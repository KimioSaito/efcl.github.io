<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        
        ECMAScript 2015以降のJavaScriptの`this`を理解する | Web Scratch
        
    </title>
    <meta name="description" content="この記事はJavaScriptの入門書として書いているjs-primerのthisに関する部分をベースにしています。またjs-primerでは書けなかった現在時点(2018年1月1日)でのブラウザの挙動についてを加えたものです。">
    
    <meta name="keywords" content="JavaScript,ECMAScript,this" />
    
    <meta name="author" content="azu">
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144"
          href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="http://efcl.info/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed/">
    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/main.css">
    <!-- JavaScript -->
    <!-- Open graph tags -->
<meta property="og:title" content="ECMAScript 2015以降のJavaScriptの`this`を理解する">
<meta property="og:type" content="article">
<meta property="og:url" content="http://efcl.info/2018/01/04/what-is-this/">
<meta property="og:image" content="http://efcl.info/public/favicon.ico">

<meta property="og:description" content="この記事はJavaScriptの入門書として書いているjs-primerのthisに関する部分をベースにしています。またjs-primerでは書けなかった現在時点(2018年1月1日)でのブラウザの挙動についてを加えたものです。">
<meta property="og:site_name" content="Web Scratch">




<meta property="article:published_time" content="2018-01-04T19:02:00+09:00">
<meta property="article:author" content="https://www.facebook.com/">

<meta property="og:see_also" content="http://efcl.info/2017/12/30/oss-in-2017/">

<meta property="og:see_also" content="http://efcl.info/2017/12/29/textlint-rule-no-invalid-control-character/">

<meta property="og:see_also" content="http://efcl.info/2017/12/26/docusaurus-almin/">





<meta property="article:section" content="javascript">





<meta property="article:tag" content="JavaScript">

<meta property="article:tag" content="ECMAScript">

<meta property="article:tag" content="this">


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2184335-8', 'auto');
    ga('send', 'pageview');
</script>
    <script>
var blog_categories = [
{
    "title" : "greasemonkey",
    "count" : 61
},{
    "title" : "ニコニコ動画",
    "count" : 16
},{
    "title" : "小説電子化",
    "count" : 3
},{
    "title" : "vista",
    "count" : 12
},{
    "title" : "firefox",
    "count" : 55
},{
    "title" : "その他",
    "count" : 13
},{
    "title" : "webサービス",
    "count" : 22
},{
    "title" : "software",
    "count" : 59
},{
    "title" : "雑記",
    "count" : 37
},{
    "title" : "まとめ",
    "count" : 11
},{
    "title" : "zaurus",
    "count" : 3
},{
    "title" : "ハードウェア",
    "count" : 8
},{
    "title" : "アドオン",
    "count" : 31
},{
    "title" : "wordpress",
    "count" : 6
},{
    "title" : "javascript",
    "count" : 196
},{
    "title" : "インストール設定",
    "count" : 12
},{
    "title" : "iphone",
    "count" : 10
},{
    "title" : "loox u",
    "count" : 1
},{
    "title" : "tombloo",
    "count" : 3
},{
    "title" : "イベント",
    "count" : 92
},{
    "title" : "userchome.js",
    "count" : 8
},{
    "title" : "jetpack",
    "count" : 7
},{
    "title" : "onenote",
    "count" : 2
},{
    "title" : "nilscript",
    "count" : 4
},{
    "title" : "keysnail",
    "count" : 3
},{
    "title" : "ios",
    "count" : 15
},{
    "title" : "shell",
    "count" : 3
},{
    "title" : "r言語",
    "count" : 2
},{
    "title" : "node.js",
    "count" : 3
},{
    "title" : "mac",
    "count" : 2
},{
    "title" : "github",
    "count" : 11
},{
    "title" : "jekyll",
    "count" : 1
},{
    "title" : "golang",
    "count" : 1
},{
    "title" : "web",
    "count" : 1
},{
    "title" : "スライド",
    "count" : 1
},{
    "title" : "ie",
    "count" : 1
},{
    "title" : "書籍",
    "count" : 2
},{
    "title" : "textlint",
    "count" : 9
}
];
    blog_categories = blog_categories.filter(function(categoryObject){
        return !/^\d+$/.test(categoryObject.title);
    });
</script>
</head>


<body class="layout-reverse theme-base-0d">
<a href="https://github.com/efcl/efcl.github.io" class="github-ribbon">
    <img style="position: fixed; z-index:100; top: 0; right: 0; border: 0;"
         src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
         alt="Fork me on GitHub"
         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<header>
    <div class="site-header">
    <img src="/public/img/reimu-right.png" class="header-logo">

    <h1 class="site-title">
        <a href="/">
            Web Scratch
        </a>
    </h1>
    <p class="lead">ブラウザ/JavaScript等についてのブログ</p>

</div>
</header>
<aside>
    <div class="sidebar">
    <div class="container">
        <div class="profile">
            <a href="/about/" title="About"><img src="/public/img/azu.png" alt="Profile"></a>

            <h2><a href="/about/" title="About">azu</a></h2>
        </div>
        <div class="social">
            <a class="twitter" href="http://twitter.com/azu_re" title="Twitter">
                <img src="/public/svg/twitter.svg" alt="twitter" width="32" height="32"/>
            </a>
            <a class="github" href="https://github.com/azu" title="GitHub">
                <img src="/public/svg/github.svg" alt="GitHub" width="32" height="32"/>
            </a>
            <a class="rss" href="/feed/" title="RSS Feed">
                <img src="/public/svg/feed.svg" alt="RSS" width="32" height="32"/>
            </a>
        </div>
        <nav class="sidebar-nav">
            <div class="search">
                <form class="search-box" method="get" action="https://www.google.co.jp/search">
                    <label for="search-box-label">検索:</label>
                    <input type="hidden" name="q" value="site:efcl.info">
                    <input id="search-box-label" type="search" name="q">
                    <input type="submit" value="search">
                </form>
            </div>
            <div class="recent">
    <h3 class="recent-posts-list-title">
        <a href="/">最近の投稿</a>
    </h3>
    <ul class="recent-posts">
        
        <li>
            <a href="/2018/01/04/what-is-this/">
                ECMAScript 2015以降のJavaScriptの`this`を理解する
            </a>
        </li>
        
        <li>
            <a href="/2017/12/30/oss-in-2017/">
                今年のOSS活動振り返り @ 2017
            </a>
        </li>
        
        <li>
            <a href="/2017/12/29/textlint-rule-no-invalid-control-character/">
                文中に制御文字が混じっているのを見つけて自動修正するtextlintルール
            </a>
        </li>
        
        <li>
            <a href="/2017/12/26/docusaurus-almin/">
                AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した
            </a>
        </li>
        
    </ul>
</div>
            <div class="recent">
    <h3 class="categories-list-title"><a href="/categories">カテゴリ一覧</a></h3>

    <div class="categories-list" id="js-categories-list">

    </div>
    <script>
        (function () {
            var categoriesList = window.blog_categories;
            var appendPoint = document.getElementById("js-categories-list");
            // big ... small
            var sortedCategories = categoriesList.sort(function (a, b) {
                return a.count < b.count ? 1 : -1;
            });
            var ulTag = document.createElement("ul");
            var displayCount = sortedCategories.length < 3 ? sortedCategories.length : 3;
            for (var i = 0; i < displayCount; i++) {
                var category = sortedCategories[i];
                var liTag = document.createElement("li");
                var aTag = document.createElement("a");
                aTag.href = "/categories#" + category.title;
                aTag.textContent = category.title;
                var spanTag = document.createElement("span");
                spanTag.appendChild(document.createTextNode("[" + category.count + "]"));
                liTag.appendChild(aTag);
                liTag.appendChild(spanTag);
                ulTag.appendChild(liTag);
            }
            var lastLiTag = document.createElement("li");
            var lastATag = document.createElement("a");
            lastATag.href = "/categories";
            lastATag.textContent = "その他のタグ…";
            lastLiTag.appendChild(lastATag);
            ulTag.appendChild(lastATag);
            appendPoint.appendChild(ulTag);
        })();
    </script>
</div>
        </nav>
    </div>
</div>

</aside>
<article>
    <div class="content container">
        <div class="post" id="js-post-url" data-post-url="/2018/01/04/what-is-this/">
    <h1 class="post-title">ECMAScript 2015以降のJavaScriptの`this`を理解する</h1>

    <div class="pre-post-toolbar">
        <span class="post-date">2018年01月04日</span>
        <a class="btn edit-on-github" href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2018/2018-01-04-what-is-this.md"><span class="edito-on-github-label"></span>Edit on GitHub</a>

    </div>
    <div class="post-content">
        <p>この記事はJavaScriptの入門書として書いている<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>の<code>this</code>に関する部分をベースにしています。
またjs-primerでは書けなかった現在時点(2018年1月1日)でのブラウザの挙動についてを加えたものです。</p>

<p>次の場所に<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>版のか<code>this</code>についての解説があります。
この記事と違って実際にコードを実行しながら読めるので、学習ソースとしては<a href="https://asciidwango.github.io/js-primer/basic/function-this/">js-primer版</a>を推奨します。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></li>
</ul>

<p>また、バグ報告やPRも直接リポジトリにして問題ありません。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a></li>
</ul>

<p>おかしい場所を選択した状態で右下にある&quot;Bug Report&quot;ボタンを押せば、簡単にtypoとかのバグを報告できます。(PRでも歓迎)</p>

<p><a href="https://asciidwango.github.io/js-primer/basic/function-this/"><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515061693.png" alt="バグ報告のフロー"></a></p>

<p>前置きはこの辺までで、ここから本編。</p>

<h1 id="ecmascript-2015以降のthis">ECMAScript 2015以降の<code>this</code></h1>

<p>この記事では<code>this</code>という特殊な動作をするキーワードについてを見ていきます。
<code>this</code>は基本的にはメソッドの中で利用します。しかし、<code>this</code>は読み取り専用のグローバル変数のようなものでどこにでも書くことができます。
また、<code>this</code>の参照先（値）は条件によってさまざまです。</p>

<p><code>this</code>の参照先は主に次の条件によって変化します。</p>

<ul>
<li>実行コンテキストにおける<code>this</code></li>
<li>コンストラクタにおける<code>this</code></li>
<li>関数とメソッドにおける<code>this</code></li>
<li>Arrow Functionにおける<code>this</code></li>
</ul>

<p>もっとも複雑な条件が存在するのは「関数とメソッドにおける<code>this</code>」です。
そのためこの記事では関数と<code>this</code>の関係を主に扱います。
(コンストラクタにおける<code>this</code>はクラスと一緒に学んだ方がいいので省きます。)</p>

<p>この記事では、さまざまな条件下で変わる<code>this</code>の参照先と関数やArrow Functionとの関係を見ていきます。</p>

<h2 id="目標-thisの評価結果を理解する">目標: <code>this</code>の評価結果を理解する</h2>

<p><code>this</code>はさまざまな条件でその評価結果(参照先)は異なります。
基本的な関数やメソッドについては次のようなパターンが考えられます。</p>

<p>この記事では<code>???</code>となっている<code>this</code>の評価結果がなぜそうなるのかを理解できることを目標にします。</p>

<p><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515062180.png" alt="`this`の評価結果の穴埋め"></p>

<ul>
<li><code>＊</code>はどの場合でも結果に影響しないということを示すワイルドカード</li>
<li>関数は<code>fn()</code>と実行した場合の<code>this</code>の評価結果、メソッドは<code>obj.method()</code>と実行した場合の<code>this</code>の評価結果</li>
</ul>

<p>表の結果がすべてわかっている人にはこの記事は不要だと思います。</p>

<ul>
<li><a href="https://gist.github.com/azu/ca9d5a0f4b7c137bc5e2453f8783bf8c">Gist: 穴埋め用の<code>this</code>表</a></li>
</ul>

<p>記事の最後に答え合わせ用の表を置いています。</p>

<h2 id="実行コンテキストとthis">実行コンテキストと<code>this</code></h2>

<p>JavaScriptには実行コンテキストとして&quot;Script&quot;と&quot;Module&quot;があります。
トップレベルにある<code>this</code>は、実行コンテキストによって値が異なります。
実行コンテキストの違いは意識しにくい部分であり、トップレベルで<code>this</code>を使うことは混乱を生むことになります。
そのため、コードのトップレベルにおいては<code>this</code>を使うべきではありませんが、それぞれの実行コンテキストにおける動作を紹介します。</p>

<h3 id="スクリプトにおけるthis">スクリプトにおける<code>this</code></h3>

<p>実行コンテキストが&quot;Script&quot;である場合、そのコード直下に書かれた<code>this</code>はグローバルオブジェクトを参照します。
グローバルオブジェクトとは、実行環境において異なるものが定義されています。
ブラウザなら<code>window</code>オブジェクト、Node.jsなら<code>global</code>オブジェクトとなります。</p>

<p>ブラウザでは、<code>script</code>要素の<code>type</code>属性を指定してない場合は実行コンテキストが&quot;Script&quot;として実行されます。
この<code>script</code>要素の直下に書いた<code>this</code>はグローバルオブジェクトである<code>window</code>オブジェクトとなります。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script&gt;</span>
<span class="c1">// 実行コンテキストは&quot;Script&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; window</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<h3 id="モジュールにおけるthis">モジュールにおける<code>this</code></h3>

<p>実行コンテキストが&quot;Module&quot;である場合、そのコード直下に書かれた<code>this</code>は常に<code>undefined</code>となります。</p>

<p>ブラウザでは、<code>script</code>要素の<code>type=&quot;module&quot;</code>属性がついた場合は実行コンテキストが&quot;Module&quot;として実行されます。
この<code>script</code>要素の直下に書いた<code>this</code>は<code>undefined</code>となります。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="c1">// 実行コンテキストは&quot;Module&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>このように、コード直下の<code>this</code>は実行コンテキストによって<code>undefined</code>となる場合があります。
単純にグローバルオブジェクトを参照したい場合は、<code>this</code>ではなく<code>window</code>などのグローバルオブジェクトを直接参照した方がよいです。</p>

<h4 id="📝-note">📝 Note</h4>

<p>なぜModuleコンテキストではトップレベルの<code>this</code>が<code>undefined</code>となるかは次の記事で解説しています。</p>

<ul>
<li><a href="http://efcl.info/2015/05/06/this-is-es6-module/" title="ES6 moduleのtop levelにある`this`の値は何になるのか? | Web Scratch">ES6 moduleのtop levelにある<code>this</code>の値は何になるのか? | Web Scratch</a></li>
</ul>

<p>また現時点では環境へ依存せずにグローバルオブジェクトを取得するのはややこしい方法が必要です。
しかし、現在(2018-01-01) Stage 3のProposalである<code>global</code>が将来的には利用できます。</p>

<ul>
<li><a href="https://github.com/tc39/proposal-global" title="tc39/proposal-global: ECMAScript Proposal, specs, and reference implementation for `global`">tc39/proposal-global: ECMAScript Proposal, specs, and reference implementation for <code>global</code></a></li>
</ul>

<h2 id="関数とメソッドにおけるthis">関数とメソッドにおける<code>this</code></h2>

<p><strong>関数</strong>を定義する方法として、<code>function</code>キーワードによる関数宣言と関数式、Arrow Functionなどがあります。
<code>this</code>が参照先を決めるルールはArrow Functionとそれ以外の方法で異なります。</p>

<p>まずは<strong>Arrow Function以外</strong>の関数やメソッドにおける<code>this</code>を見ていきます。</p>

<h2 id="arrow-function以外の関数におけるthis">Arrow Function以外の関数における<code>this</code></h2>

<p>Arrow Function以外の関数（メソッドも含む)における<code>this</code>は実行時に決まる値となります。
言い方をかえると<code>this</code>は関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行する時に決まります。</p>

<p>次のコードは擬似的なものです。
関数の中に書かれた<code>this</code>は、関数の呼び出し元から暗黙的に渡される値を参照することになります。
このルールはArrow Function以外の関数やメソッドで共通した仕組みとなります。Arrow Functionで定義した関数やメソッドはこのルールとは別の仕組みとなります。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 擬似的な`this`の値の仕組み</span>
<span class="c1">// 関数は引数として暗黙的に`this`の値を受け取るイメージ</span>
<span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="err">暗黙的渡される</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="err">仮引数</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; 暗黙的渡されるthisの値</span>
<span class="p">}</span>
<span class="c1">// 暗黙的に`this`の値を引数として渡しているイメージ</span>
<span class="nx">fn</span><span class="p">(</span><span class="err">暗黙的に渡す</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="err">引数</span><span class="p">);</span>
</code></pre></div>
<!-- textlint-disable no-js-function-paren -->

<p>関数における<code>this</code>の基本的な参照先（暗黙的に関数に渡す<code>this</code>の値）は<strong>ベースオブジェクト</strong>となります。
ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
ベースオブジェクトがない場合の<code>this</code>は<code>undefined</code>となります。</p>

<p>たとえば、<code>fn()</code>のように関数を呼び出したとき、この<code>fn</code>関数呼び出しのベースオブジェクトはないため、<code>this</code>は<code>undefiend</code>となります。
一方、<code>obj.method()</code>のようにメソッドを呼び出したとき、この<code>obj.method</code>メソッド呼び出しのベースオブジェクトは<code>obj</code>オブジェクトとなり、<code>this</code>は<code>obj</code>となります。</p>

<!-- textlint-enable no-js-function-paren -->

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `fn`関数はメソッドではないのでベースオブジェクトはない</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// `obj.method`メソッドのベースオブジェクトは`obj`</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
<span class="c1">// `obj1.obj2.method`メソッドのベースオブジェクトは`obj2`</span>
<span class="c1">// ドット演算子、ブラケット演算子どちらも結果は同じ</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
<span class="nx">obj1</span><span class="p">[</span><span class="s2">&quot;obj2&quot;</span><span class="p">][</span><span class="s2">&quot;method&quot;</span><span class="p">]();</span>
</code></pre></div>
<p><code>this</code>は関数の定義ではなく呼び出し方で参照する値が異なります。これは、後述する「<code>this</code>が問題となるパターン」で詳しく紹介します。
Arrow Function以外の関数では、関数の定義だけを見て<code>this</code>の値が何かということは決定できない点には注意が必要です。</p>

<h3 id="関数宣言や関数式におけるthis">関数宣言や関数式における<code>this</code></h3>

<p>まずは、関数宣言や関数式の場合を見ていきます。</p>

<p>次の例では、関数宣言と関数式で定義した関数の中の<code>this</code>をコンソールに出力しています。
このとき、<code>fn1</code>と<code>fn2</code>はただの関数として呼び出されています。
つまり、ベースオブジェクトがないため<code>this</code>は<code>undefined</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">fn1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 関数の中の`this`が参照する値は呼び出し方によって決まる</span>
<span class="c1">// `fn1`と`fn2`どちらもただの関数として呼び出している</span>
<span class="c1">// メソッドとして呼び出していないためベースオブジェクトはない</span>
<span class="c1">// ベースオブジェクトがない場合、`this`は`undefined`となる</span>
<span class="nx">fn1</span><span class="p">();</span> <span class="c1">// =&gt; undefined</span>
<span class="nx">fn2</span><span class="p">();</span> <span class="c1">// =&gt; undefined</span>
</code></pre></div>
<p>これは、関数の中に関数を定義して呼びだす場合も同じです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
    <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
    <span class="p">}</span>
    <span class="c1">// `inner`関数呼び出しのベースオブジェクトはない</span>
    <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// `outer`関数呼び出しのベースオブジェクトはない</span>
<span class="nx">outer</span><span class="p">();</span>
</code></pre></div>
<p>この書籍では注釈がないコードはstrict modeとして扱いますが、コード例に<code>&quot;use strict&quot;;</code>でstrict modeを明示しています。
なぜなら、strict modeではない場合に<code>this</code>が<code>undefined</code>の場合は、<code>this</code>がグローバルオブジェクトへと暗黙的に変換されてしまう問題があるからです。
strict modeかどうかによって挙動が異なるのは混乱の元であるため、関数呼び出しする関数においては<code>this</code>を使うべきではありません。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Strict_mode" title="Strict モード - JavaScript | MDN">Strict モード - JavaScript | MDN</a></li>
</ul>

<h3 id="メソッド呼び出しにおけるthis">メソッド呼び出しにおける<code>this</code></h3>

<p>次に、メソッドの場合を見ていきます。
メソッドの場合は、そのメソッドは何かしらのオブジェクトに所属しています。
なぜなら、JavaScriptではオブジェクトのプロパティとして指定される関数のことをメソッドと呼ぶためです。</p>

<p>次の例では<code>method1</code>と<code>method2</code>はそれぞれメソッドとして呼び出されています。
このとき、それぞれのベースオブジェクトは<code>object</code>となり、<code>this</code>は<code>object</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 関数式をプロパティの値にしたメソッド</span>
    <span class="nx">method1</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="c1">// 短縮記法で定義したメソッド</span>
    <span class="nx">method2</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// メソッド呼び出しの場合、それぞれの`this`はベースオブジェクト(`object`)を参照する</span>
<span class="c1">// メソッド呼び出しの`.`の左にあるオブジェクトがベースオブジェクト</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">method1</span><span class="p">();</span> <span class="c1">// =&gt; object</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">method2</span><span class="p">();</span> <span class="c1">// =&gt; object</span>
</code></pre></div>
<p>これを利用すれば、メソッドの中から同じオブジェクトに所属する別のプロパティを<code>this</code>で参照できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// `person.fullName`と書いているのと同じ</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `person.fullName`を出力する</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">());</span> <span class="c1">// =&gt; &quot;Brendan Eich&quot;</span>
</code></pre></div>
<p>このようにメソッドが所属するオブジェクトのプロパティを、<code>オブジェクト名.プロパティ名</code>の代わりに<code>this.プロパティ名</code>で参照できます。</p>

<p>オブジェクトは何重にもネストできますが、<code>this</code>はベースオブジェクトを参照するというルールは同じです。</p>

<p>次のコードを見てみると、ネストしたオブジェクトにおいてメソッド内の<code>this</code>がベースオブジェクトである<code>obj3</code>を参照していることが分かります。
このときのベースオブジェクトはドットで繋いだ一番左の<code>obj1</code>ではなく、メソッドから見てひとつ左の<code>obj3</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">obj2</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">obj3</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `obj1.obj2.obj3.method`メソッドの`this`は`obj3`を参照</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">obj3</span><span class="p">.</span><span class="nx">method</span><span class="p">()</span> <span class="o">===</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">obj3</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<h2 id="thisが問題となるパターン"><code>this</code>が問題となるパターン</h2>

<p><code>this</code>はその関数（メソッドも含む）呼び出しのベースオブジェクトを参照することがわかりました。
<code>this</code>は所属するオブジェクトを直接書く代わりとして利用できますが、一方<code>this</code>には色々な問題があります。</p>

<p>この問題の原因は<code>this</code>がどの値を参照するかは関数の呼び出し時に決まるという性質に由来します。
この<code>this</code>の性質が問題となるパターンの代表的な2つの例とそれぞれの対策についてを見ていきます。</p>

<h3 id="問題-thisを含むメソッドを変数に代入した場合">問題: <code>this</code>を含むメソッドを変数に代入した場合</h3>

<p>JavaScriptではメソッドとして定義したものが、後からただの関数として呼び出されることがあります。
なぜなら、メソッドは関数を値にもつプロパティのことで、プロパティは変数に代入し直すことができるためです。</p>

<p>そのため、メソッドとして定義した関数も、別の変数に代入してただの関数として呼び出されることがあります。
この場合には、メソッドとして定義した関数であっても、実行時にはただの関数であるためベースオブジェクトが変わっています。
これは<code>this</code>が定義した時点ではなく実行した時に決まるという性質そのものです。</p>

<p>具体的に、<code>this</code>が実行時に変わる例を見ていましょう。
次の例では、<code>person.sayName</code>メソッドを変数<code>say</code>に代入してから実行しています。
このときの<code>say</code>関数(<code>sayName</code>メソッドを参照)のベースオブジェクトはありません。
そのため、<code>this</code>は<code>undefined</code>となり、<code>undefined.fullName</code>は参照できずに例外をなげます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// `this`は呼び出し元によってことなる</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `sayName`メソッドは`person`オブジェクトに所属する</span>
<span class="c1">// `this`は`person`オブジェクトとなる</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// =&gt; &quot;Brendan Eich&quot;</span>
<span class="c1">// `person.sayName`を`say`変数に代入する</span>
<span class="kr">const</span> <span class="nx">say</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">;</span>
<span class="c1">// 代入したメソッドを関数として呼ぶ</span>
<span class="c1">// この`say`関数はどのオブジェクトにも所属していない</span>
<span class="c1">// `this`はundefinedとなるため例外を投げる</span>
<span class="nx">say</span><span class="p">();</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p>結果的には、次のようなコードが実行されているのと同じです。
次のコードでは、<code>undefined.fullName</code>を参照しようとして例外が発生しています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// const sayName = person.sayName; は次のようなイメージ</span>
<span class="kr">const</span> <span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// `this`は`undefined`となるため例外をなげる</span>
<span class="nx">say</span><span class="p">();</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p>このように、Arrow Function以外の関数において、<code>this</code>は定義した時ではなく実行した時に決定されます。
そのため、関数に<code>this</code>を含んでいる場合、その関数は意図した呼ばれ方がされないと間違った結果が発生するという問題があります。</p>

<p>この問題の対処法法としては大きく分けて2つあります。</p>

<p>ひとつはメソッドとして定義されている関数はメソッドとして呼ぶということです。
メソッドをわざわざただの関数として呼ばなければそもそもこの問題は発生しません。</p>

<p>もうひとつは、<code>this</code>の値を指定して関数を呼べるメソッドで関数を実行する方法です。</p>

<h3 id="対処法-call、apply、bindメソッド">対処法: call、apply、bindメソッド</h3>

<p>関数やメソッドの<code>this</code>を明示的に指定して関数を実行する方法もあります。
<code>Function</code>（関数オブジェクト）には<code>call</code>、<code>apply</code>、<code>bind</code>といった明示的に<code>this</code>を指定して関数を実行するメソッドが用意されています。</p>

<p><code>call</code>メソッドは第一引数に<code>this</code>としたい値を指定し、残りの引数は呼びだす関数の引数となります。
暗黙的に渡される<code>this</code>の値を明示的に渡せるメソッドといえます。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">...</span><span class="err">関数の引数</span><span class="p">);</span>
</code></pre></div>
<p>次の例では<code>this</code>に<code>person</code>オブジェクトを指定した状態で<code>say</code>関数を呼び出しています。
<code>call</code>メソッドの第二引数で指定した値が、<code>say</code>関数の仮引数<code>message</code>に入ります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`にして`say`関数を呼びだす</span>
<span class="nx">say</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
<span class="c1">// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生</span>
<span class="nx">say</span><span class="p">(</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p><code>apply</code>メソッドは第一引数に<code>this</code>とする値を指定し、第二引数に関数の引数を配列として渡します。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">[</span><span class="err">関数の引数</span><span class="mi">1</span><span class="p">,</span> <span class="err">関数の引数</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div>
<p>次の例では<code>this</code>に<code>person</code>オブジェクトを指定した状態で<code>say</code>関数を呼び出しています。
<code>apply</code>メソッドの第二引数で指定した配列は、自動的に展開されて<code>say</code>関数の仮引数<code>message</code>に入ります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`にして`say`関数を呼びだす</span>
<span class="c1">// callとは異なり引数を配列として渡す</span>
<span class="nx">say</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
<span class="c1">// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生</span>
<span class="nx">say</span><span class="p">(</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p><code>call</code>メソッドと<code>apply</code>メソッドの違いは、関数の引数への値の渡し方が異なるだけです。
また、どちらのメソッドも<code>this</code>の値が不要な場合は<code>null</code>を渡すのが一般的です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// `this`は不要な場合はnullを渡す</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// =&gt; 3</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="c1">// =&gt; 3</span>
</code></pre></div>
<p>最後に<code>bind</code>メソッドについてです。
名前のとおり<code>this</code>の値を束縛（bind）した新しい関数を作成します。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">...</span><span class="err">関数の引数</span><span class="p">);</span> <span class="c1">// =&gt; thisや引数がbindされた関数</span>
</code></pre></div>
<p>次の例では<code>this</code>を<code>person</code>オブジェクトに束縛した<code>say</code>関数の関数を作っています。
<code>bind</code>メソッドの第二引数以降に値を渡すことで、束縛した関数の引数も束縛できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`に束縛した`say`関数をラップした関数を作る</span>
<span class="kr">const</span> <span class="nx">sayPerson</span> <span class="o">=</span> <span class="nx">say</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span>
<span class="nx">sayPerson</span><span class="p">();</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
</code></pre></div>
<p>この<code>bind</code>メソッドをただの関数で表現すると次のように書けます。
<code>bind</code>は<code>this</code>や引数を束縛した関数を作るメソッドということがわかります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`に束縛した`say`関数をラップした関数を作る</span>
<span class="c1">//  say.bind(person, &quot;こんにちは&quot;); は次のようなラップ関数を作る</span>
<span class="kr">const</span> <span class="nx">sayPerson</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">say</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">sayPerson</span><span class="p">();</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
</code></pre></div>
<p>このように<code>call</code>、<code>apply</code>、<code>bind</code>メソッドを使うことで<code>this</code>を明示的に指定した状態で関数を呼び出せます。
しかし、毎回関数を呼びだすたびにこれらのメソッドを使うのは、関数を呼びだすための関数が必要になってしまい手間がかかります。
そのため、基本的には「メソッドとして定義されている関数はメソッドとして呼ぶこと」でこの問題を回避するほうがよいでしょう。
その中で、どうしても<code>this</code>を固定したい場合には<code>call</code>、<code>apply</code>、<code>bind</code>メソッドを利用します。</p>

<h3 id="問題-コールバック関数とthis">問題: コールバック関数と<code>this</code></h3>

<p>コールバック関数の中で<code>this</code>を参照すると問題となる場合があります。
この問題は、メソッドの中で<code>Array#map</code>メソッドなどコールバック関数を扱う場合に発生しやすいです。</p>

<p>具体的に、コールバック関数における<code>this</code>が問題となっている例を見てみましょう。
次のコードでは<code>prefixArray</code>メソッドの中で<code>Array#map</code>メソッドを使っています。
このとき、<code>Array#map</code>メソッドのコールバック関数の中で、<code>Prefixer</code>オブジェクトを参照するつもりで<code>this</code>を参照しています。</p>

<p>しかし、このコールバック関数における<code>this</code>は<code>undefined</code>となり、<code>this.prefix</code>は<code>undefined.prefix</code>であるためTypeErrorとなります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="cm">/**</span>
<span class="cm">     * `strings`配列の各要素にprefixをつける</span>
<span class="cm">     */</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// コールバック関数における`this`は`undefined`となる(strict mode)</span>
            <span class="c1">// そのため`this.prefix`は`undefined.prefix`となり例外が発生する</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;prefix&#39; of undefined</span>
</code></pre></div>
<p>なぜコールバック関数の中での<code>this</code>が<code>undefined</code>となるのかを見ていきます。
<code>Array#map</code>メソッドにはコールバック関数として、その場で定義した匿名関数を渡していることに注目してください。</p>

<!-- textlint-disable eslint -->

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// ...</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 匿名関数をコールバック関数として渡している</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div>
<!-- textlint-enable eslint -->

<!-- textlint-disable no-js-function-paren -->

<p>このとき、<code>Array#map</code>メソッドに渡しているコールバック関数は<code>callback()</code>のようにただの関数として呼び出されます。
つまり、コールバック関数として呼びだすとき、この関数にはベースオブジェクトはありません。
そのため<code>callback</code>関数の<code>this</code>は<code>undefined</code>となります。</p>

<p>先ほどの匿名関数をコールバック関数として渡しているのは、一度<code>callback</code>変数に入れてから渡しても結果は同じです。</p>

<!-- textlint-enable no-js-function-paren -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="cm">/**</span>
<span class="cm">     * `strings`配列の各要素にprefixをつける</span>
<span class="cm">     */</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// コールバック関数は`callback()`のように呼び出される</span>
        <span class="c1">// そのためコールバック関数における`this`は`undefined`となる(strict mode)</span>
        <span class="kr">const</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;prefix&#39; of undefined</span>
</code></pre></div>
<h4 id="対処法-thisを一時変数へ代入する">対処法: <code>this</code>を一時変数へ代入する</h4>

<p>コールバック関数内での<code>this</code>の参照先が変わる問題への対処法として、<code>this</code>を別の変数に代入し、その<code>this</code>の参照先を保持するという方法があります。</p>

<p><code>this</code>は関数の呼び出し元で変化し、その参照先は呼び出し元におけるベースオブジェクトです。
<code>prefixArray</code>メソッドの呼び出しにおいては、<code>this</code>は<code>Prefixer</code>オブジェクトです。
しかし、コールバック関数はあらためて関数として呼び出されるため<code>this</code>が<code>undefined</code>となってしまうのが問題でした。</p>

<p>そのため、最初の<code>prefixArray</code>メソッド呼び出しにおける<code>this</code>の参照先を一時変数として保存することでこの問題を回避できます。
つぎのように、<code>prefixArray</code>メソッドの<code>this</code>を<code>that</code>変数に保持しています。
コールバック関数からは<code>this</code>の代わりに<code>that</code>変数を参照することで、コールバック関数からも<code>prefixArray</code>メソッド呼び出しと同じ<code>this</code>を参照できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="cm">/**</span>
<span class="cm">     * `strings`配列の各要素にprefixをつける</span>
<span class="cm">     */</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// `that`は`prefixArray`メソッド呼び出しにおける`this`となる</span>
        <span class="c1">// つまり`that`は`Prefixer`オブジェクトを参照する</span>
        <span class="kr">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `this`ではなく`that`を参照する</span>
            <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>もちろん<code>Function#call</code>メソッドなどで明示的に<code>this</code>を渡して関数を呼びだすこともできます。
また、<code>Arry#map</code>メソッドなどは<code>this</code>となる値引数として渡せる仕組みを持っています。
そのため、つぎのように第二引数に<code>this</code>となる値を渡すことでも解決できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="cm">/**</span>
<span class="cm">     * `strings`配列の各要素にprefixをつける</span>
<span class="cm">     */</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// `Array#map`メソッドは第二引数に`this`となる値を渡せる</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `this`が第二引数の値と同じになる</span>
            <span class="c1">// つまり`prefixArray`メソッドと同じ`this`となる</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">},</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>しかし、これら解決方法はコールバック関数において<code>this</code>が変わることを意識して書く必要があります。
そもそもの問題としてメソッド呼び出しとその中でのコールバック関数における<code>this</code>が変わってしまうのが問題でした。
ES2015では<code>this</code>を変えずにコールバック関数を定義する方法として、Arrow Functionが導入されました。</p>

<h3 id="対処法-arrow-functionでコールバック関数を扱う">対処法: Arrow Functionでコールバック関数を扱う</h3>

<p>通常の関数やメソッドは呼び出し時に暗黙的に<code>this</code>の値を受け取り、関数内の<code>this</code>はその値を参照します。
一方、Arrow Functionはこの暗黙的な<code>this</code>の値を受け取りません。
そのためArrow Function内の<code>this</code>は、スコープチェーンの仕組みと同様で外側の関数(この場合は<code>prefixArray</code>メソッド)に探索します。
これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数の<code>this</code>をそのまま利用します。</p>

<p>Arrow Functionを使うことで、先ほどのコードは次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Arrow Function自体は`this`を持たない</span>
            <span class="c1">// `this`は外側の`prefixArray`関数がもつ`this`を参照する</span>
            <span class="c1">// そのため`this.prefix`は&quot;pre&quot;となる</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// この時、`prefixArray`のベースオブジェクトは`Prefixer`となる</span>
<span class="c1">// つまり、`prefixArray`メソッド内の`this`は`Prefixer`を参照する</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>このように、Arrow Functionでのコールバック関数における<code>this</code>は簡潔です。
そのため、コールバック関数内での<code>this</code>の対処法として<code>this</code>を代入する方法を紹介しましたが、
ES2015からはArrow Functionを使うのがもっとも簡潔です。</p>

<p>このArrow Functionと<code>this</code>の関係についてもっと詳しく見ていきます。</p>

<h2 id="arrow-functionとthis">Arrow Functionと<code>this</code></h2>

<p>Arrow Functionで定義された関数やメソッドにおける<code>this</code>がどの値を参照するかは関数の定義時（静的）に決まります。
一方、Arrow Functionではない関数においては、<code>this</code>は呼び出し元に依存するため関数の実行時（動的）に決まります。</p>

<p>Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionは<code>this</code>を暗黙的な引数として受け付けないということです。
そのため、Arrow Function内には<code>this</code>が定義されていません。このときの<code>this</code>は外側のスコープ（関数）の<code>this</code>を参照します。</p>

<p>これは変数におけるスコープチェーンの仕組みと同様で、そのスコープに<code>this</code>が定義されていない場合には外側のスコープを探索するのと同じです。
そのため、Arrow Function内の<code>this</code>の参照先は、常に外側のスコープ（関数）へと<code>this</code>の定義を探索しに行きます（詳細は<a href="https://asciidwango.github.io/js-primer/basic/function-scope/##scope-chain%7D">スコープチェーン</a>を参照）。
また、<code>this</code>は読み取り専用のキーワードであるため、ユーザーが<code>this</code>という変数を定義できません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="k">this</span> <span class="o">=</span> <span class="s2">&quot;thisは読み取り専用&quot;</span><span class="p">;</span> <span class="c1">// =&gt; SyntaxError: Unexpected token this</span>
</code></pre></div>
<p>これにより、Arrow Functionにおける<code>this</code>は通常の変数と同じように、どの値を参照するかは静的に決まるという性質があります（詳細は<a href="https://asciidwango.github.io/js-primer/basic/function-scope/#static-scope">静的スコープ</a>を参照）。
つまりArrow Functionにおける<code>this</code>の参照先は「Arrow Function自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」となります。</p>

<p>具体的な例を元にArrow Functionにおける<code>this</code>の動きを見ていきましょう。</p>

<p>まずは、関数式のArrow Functionを見ていきます。</p>

<p>次の例では、関数式で定義したArrow Functionの中の<code>this</code>をコンソールに出力しています。
このとき、<code>fn</code>の外側には関数はないため、「自身より外側のスコープにあるもっとも近い関数」の条件にあてはまるものはありません。
このときの<code>this</code>はトップレベルに書かれた<code>this</code>と同じ値になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Arrow Functionで定義した関数</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// この関数の外側には関数は存在しない</span>
    <span class="c1">// トップレベルの`this`と同じ値</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">fn</span><span class="p">()</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>トップレベルに書かれた<code>this</code>の値は実行コンテキストによって異なることを紹介しました。
<code>this</code>の値は、実行コンテキストが&quot;Script&quot;ならばグローバルオブジェクトとなり、&quot;Module&quot;ならば<code>undefined</code>となります。</p>

<p>次の例のように、Arrow Functionを包むように通常の関数が定義されている場合はどうでしょうか。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrow Functionで定義した関数を返す</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// この関数の外側には`outer`関数が存在する</span>
        <span class="c1">// `outer`関数に`this`を書いた場合と同じ</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// `outer`関数の返り値はArrow Functionにて定義された関数</span>
<span class="kr">const</span> <span class="nx">innerArrowFunction</span> <span class="o">=</span> <span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">innerArrowFunction</span><span class="p">());</span> <span class="c1">// =&gt; undefined;</span>
</code></pre></div>
<p>Arrow Functionにおける<code>this</code>は「自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」となります。
つまり、このArrow Functionにおける<code>this</code>は<code>outer</code>関数で<code>this</code>を参照した場合と同じ値になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// `outer`関数直下の`this`</span>
    <span class="kr">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="c1">// Arrow Functionで定義した関数を返す</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Arrow Function自身は`this`を持たない</span>
        <span class="c1">// `outer`関数に`this`を書いた場合と同じ</span>
        <span class="k">return</span> <span class="nx">that</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// `outer()`と呼び出した時の`this`は`undefined`(strict mode)</span>
<span class="kr">const</span> <span class="nx">innerArrowFunction</span> <span class="o">=</span> <span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">innerArrowFunction</span><span class="p">());</span> <span class="c1">// =&gt; undefined;</span>
</code></pre></div>
<h3 id="メソッドとコールバック関数とarrow-function">メソッドとコールバック関数とArrow Function</h3>

<p>メソッド内におけるコールバック関数はArrow Functionをもっと活用できるパターンです。
<code>function</code>キーワードでコールバック関数を定義すると、<code>this</code>の値はコールバック関数の呼ばれ方を意識する必要があります。
なぜなら、<code>function</code>キーワードで定義した関数における<code>this</code>は呼び出し方によって変わるためです。</p>

<p>コールバック関数側から見ると、どのように呼ばれるかによって変わる<code>this</code>を使うことはエラーとなる場合もあるため使えません。
そのため、コールバック関数の外側のスコープで<code>this</code>を一時変数に代入し、それを使うという回避を取っていました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `callback`関数を受け取り呼び出す関数</span>
<span class="kr">const</span> <span class="nx">callCallback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// `callback`を呼び出す実装</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">callCallback</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// ここでの `this` は`callCallback`の実装に依存する</span>
            <span class="c1">// `callback()`のように単純に呼び出されるなら`this`は`undefined`になる</span>
            <span class="c1">// `Function#call`などを使い特定のオブジェクトを指定するかもしれない</span>
            <span class="c1">// この問題を回避するために`const that = this`のような一時変数を使う</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>一方、Arrow Functionでコールバック関数を定義した場合は、1つ外側の関数の<code>this</code>を参照します。
このときのArrow Functionで定義したコールバック関数における<code>this</code>は呼び出し方によって変化しません。
そのため、<code>this</code>を一時変数に代入するなどの回避方法は必要ありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `callback`関数を受け取り呼び出す関数</span>
<span class="kr">const</span> <span class="nx">callCallback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// `callback`を呼び出す実装</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">callCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// ここでの`this`は1つ外側の関数における`this`と同じ</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>このArrow Functionにおける<code>this</code>は呼び出し方の影響を受けません。
つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなく<code>this</code>を扱うことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// `Prefixer.prefixArray()` と呼び出されたとき</span>
            <span class="c1">// `this`は常に`Prefixer`を参照する</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<h3 id="arrow-functionはthisをbindできない">Arrow Functionは<code>this</code>をbindできない</h3>

<p>Arrow Functionで定義した関数には<code>call</code>、<code>apply</code>、<code>bind</code>を使った<code>this</code>の指定は単に無視されます。
これは、Arrow Functionは<code>this</code>をもつことができないためです。</p>

<p>次のようにArrow Functionで定義した関数に対して<code>call</code>で<code>this</code>をしても、<code>this</code>の参照先が代わっていないことが分かります。
同様に<code>apply</code>や<code>bind</code>メソッドを使った場合も<code>this</code>の参照先が変わりません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Scriptコンテキストの場合、スクリプト直下のArrow Functionの`this`はグローバルオブジェクト</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span> <span class="c1">// グローバルオブジェクト</span>
<span class="c1">// callで`this`を`{}`にしようとしても、`this`は変わらない</span>
<span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">({});</span> <span class="c1">// グローバルオブジェクト</span>
</code></pre></div>
<p>最初に述べたよう<code>function</code>キーワードで定義した関数は呼び出し時に、ベースオブジェクトが暗黙的な引数のように<code>this</code>の値として渡されます。
一方、Arrow Functionの関数は呼び出し時に<code>this</code>を受け取らずに、定義時のArrow Functionにおける<code>this</code>の参照先が静的に決定されます。</p>

<!-- textlint-disable -->

<p>また、<code>this</code>が変わらないのはあくまでArrow Functionで定義した関数だけで、Arrow Functionの<code>this</code>が参照する「自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」は<code>call</code>メソッドで変更できます。</p>

<!-- textlint-enable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">arrowFunction</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nx">arrowFunction</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 通常の`this`は`object.method`の`this`と同じ</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">());</span> <span class="c1">// =&gt; object</span>
<span class="c1">// `object.method`の`this`を変更すれば、Arrow Functionの`this`も変更される</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s2">&quot;THAT&quot;</span><span class="p">));</span> <span class="c1">// =&gt; &quot;THAT&quot;</span>
</code></pre></div>
<h2 id="thisの評価結果のまとめ"><code>this</code>の評価結果のまとめ</h2>

<p><code>this</code>は状況によって異なる値を参照する性質を持ったキーワードであることについてを紹介しました。
その<code>this</code>の評価結果をまとめると次の表のようになります。</p>

<p><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515062936.png" alt="`this`の評価結果のまとめ"></p>

<!-- textlint-disable -->

<p>実際にブラウザで実行した結果は<a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a>で確認できます。</p>

<!-- textlint-enable -->

<p>Chrome 63を使ってる人は&quot;Module&quot;コンテキストのトップレベルArrow Functionにおける<code>this</code>の挙動が表と一致しないことに気づいたかもしれません。
Chrome 63では次のコードを&quot;Module&quot;コンテキストで実行すると<code>this</code>が<code>undefined</code>ではなく、グローバルオブジェクトを参照します。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="c1">// &quot;Module&quot; context @ Chrome 63</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span> <span class="c1">// =&gt; window</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>これはChrome(V8)のバグです。すでに報告して最新のCanary(65相当)では修正されています。</p>

<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791334" title="791334 - `this` in top level Arrow Function in Module Context should be `undefined` - chromium - Monorail">791334 - <code>this</code> in top level Arrow Function in Module Context should be <code>undefined</code> - chromium - Monorail</a></li>
</ul>

<p>Chrome 63とChrome 65では次のサイトの結果は異なることが分かります。</p>

<ul>
<li><a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a></li>
</ul>

<h2 id="まとめ">まとめ</h2>

<p><code>this</code>はオブジェクト指向プログラミングのメソッドでの利用を目的としています。
メソッド以外においても<code>this</code>は評価できますが、実行コンテキストやstrict modeなどによって結果が異なり混乱の元となります。
そのため、メソッド以外では<code>this</code>を使うべきではありません（ここでは紹介してないコンストラクタは例外です）</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">+infinity<br>JS `this` is for OO methods, not standalone functions. Never use `this` as a parameter to non-method functions. <a href="https://t.co/tFHkqEepcM">https://t.co/tFHkqEepcM</a></p>&mdash; Allen Wirfs-Brock (@awbjs) <a href="https://twitter.com/awbjs/status/938272440085446657?ref_src=twsrc%5Etfw">December 6, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote>
<p>ECMAScript 2015の仕様策定者であるAllen Wirfs-Brock‏氏の意見</p>
</blockquote>

<p>また、メソッドにおいても<code>this</code>は呼び出し方によって異なる値となり、それにより発生する問題と対処法についてを紹介しました。
コールバック関数における<code>this</code>はArrow Functionを使うことで分かりやすく解決できます。
この背景にはArrow Functionで定義した関数は<code>this</code>を持たないという性質があります。</p>

<p>もっと<code>this</code>について理解してみたい人は、書籍版も実行しながら見ると良さそうです。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></li>
</ul>

<h3 id="📝-note-this-binding-syntax-proposal">📝 Note: This-Binding Syntax proposal</h3>

<p>通常の関数をmixin関数のように扱いやすくする<code>::</code>という構文のProposalがありましたが、しばらくステータスが更新されていません。
(Proposalの元々のAuthorがTC39メンバーではなくなったのも1つの理由)</p>

<ul>
<li><a href="https://github.com/tc39/proposal-bind-operator" title="ECMAScript This-Binding Syntax">ECMAScript This-Binding Syntax</a></li>
</ul>

<h3 id="📝-this名前解決の仕様">📝 <code>this</code>名前解決の仕様</h3>

<p><code>this</code> bindingの設定は、関数を呼ぶときの次の仕様で決定される。</p>

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-evaluatecall">https://tc39.github.io/ecma262/#sec-evaluatecall</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-call">https://tc39.github.io/ecma262/#sec-call</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist">https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-ordinarycallbindthis">https://tc39.github.io/ecma262/#sec-ordinarycallbindthis</a></li>
</ul>

<p>大きく分けると、WriteとReadの２つのフェーズで<code>this</code>が決まる。
ここでWriteとReadとつけているけど、仕様にそういうフェーズがあるわけじゃなくて自分の解釈です。</p>

<p>Write: 関数呼び出しをする際に、その関数のFunction Environment Recordsの<code>[[ThisValue]]</code>に<code>this</code>の値を入れる</p>

<p><code>[[ThisValue]]</code>には次のステップの結果が入る。
(ただしArrow Functionはlexicalなので<code>[[ThisValue]]</code>を持たない。<a href="https://tc39.github.io/ecma262/#sec-ordinarycallbindthis">Arrow Functionの詳細</a>)</p>

<p><a href="https://tc39.github.io/ecma262/#sec-evaluatecall" title="12.3.4.2Runtime Semantics: EvaluateCall(func, ref, arguments, tailPosition )">12.3.4.2Runtime Semantics: EvaluateCall(func, ref, arguments, tailPosition )</a>のステップを参照する</p>

<ul>
<li>プロパティならば

<ul>
<li><code>this</code>は<code>GetThisValue()</code>の結果

<ul>
<li><code>super.prop</code>なら

<ul>
<li><code>super</code>となる</li>
</ul></li>
<li>それ以外なら

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-getbase" title="6.2.4.1GetBase ( V )">6.2.4.1GetBase ( V )</a>の結果</li>
<li>ベースオブジェクトが<code>this</code>となる</li>
</ul></li>
</ul></li>
</ul></li>
<li>それ以外(ただの関数呼び出し)なら<a href="https://tc39.github.io/ecma262/#sec-object-environment-records-withbaseobject">WithBaseObject</a>の結果

<ul>
<li>withの場合

<ul>
<li>with bingingの値</li>
</ul></li>
<li>それ以外

<ul>
<li>undefined</li>
</ul></li>
</ul></li>
</ul>

<p>Read: <code>this</code>という識別子から、その値が何を参照するかを決めるフェーズ</p>

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-getthisenvironment">https://tc39.github.io/ecma262/#sec-getthisenvironment</a>

<ul>
<li><code>this</code>の解決はスコープと同じく、一個つづ順に内側から外側へ探すのはスコープチェーンと同じ

<ul>
<li>見つかるまで再帰的に外側のEnvironment Recordsを探索する</li>
<li>見つからない場合は、&quot;Script&quot;や&quot;Module&quot;の実行コンテキストの<code>this</code>の値になる</li>
<li>&quot;Module&quot;の<a href="https://tc39.github.io/ecma262/#sec-module-environment-records-getthisbinding" title="GetThisBinding ( )">GetThisBinding ( )</a>は常に<code>undefined</code></li>
<li>&quot;Script&quot;の<a href="https://tc39.github.io/ecma262/#sec-global-environment-records-getthisbinding" title="GetThisBinding ( )">GetThisBinding ( )</a>はグローバルオブジェクト</li>
</ul></li>
<li>ただし、Arrow Functionは<code>[[ThisValue]]</code>を持たないので必ずスキップされる</li>
<li>もっと近い関数(Function Environment Records)の<code>[[ThisValue]]</code>の値が<code>this</code>の値となる</li>
</ul></li>
</ul>

    </div>
    <div class="post-post-toolbar">
        <a class="btn edit-on-github"
           href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2018/2018-01-04-what-is-this.md"><span
                class="edit-on-github-label"></span>修正リクエストをする</a>
        <nav class="tags"
             id="js-post-tags"
             data-post-tags='["JavaScript","ECMAScript","this"]'>
            <span>タグ:</span>
            <ul>
                
                <li><a href="/tags/?q=JavaScript">JavaScript</a></li>
                
                <li><a href="/tags/?q=ECMAScript">ECMAScript</a></li>
                
                <li><a href="/tags/?q=this">this</a></li>
                
            </ul>
        </nav>
    </div>
    <div class="announce-area">
        <h3>お知らせ欄</h3>
        <div class="announce-text">
            <!--お知らせ-->
JavaScriptに関する最新情報は週一で<a href="http://jser.info/" title="JSer.info">JSer.info</a>を更新しています。

        </div>
        <h3>次に書くかもしれない記事候補</h3>
        <p>興味がありましたら<a href="https://github.com/efcl/efcl.github.io/labels/%E8%A8%98%E4%BA%8B%E5%80%99%E8%A3%9C" title="Issues · efcl/efcl.github.io">Issues · efcl/efcl.github.io</a>からご意見下さい</p>
        <div class="announce-text">
            <iframe src="https://azu.github.io/github-issue-widget/?owner=efcl&repo=efcl.github.io&labels=記事候補&limit=4&random"
                    allowtransparency="true" frameborder="0" scrolling="0" width="100%" height="100%"></iframe>
        </div>
    </div>
    <div class="related-articles" id="js-related-articles">
        <h3>関連記事</h3>
    </div>
</div>
<div class="zenback-embed">
    <!-- X:S ZenBackWidget --><div id="zenback-widget-loader"></div><script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var r=Math.ceil((new Date()*1)*Math.random());var j=d.createElement("script");j.id=i;j.async=true;j.src="//w.zenback.jp/v1/?base_uri=http%3A//efcl.info/&nsid=89229392978401102%3A%3A89229398078677080&rand="+r;d.body.appendChild(j);}}(document,"zenback-widget-js");</script><!-- X:E ZenBackWidget -->
</div>
<div class="disqus-embed" id="js-disqus-embed">
    <button class="comment-button" id="js-comment-button">コメントを表示</button>
</div>

<script type="text/javascript" src="/public/js/tag-fetcher.js"></script>
<script type="text/javascript" src="/public/js/show-related-article.js"></script>
<script type="text/javascript" src="/public/js/show-disqus.js"></script>

    </div>
</article>
</body>
</html>
