<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        
        ECMAScriptの仕様/プロポーザルの調べ方を知る | Web Scratch
        
    </title>
    <meta name="description" content="はじめに">
    
    <meta name="keywords" content="ECMAScript,JavaScript,Proposal" />
    
    <meta name="author" content="azu">
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144"
          href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="http://efcl.info/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed/">
    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/main.css">
    <!-- JavaScript -->
    <!-- Open graph tags -->
<meta property="og:title" content="ECMAScriptの仕様/プロポーザルの調べ方を知る">
<meta property="og:type" content="article">
<meta property="og:url" content="http://efcl.info/2018/03/07/ecmascript-usage/">
<meta property="og:image" content="http://efcl.info/public/favicon.ico">

<meta property="og:description" content="はじめに">
<meta property="og:site_name" content="Web Scratch">




<meta property="article:published_time" content="2018-03-07T11:54:00+09:00">
<meta property="article:author" content="https://www.facebook.com/">

<meta property="og:see_also" content="http://efcl.info/2018/02/22/node29/">

<meta property="og:see_also" content="http://efcl.info/2018/02/02/snapshot-test/">

<meta property="og:see_also" content="http://efcl.info/2018/01/25/almin-0.15/">





<meta property="article:section" content="javascript">





<meta property="article:tag" content="ECMAScript">

<meta property="article:tag" content="JavaScript">

<meta property="article:tag" content="Proposal">


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2184335-8', 'auto');
    ga('send', 'pageview');
</script>
    <script>
var blog_categories = [
{
    "title" : "greasemonkey",
    "count" : 61
},{
    "title" : "ニコニコ動画",
    "count" : 16
},{
    "title" : "小説電子化",
    "count" : 3
},{
    "title" : "vista",
    "count" : 12
},{
    "title" : "firefox",
    "count" : 55
},{
    "title" : "その他",
    "count" : 13
},{
    "title" : "webサービス",
    "count" : 22
},{
    "title" : "software",
    "count" : 59
},{
    "title" : "雑記",
    "count" : 37
},{
    "title" : "まとめ",
    "count" : 11
},{
    "title" : "zaurus",
    "count" : 3
},{
    "title" : "ハードウェア",
    "count" : 8
},{
    "title" : "アドオン",
    "count" : 31
},{
    "title" : "wordpress",
    "count" : 6
},{
    "title" : "javascript",
    "count" : 200
},{
    "title" : "インストール設定",
    "count" : 12
},{
    "title" : "iphone",
    "count" : 10
},{
    "title" : "loox u",
    "count" : 1
},{
    "title" : "tombloo",
    "count" : 3
},{
    "title" : "イベント",
    "count" : 92
},{
    "title" : "userchome.js",
    "count" : 8
},{
    "title" : "jetpack",
    "count" : 7
},{
    "title" : "onenote",
    "count" : 2
},{
    "title" : "nilscript",
    "count" : 4
},{
    "title" : "keysnail",
    "count" : 3
},{
    "title" : "ios",
    "count" : 15
},{
    "title" : "shell",
    "count" : 3
},{
    "title" : "r言語",
    "count" : 2
},{
    "title" : "node.js",
    "count" : 3
},{
    "title" : "mac",
    "count" : 2
},{
    "title" : "github",
    "count" : 11
},{
    "title" : "jekyll",
    "count" : 1
},{
    "title" : "golang",
    "count" : 1
},{
    "title" : "web",
    "count" : 1
},{
    "title" : "スライド",
    "count" : 1
},{
    "title" : "ie",
    "count" : 1
},{
    "title" : "書籍",
    "count" : 2
},{
    "title" : "textlint",
    "count" : 9
}
];
    blog_categories = blog_categories.filter(function(categoryObject){
        return !/^\d+$/.test(categoryObject.title);
    });
</script>
</head>


<body class="layout-reverse theme-base-0d">
<a href="https://github.com/efcl/efcl.github.io" class="github-ribbon">
    <img style="position: fixed; z-index:100; top: 0; right: 0; border: 0;"
         src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
         alt="Fork me on GitHub"
         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<header>
    <div class="site-header">
    <img src="/public/img/reimu-right.png" class="header-logo">

    <h1 class="site-title">
        <a href="/">
            Web Scratch
        </a>
    </h1>
    <p class="lead">ブラウザ/JavaScript等についてのブログ</p>

</div>
</header>
<aside>
    <div class="sidebar">
    <div class="container">
        <div class="profile">
            <a href="/about/" title="About"><img src="/public/img/azu.png" alt="Profile"></a>

            <h2><a href="/about/" title="About">azu</a></h2>
        </div>
        <div class="social">
            <a class="twitter" href="http://twitter.com/azu_re" title="Twitter">
                <img src="/public/svg/twitter.svg" alt="twitter" width="32" height="32"/>
            </a>
            <a class="github" href="https://github.com/azu" title="GitHub">
                <img src="/public/svg/github.svg" alt="GitHub" width="32" height="32"/>
            </a>
            <a class="rss" href="/feed/" title="RSS Feed">
                <img src="/public/svg/feed.svg" alt="RSS" width="32" height="32"/>
            </a>
        </div>
        <nav class="sidebar-nav">
            <div class="search">
                <form class="search-box" method="get" action="https://www.google.co.jp/search">
                    <label for="search-box-label">検索:</label>
                    <input type="hidden" name="q" value="site:efcl.info">
                    <input id="search-box-label" type="search" name="q">
                    <input type="submit" value="search">
                </form>
            </div>
            <div class="recent">
    <h3 class="recent-posts-list-title">
        <a href="/">最近の投稿</a>
    </h3>
    <ul class="recent-posts">
        
        <li>
            <a href="/2018/03/07/ecmascript-usage/">
                ECMAScriptの仕様/プロポーザルの調べ方を知る
            </a>
        </li>
        
        <li>
            <a href="/2018/02/22/node29/">
                Node学園 29時限目でECMAScriptの調べ方について発表してきた
            </a>
        </li>
        
        <li>
            <a href="/2018/02/02/snapshot-test/">
                Jestなどを使わずにスナップショットテストを書く
            </a>
        </li>
        
        <li>
            <a href="/2018/01/25/almin-0.15/">
                Almin 0.15リリース
            </a>
        </li>
        
    </ul>
</div>
            <div class="recent">
    <h3 class="categories-list-title"><a href="/categories">カテゴリ一覧</a></h3>

    <div class="categories-list" id="js-categories-list">

    </div>
    <script>
        (function () {
            var categoriesList = window.blog_categories;
            var appendPoint = document.getElementById("js-categories-list");
            // big ... small
            var sortedCategories = categoriesList.sort(function (a, b) {
                return a.count < b.count ? 1 : -1;
            });
            var ulTag = document.createElement("ul");
            var displayCount = sortedCategories.length < 3 ? sortedCategories.length : 3;
            for (var i = 0; i < displayCount; i++) {
                var category = sortedCategories[i];
                var liTag = document.createElement("li");
                var aTag = document.createElement("a");
                aTag.href = "/categories#" + category.title;
                aTag.textContent = category.title;
                var spanTag = document.createElement("span");
                spanTag.appendChild(document.createTextNode("[" + category.count + "]"));
                liTag.appendChild(aTag);
                liTag.appendChild(spanTag);
                ulTag.appendChild(liTag);
            }
            var lastLiTag = document.createElement("li");
            var lastATag = document.createElement("a");
            lastATag.href = "/categories";
            lastATag.textContent = "その他のタグ…";
            lastLiTag.appendChild(lastATag);
            ulTag.appendChild(lastATag);
            appendPoint.appendChild(ulTag);
        })();
    </script>
</div>
        </nav>
    </div>
</div>

</aside>
<article>
    <div class="content container">
        <div class="post" id="js-post-url" data-post-url="/2018/03/07/ecmascript-usage/">
    <h1 class="post-title">ECMAScriptの仕様/プロポーザルの調べ方を知る</h1>

    <div class="pre-post-toolbar">
        <span class="post-date">2018年03月07日</span>
        <a class="btn edit-on-github" href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2018/2018-03-07-ecmascript-usage.md"><span class="edito-on-github-label"></span>Edit on GitHub</a>

    </div>
    <div class="post-content">
        <h2 id="はじめに">はじめに</h2>

<p>この文章は<a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a>で書いた<a href="https://asciidwango.github.io/js-primer/basic/ecmascript/" title="ECMAScript · JavaScriptの入門書 #jsprimer">ECMAScript · JavaScriptの入門書 #jsprimer</a>の章が元となっています。</p>

<p>また、<a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a>というスライドでどのようの話をしているのであわせて参照してみてください。</p>

<blockquote>
<p>スライド: <a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a></p>
</blockquote>

<h2 id="ecmascript">ECMAScript</h2>

<p>ECMAScriptは<a href="http://www.ecma-international.org/" title="Ecma International">Ecma International</a>という団体によって標準化されている仕様です。
Ecma InternationalはECMAScript以外にもC#やDartなどの標準化作業を行っています。
Ecma International中のTechnical Committee 39（TC39）という技術委員会が中心となって、ECMAScript仕様についてを議論しています。
この技術委員会はMicroSoft、Mozilla、Google、AppleといったブラウザベンダーやECMAScriptに関心のある企業などによって構成されます。</p>

<h2 id="ecmascriptのバージョンの歴史">ECMAScriptのバージョンの歴史</h2>

<p>ここで、簡単にECMAScriptのバージョンの歴史を振り返ってみましょう。</p>

<table>
<thead>
<tr>
<th>バージョン</th>
<th>リリース時期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1997年6月</td>
</tr>
<tr>
<td>2</td>
<td>1998年6月</td>
</tr>
<tr>
<td>3</td>
<td>1999年12月</td>
</tr>
<tr>
<td>4</td>
<td>破棄</td>
</tr>
<tr>
<td>5</td>
<td>2009年12月</td>
</tr>
<tr>
<td>5.1</td>
<td>2011年6月</td>
</tr>
<tr>
<td>2015</td>
<td>2015年6月</td>
</tr>
<tr>
<td>2016</td>
<td>2016年6月</td>
</tr>
<tr>
<td>2017</td>
<td>2017年6月</td>
</tr>
</tbody>
</table>

<!-- textlint-disable -->

<p>ES5.1からES2015がでるまで4年もの歳月がかかっているの対して、ES2015以降は毎年リリースされています。
毎年安定したリリースを行えるようになったのは、ES2015以降は仕様策定プロセスの変更が行われたためです。</p>

<!-- textlint-enable -->

<h2 id="living-standardとなるecmascript">Living StandardとなるECMAScript</h2>

<p>現在、ECMAScriptの仕様書のドラフトはGitHub上の<a href="https://github.com/tc39/ecma262" title="tc39/ecma262: Status, process, and documents for ECMA262">tc39/ecma262</a>で管理されており日々更新されています。
そのため、本当の意味での最新のECMAScript仕様は<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>となります。
このように更新ごとにバージョン番号を付けずに、常に最新版を公開する仕様のことを<strong>Living Standard</strong>と呼びます。</p>

<p>ECMAScriptはLiving Stadardですが、これに加えてECMAScript 2017のようにバージョン番号をつけたものも公開されています。
このバージョン付きECMAScriptは、毎年決まった時期のドラフトを元にしたスナップショットのようなものです。</p>

<p>ブラウザなどに実際にJavaScriptとして実装される際には、Living StandardのECMAScriptを参照しています。
これは、ブラウザ自体も日々更新されるものであり、決まった時期にしかリリースされないバージョン付きよりもLiving Standardの方が適当であるためです。</p>

<h2 id="仕様策定のプロセス">仕様策定のプロセス</h2>

<p>ES2015以前はすべての仕様の合意が取れるまで延々と議論を続けすべてが決まってからリリースされていました。
そのため、ES2015がリリースされるまでには4年もの歳月がかかり言語の進化が停滞していました。
この問題を解消するために、TC39は毎年リリースするためにECMAScriptの策定プロセスを変更しました。</p>

<p>この策定プロセスはES2015がリリース後に適応され、このプロセスで初めてリリースされたのがES2016となります。
ES2016以降では、次のような仕様策定のプロセスで議論を進めて仕様が決定されています。</p>

<p>仕様に追加する機能（API、構文など）をそれぞれ個別の<strong>プロポーザル</strong>（提案書）として進めていきます。
現在策定中のプロポーザルはGitHub上の<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>に一覧が公開されています。
それぞれのプロポーザルは責任者である<strong>チャンピオン</strong>と<strong>ステージ</strong>（Stage）と呼ばれる<code>0</code>から<code>4</code>の5段階の状態を持ちます。</p>

<table>
<thead>
<tr>
<th style="text-align:center">ステージ</th>
<th>ステージの概要</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td>アイデアの段階</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>機能提案の段階</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>機能の仕様書ドラフトを作成した段階</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>仕様としては完成しており、ブラウザの実装やフィードバックを求める段階</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>仕様策定が完了し、2つ以上の実装が存在している。<br />正式にECMAScriptにマージできる段階</td>
</tr>
</tbody>
</table>

<p>このステージの詳細については<a href="https://tc39.github.io/process-document/" title="The TC39 Process">The TC39 Process</a>を参照してください。</p>

<p>2ヶ月に1度行われるTC39のミーティングにおいて、プロポーザルごとにステージを進めるかどうかを議論します。
このミーティングの議事録もGitHub上の<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>にて公開されています。
ステージ4となったプロポーザルはドラフト版である<a href="https://github.com/tc39/ecma262" title="tc39/ecma262: Status, process, and documents for ECMA262">tc39/ecma262</a>へマージされます。
そして毎年の決まった時期にドラフト版を元にして<code>ECMAScript 20XX</code>としてリリースします。</p>

<p>この仕様策定プロセスの変更は、ECMAScriptに含まれる機能の形にも影響しています。</p>

<p>たとえば、<code>class</code>構文の策定は<strong>最大限に最小のクラス</strong>（maximally minimal classes）と呼ばれる形で提案されています。
これによりES2015で<code>class</code>構文が導入されましたが、クラスとして合意が取れる最低限の機能だけの状態で入りました。
その他のクラスの機能は別のプロポーザルとして提案され、ES2015以降に持ち越された形で議論が進められています。</p>

<p>このような合意が取れる最低限の形でプロポーザルを進めていくのには、ES4の苦い失敗が背景にあります。
ES4ではECMAScriptに多くの変更を入れることを試みましたが、TC39内でも意見が分かれ最終的に合意できませんでした。
これによりES4の策定に割いた数年分のリソースが無駄となってしまったという経緯があります。</p>

<p>詳しくはES2015のエディタであるAllenさんによる<a href="http://wirfs-brock.com/allen/files/papers/standpats-asianplop2016.pdf">プログラミング言語標準化</a>というPaperにかかれています。</p>

<p>またES2016以降の策定プロセスでも、すべてのプロポーザルが仕様に入るわけではありません。
別の代替プロポーザルが出た場合や後方互換性と保てない場合などにプロポーザルの策定を中断する場合があります。
しかし、この場合でもプロポーザルという単位であるため策定作業の無駄は最小限で済みます。
このようにモジュール化されたプロポーザルは入れ替えがし易いという性質もあります。</p>

<h2 id="プロポーザルの機能を試す">プロポーザルの機能を試す</h2>

<p>ECMAScriptの策定プロセスのステージ4に「2つ以上の実装が存在している」という項目があります。
そのためブラウザのJavaScriptエンジンには、策定中のプロポーザルが実装されている場合があります。
多くの場合は試験的なフラグ付きで実装されておりフラグを有効化することで、試すことができるようになっています。</p>

<p>またTranspilerやPolyfillといった手段で、プロポーザルの機能をエミュレートできる場合があります。</p>

<p>Transpilerとは、新しい構文を既存の機能で再現できるようにソースコードを変換するツールのことです。
たとえば、ES2015で<code>class</code>構文が導入されましたが、ES5では<code>class</code>は予約語であるため構文エラーとなり実行することはできません。
Transpilerでは、<code>class</code>構文を含むソースコードを<code>function</code>キーワードを使い擬似的に再現するコードへ変換します。
Transpilerとしては<a href="https://babeljs.io/" title="Babel · The compiler for writing next generation JavaScript">Babel</a>や<a href="https://www.typescriptlang.org/" title="TypeScript - JavaScript that scales.">TypeScript</a>などが有名です。</p>

<p>Polyfillとは、新しい関数やメソッドなどの仕様を満たすような実装を提供するライブラリのことです。
たとえば、ES2016では<code>Array#inclues</code>というメソッドが追加されました。
構文とは異なり<code>Array#inclues</code>のようなメソッドはビルトインオブジェクトを書き換えることで実装できます。
Polyfillを提供するものとしては<a href="https://github.com/zloirock/core-js" title="zloirock/core-js: Standard Library">core-js</a>や<a href="https://polyfill.io/v2/docs/" title="Polyfill service">polyfill.io</a>などが有名です。</p>

<p>注意点としてはTranspilerやPolyfillはあくまで既存の機能で新しい機能を再現を試みているだけに過ぎません。
そのため、既存の機能で再現ができないプロポーザル（機能）はTranspilerやPolyfillでは再現できません。
また、完全な再現はできていないことがあるためTranspilerやPolyfillを新しい機能を学ぶために使うべきではありません。</p>

<!-- Notes: バージョンが西暦となった理由

実際に各ブラウザなどはECMAScriptを実装していますが、このときに参照するのは基本的にLiving StandardであるECMAScriptです。
また、PolyfillやTranspilerといった手段で、タグ付けされたECMAScript 20XXがリリースされる前にその機能が利用できることも多いです。
ECMAScriptのバージョンとしてES6ではなくES2015のように西暦をバージョンとして使うようになったのも、Living Standardを意識しての試みです。

-->

<h2 id="仕様や策定プロセスを知る意味">仕様や策定プロセスを知る意味</h2>

<p>こうしたECMAScriptという仕様や策定プロセスを知る意味は何があるのでしょうか？
主に次のような理由で知る意味があると考えています。</p>

<ul>
<li>言語を学ぶため</li>
<li>言語が進化しているため</li>
<li>情報の正しい状態を調べるため</li>
</ul>

<h3 id="言語を学ぶため">言語を学ぶため</h3>

<p>もっとも単純な理由はJavaScriptという言語そのものを学ぶためです。
言語の詳細を知りたい場合にはECMAScriptという仕様を参照できます。</p>

<p>しかしながら、JavaScriptにおいては言語機能に関しては<a href="https://developer.mozilla.org/ja/" title="MDN Web Docs">MDN Web Docs</a>という優れたリファレンスサイトなどがあります。
そのため、使い方を覚えたいなどの範囲ではECMAScriptの仕様そのものを参照する機会は少ないでしょう。</p>

<h3 id="言語が進化しているため">言語が進化しているため</h3>

<p>ECMAScriptはLiving Standardであり、日々更新されています。
これは、言語仕様に新しい機能や修正などが常に行われていることを表しています。</p>

<p>ECMAScriptは後方互換性を尊重するため、今学んでいることが無駄になるわけではありません。
しかしながら言語自体も進化していることは意識しておくとよいでしょう。</p>

<p>ECMAScriptのプロポーザル（機能）は問題を解決するために提案されます。
そのプロポーザルがECMAScriptにマージされ利用できる場合、その機能が何を解決するために導入されたのか知ることは大切です。
その際には、ECMAScriptの策定プロセスを知っておくことが調べることに役立ちます。</p>

<p>この仕様はなぜこうなったのかということを知りたいと思ったときに、その機能がどのような経緯で入ったのかを調べる手段をもつことは大切です。
特にES2015以降は策定プロセスもGitHubを利用したオープンなものとなり、過去の記録なども探しやすくなっています。</p>

<h3 id="情報の正しい状態を調べるため">情報の正しい状態を調べるため</h3>

<p>JavaScriptは幅広く使われている言語であるため、世の中には膨大な情報があります。
そして、検索して見つかる情報には正しいものや間違ったものが混在しています。</p>

<p>その中においてECMAScriptの仕様やその策定中のプロポーザルに関する情報は状態が明確です。
基本的にECMAScriptの仕様に入ったものは、後方互換性を維持するために破壊的変更は殆ど行なえません。
プロポーザルはステージという明示された状態があり、ステージ4未満の場合はまだ安定していないことが分かります。</p>

<p>そのため、問題を見つけた際に該当する仕様やプロポーザルを確認してみることは重要です。</p>

<p>これはECMAScriptにかぎらず、ウェブやブラウザに関する情報に関しては同じことがいえます。
ブラウザ関してはHTML、DOM API、CSSなどもオープンな仕様とそれぞれ策定プロセスが存在しています。</p>

<h3 id="ここまでのまとめ">ここまでのまとめ</h3>

<p>JavaScriptと一言にいってもECMAScript、ブラウザ、Node.js、WebAssembly、WebGL、WebRTCなど幅広い分野があります。
そのためすべてのことを知っている必要はありませんし、知っている人もおそらくいないでしょう。
このような状況下においては知識そのものよりも、それについて知りたいと思ったときに調べる方法を持っていることが大切です。</p>

<p>なにごとも突然全く新しい概念が増えるわけではなく、ものごとには過程が存在します。
ECMAScriptにおいては策定プロセスという形でどのような段階であるかが公開されています。
つまり、仕様にいきなり新しい機能が増えるのではなくプロポーザルという段階を踏んでいます。</p>

<p>日々変化しているソフトウェアにおいては、自身に適切な調べ方をもつことが大切です。</p>

<h2 id="具体例">具体例</h2>

<p>話しだけ見てもよくわからないと思うので、ここからは具体的な使い方の話です。</p>

<p>どのような場合に仕様やプロポーザルを調べたりするのか、またどのように調べるかについてです。</p>

<h2 id="実装が仕様に準拠しているかを調べたい">実装が仕様に準拠しているかを調べたい</h2>

<p>あるブラウザ/JavaScriptエンジンの挙動が仕様なのかを調べたいときがあります。</p>

<p>それぞれのメジャーブラウザはJavaScriptエンジンを各自実装しています。
そのため、どれかのブラウザが間違った実装だった場合に結果を比較することで分かる可能性があります。</p>

<p><a href="https://github.com/bterlson/eshost-cli">eshost-cli</a>というツールを使うことで、ローカルにインストール済みのJavaScriptエンジンでの実行結果をまとめて出力してくれます。
それぞれのJavaScriptエンジンをインストールするには<a href="https://github.com/GoogleChromeLabs/jsvu">jsvu</a>を使うのが簡単です。</p>

<ul>
<li><a href="https://github.com/GoogleChromeLabs/jsvu">GoogleChromeLabs/jsvu: JavaScript (engine) Version Updater</a>

<ul>
<li>主要なJavaScriptエンジンをまとめてインストール</li>
<li>macOSならChakraを含めてほぼ対応できる</li>
</ul></li>
<li><a href="https://github.com/bterlson/eshost-cli">bterlson/eshost-cli: Run ECMAScript code uniformly across any ECMAScript host</a>

<ul>
<li>指定したJavaScriptエンジンでコードを実行できる</li>
</ul></li>
</ul>

<p>次のように各種JavaScriptエンジンをインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># jsvuとeshostをインストール
npm install jsvu eshost-cli -g
# インストール先
export PATH=&quot;${HOME}/.jsvu:${PATH}&quot;
# JavaScriptエンジンをまとめてインストールしてくれる
jsvu
# インストールしたJavaScriptエンジンをeshotに登録
eshost --add &#39;Chakra&#39; ch ~/.jsvu/chakra
eshost --add &#39;JavaScriptCore&#39; jsc ~/.jsvu/javascriptcore
eshost --add &#39;SpiderMonkey&#39; jsshell ~/.jsvu/spidermonkey
eshost --add &#39;V8&#39; d8 ~/.jsvu/v8
</code></pre></div>
<p>後は、eshostでコードを実行するだけです。
次のコードではV8だけ結果が異なることが分かります。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># eshotでコードを実行
eshost -e &#39;new RegExp(&quot;\n&quot;).toString()&#39;
#### Chakra
/\n/

#### SpiderMonkey
/\n/

#### JavaScriptCore
/\n/

#### V8
/
/
</code></pre></div>
<p>このようにECMAScriptレベルのコードでJavaScriptエンジンの結果に差異がある場合は、大抵は実装依存の問題か実装の間違いといったケースになります。</p>

<h2 id="ecmascriptの仕様を読む">ECMAScriptの仕様を読む</h2>

<p>あるコードの実行結果が正しいのかを検証するためにECMAScriptの仕様書を読むことが参考になる場合があります。ECMAScriptの仕様書は2箇所にありますが基本的にはLiving Standard版を参照するのがよいでしょう(特定のバージョンに関するときはスナップショット版を参照します)</p>

<ul>
<li>スナップショット版: <a href="https://www.ecma-international.org/ecma-262/">https://www.ecma-international.org/ecma-262/</a></li>
<li>Living Standard版: <a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a></li>
</ul>

<p>ECMAScriptの仕様を読む機会はそこまで多くないと思いますが、Transpilerのような変換したコードの結果が異なる場合は仕様そのものを見てみるとどこにバグを報告すれば良いのかが明確になります。例えば、次の例はクラスのメソッド定義の挙動がBabelとTypeScriptで異なるケースです。</p>

<h3 id="例-babelとtypescriptのクラス">例: BabelとTypeScriptのクラス</h3>

<p>次のコードはBabelとTypeScriptでES5相当への変換と実行結果が異なります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span>
</code></pre></div>
<h4 id="babel-preset-envのデフォルト">Babel(preset-envのデフォルト)</h4>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">writable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">);</span> <span class="k">return</span> <span class="nx">Constructor</span><span class="p">;</span> <span class="p">};</span> <span class="p">}();</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">MyClass</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">_createClass</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">,</span> <span class="p">[{</span>
        <span class="nx">key</span><span class="o">:</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">method</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}]);</span>

    <span class="k">return</span> <span class="nx">MyClass</span><span class="p">;</span>
<span class="p">}();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span> <span class="c1">// =&gt; []</span>
</code></pre></div>
<h4 id="typescript-target-es5">TypeScript(target:es5)</h4>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
    <span class="k">return</span> <span class="nx">MyClass</span><span class="p">;</span>
<span class="p">}());</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span> <span class="c1">// =&gt; [&quot;method&quot;]</span>
</code></pre></div>
<p>変換結果も異なりますが、実行結果（コンソールへの出力)も異なります。</p>

<ul>
<li>Babelはメソッド（プロパティ）は列挙されないので <code>[]</code></li>
<li>TypeSdriptはメソッド（プロパティ）が列挙されるので <code>[&quot;method&quot;]</code></li>
</ul>

<p>このようなときにどちらが仕様準拠の挙動なのかはを仕様を調べてみましょう。</p>

<h3 id="仕様書の調べ方">仕様書の調べ方</h3>

<p>先ほども書きましたが、ECMAScriptにはLiving Standardの<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>とスナップショット版の<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>があります。
このケースではどちらでも良いですが、<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>の方が使いやすいこともあるので、こちらで見ていきます。</p>

<p>今回の目的は「<code>class</code>構文のメソッド定義の仕方を調べたい」です。
このような構文自体の挙動を調べたい場合は、次のような流れで探していきます。</p>

<p>大きな流れ</p>

<ol>
<li><code>class</code> というSyntaxの定義を探す</li>
<li><code>class</code>のRuntime Semantics(Syntaxにはそれぞれ実行時に何をするかという定義がある)</li>
<li>Runtime Semanticsでそれぞれの <code>method(){}</code> がどのように定義されているかを見ていく</li>
<li>今回は列挙されているかなので <code>enumerable</code> を調べる</li>
</ol>

<p>仕様書を上記の流れで調べている動画を撮ったので参考にしてみてください。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/xT8GupiJIio" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>仕様書を見た結果、クラスのメソッドは必ず<code>enumerable</code>を<code>false</code>で定義されています。
そのため、Babelは仕様に準拠するためにdefinePropertyで列挙しないように(<code>enumerable</code>を<code>false</code>)定義していますが、
TypeScriptは単純にプロトタイプオブジェクトのメソッドを追加してるだけなので列挙されています。</p>

<p>このIssueは既にありますが、パフォーマンスの問題などあるので一概にどちらが良いとも言えません。
(Babelもlooseで似たような変換にできます)</p>

<ul>
<li><a href="https://github.com/Microsoft/TypeScript/issues/15038" title="Method class enumerable · Issue #15038 · Microsoft/TypeScript">Method class enumerable · Issue #15038 · Microsoft/TypeScript</a></li>
</ul>

<h3 id="ecmascriptの読み方の補助資料">ECMAScriptの読み方の補助資料</h3>

<p>ECMAScriptの仕様書は巨大(800ページ以上)なので、基本的に上から下に読んでいくのは難しいです。
そのため、仕様書には目次検索、Pin（ブックマーク）、各リンクの逆引きなど便利な機能があるのでそれを活用して気になったものを読むのが良さそうです。</p>

<p>また、仕様書内で使われている記号や短縮記法などが<a href="https://tc39.github.io/ecma262/#sec-notational-conventions" title="Notational Conventions">Notational Conventions</a>にかかれています。また、次のサイトも仕様書を読むのに役立ちます。</p>

<ul>
<li><a href="https://timothygu.me/es-howto/" title="How to Read the ECMAScript Specification">How to Read the ECMAScript Specification</a>

<ul>
<li>ECMAScriptの読み方について解説してる</li>
<li><code>[[内部プロパティ]]</code>やAbstract Operator、Runtime semanticsなど仕様書に出てくる記号や読み方を解説してる</li>
</ul></li>
<li><a href="https://github.com/anba/es6draft" title="anba/es6draft: ECMAScript 2015 (ECMA-262 6th Edition) compiler and runtime">anba/es6draft: ECMAScript 2015 (ECMA-262 6th Edition) compiler and runtime</a>

<ul>
<li>ECMAScriptのJava実装</li>
<li>リファレンス実装的に仕様書と対応したアルゴリズムステップで実装されているので読みやすい</li>
<li><a href="https://github.com/anba/es6draft/blob/7e196e8a1482384ca83946998f5fbd22068b47c6/src/main/java/com/github/anba/es6draft/compiler/DefaultCodeGenerator.java#L1609-L1825" title="ClassDefinitionEvaluation">ClassDefinitionEvaluation</a>の実装もそのままある</li>
</ul></li>
</ul>

<p>今回は構文を見ていましたが、メソッドなど実際にJavaScriptのAPIに存在するものはもっと読みやすいです。
<a href="https://tc39.github.io/ecma262/#sec-string.prototype.includes" title="String.prototype.includes ( searchString [ , position ] )">String.prototype.includes ( searchString [ , position ] )</a>のように仕様がほぼそのまま実行ステップになっているので比較的単純です。</p>

<h2 id="例-js-primerの場合">例: <a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>の場合</h2>

<ul>
<li>サイト: <a href="https://asciidwango.github.io/js-primer/" title="この書籍について · JavaScriptの入門書 #jsprimer">この書籍について · JavaScriptの入門書 #jsprimer</a></li>
<li>リポジトリ: <a href="https://github.com/asciidwango/js-primer">github.com/asciidwango/js-primer</a></li>
</ul>

<p>最近、<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>というES21015以降を基本としたJavaScriptの入門書を書いています。
この書籍はLiving StandardであるECMAScriptに追従するように書いています。</p>

<hr>

<p><a href="https://github.com/asciidwango/js-primer"><img src="http://azu.github.io/slide/2018/node/img/repo-actions-watch.png" alt="inline, repo-actions-watch.png"></a></p>

<p>興味ある人はStarやWatchしてください。</p>

<hr>

<p>この書籍では、どのように説明するべきか迷った場合はECMAScriptを参照しています。
例えば用語の問題や、説明するためにどのような表現を使うべきか、実際の仕様的な動作を元にしています。</p>

<p>単純に今存在するブラウザなどの挙動を元にすれば、ほとんどのケースでは問題はありません。
ブラウザはできる限り仕様に準拠した実装にするためです。</p>

<p>しかし、その機能の仕組みを理解するとなるともう少し深掘りしてから解説を書く必要がでてきます。
なぜなら同じ結果になるような方法が考えられるためです。</p>

<p>そのような際には仕様書ではどのように定義しているのかを参考にしています。</p>

<h3 id="例1-関数とthisの表現-–-arrow-function">例1: <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis</a>の表現 – Arrow Function</h3>

<blockquote>
<p><code>function</code>キーワードで定義した関数は呼び出し時に、ベースオブジェクトが暗黙的な引数のように<code>this</code>の値として渡されます。
一方、Arrow Functionの関数は呼び出し時に<code>this</code>を受け取らないため、定義時のArrow Functionにおける<code>this</code>の参照先が静的に決定されます。
-- <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></p>
</blockquote>

<p>この部分だけ切り出してもちょっと分かりにくいですが、よくあるような「Arrow Functionは<code>this</code>をbindする」という説明にはしていません。
仕様ではArrowFunctionは<code>[[ThisValue]]</code>を持たないLexicalEnvironmentという定義になっていて、Arrow Functionが<code>this</code>を持つ(bind)わけではないからです。
そのため、「Arrow Functionは<code>this</code>をbindする」というよりは、「Arrow Functionは<code>this</code>を持たないので移譲する」と言ったほうが仕様に近いかもしれません。</p>

<p>この辺の説明はホントややこしいので、詳細は<a href="http://efcl.info/2018/01/04/what-is-this/" title="ECMAScript 2015以降のJavaScriptの`this`を理解する | Web Scratch">ECMAScript 2015以降のJavaScriptの<code>this</code>を理解する | Web Scratch</a>に譲ります。</p>

<p>実際に書いているときには以下のIssueのようにメモしながら、どのような表現が良いのかを考えながら書いています。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer/issues/316" title="関数とthis · Issue #316 · asciidwango/js-primer">関数とthis · Issue #316 · asciidwango/js-primer</a></li>
</ul>

<h2 id="例2-関数とthisの表現-–-thisの値">例2: <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis</a>の表現 – <code>this</code>の値</h2>

<p>また<code>this</code>の話ですが、<code>this</code>の解説をするためにあらゆる場所の<code>this</code>の挙動を調べていました。
<code>this</code>は普通はクラスぐらいにしか使いませんが、JavaScriptでは<code>this</code>はどこにでも書けます。
また、その時の<code>this</code>の値はコンテキスト変わります。</p>

<p>最初はブラウザやNode.jsで実行しながら調べていましたが、次の&quot;Module&quot;の挙動がブラウザによって違いました。
Chromeは<code>Window</code>、 その他のブラウザは<code>undefined</code>となりました。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>最初はChromeだけで試していたので、なぜ<code>Window</code>を返すのかが分かりませんでした。</p>

<p>Arrow Functionにおける<code>this</code>は外側のスコープの<code>this</code>を参照します。
そのため、次のようにトップレベルの<code>this</code>とトップレベルのArrow Functionにおける<code>this</code>は同じになるはずです。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="c1">// =&gt; undefined</span>
    <span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">()</span> <span class="o">===</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>&quot;Module&quot;コンテキストのトップレベル<code>this</code>は常に<code>undefined</code>ということは調べて知っていました。</p>

<ul>
<li><a href="http://efcl.info/2015/05/06/this-is-es6-module/" title="ES6 moduleのtop levelにある`this`の値は何になるのか? | Web Scratch">ES6 moduleのtop levelにある<code>this</code>の値は何になるのか?</a></li>
</ul>

<p>なので、最初のコードは<code>undefined</code>になるはずで、何か自分の仕様の解釈が間違っているのかなと思いました。</p>

<p>他のブラウザでの挙動も調べてみようと思い、<code>this</code>の値の一覧を出すサイトを作りました。</p>

<ul>
<li><a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a></li>
</ul>

<p>ここでChromeが何かおかしいのではないかと思いバグ報告をしました。</p>

<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791334" title="791334 - `this` in top level Arrow Function in Module Context should be `undefined` - chromium - Monorail">791334 - <code>this</code> in top level Arrow Function in Module Context should be <code>undefined</code> - chromium - Monorail</a></li>
</ul>

<p>結果的にはChromeの問題だったため、Chrome 65で修正されています。</p>

<h2 id="プロポーザルのステータスを知りたい">プロポーザルのステータスを知りたい</h2>

<p>プロポーザルの今のステータスを知りたい場合があります。
例えばあるライブラリがプロポーザル段階の書き方をREADMEに書いていたり、記事で「これが最新版」のような記述があった場合に、実際のステータスを知ることで異なる見かたができるようになります。</p>

<p>最初に紹介していたようにプロポーザルのステータスは0から4まであり、4以外は変更や廃止の可能性があるステータスとなります。</p>

<p>これはES2015以前ではなかった事例の１つです。なぜならES2015以前は策定プロセスが現在と異なるため、個別のプロポーザルのステータスを知る意味は殆どなかったためです。</p>

<p>これは<a href="http://azu.github.io/slide/2016/jser5years/javascript-information.html" title="JavaScript情報ってなんだっけ?">JavaScript情報ってなんだっけ?</a>でも触れています、比較的新しい悩みの一種となります。</p>

<p>プロポーザルの置き場所は決まっているため、ステータスの数値やTranspilerの実装は次のページを見ると確認できます。</p>

<ul>
<li><a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals: Tracking ECMAScript Proposals</a>

<ul>
<li>ECMAScriptのプロポーザル一覧</li>
</ul></li>
<li><a href="https://github.com/babel/proposals" title="babel/proposals: ✍️ Tracking the status of Babel&amp;#39;s implementation of TC39 proposals">babel/proposals: ✍️ Tracking the status of Babel&#39;s implementation of TC39 proposals</a>

<ul>
<li>Babelの実装との対応表</li>
</ul></li>
</ul>

<h2 id="このプロポーザルって進んでるの">このプロポーザルって進んでるの?</h2>

<p>ステータスは現時点での値にすぎないため、どちらかというとそのステータスが変化しているかを知りたい場合があると思います。</p>

<p>プロポーザルのステータスの変化を知りたい場合は次のサイトなどを購読するのが簡単でしょう。
また、<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>もただのGitHubリポジトリなのでそちらをWatchするのもいいでしょう。</p>

<ul>
<li><a href="https://ecmascript-daily.github.io/" title="ECMAScript Daily">ECMAScript Daily</a>

<ul>
<li>ECMAScript関係のニュースブログ(@azu)</li>
</ul></li>
<li><a href="http://ecmascript.in/" title="EcmaScript.in | Stay updated about EcmaScript proposal changes">EcmaScript.in | Stay updated about EcmaScript proposal changes</a>

<ul>
<li>プロポーザルのStage変化の通知メール</li>
</ul></li>
<li><a href="http://2ality.com/index.html" title="2ality – JavaScript and more">2ality – JavaScript and more</a>

<ul>
<li>プロポーザルの解説</li>
</ul></li>
</ul>

<h2 id="このプロポーザルはなぜ止まっているの">このプロポーザルはなぜ止まっているの?</h2>

<p>興味があるプロポーザルがある場合になぜそのプロポーザルのステータスが進まないかということに興味を持つひともいるでしょう。</p>

<p>プロポーザルにはそれぞれチャンピオンとなる責任者いて、そのチャンピオンが策定作業を進めることで初めてステージが進みます。
<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a> にかかれている :rocket: はプロポーザルのステージをチャンピオンが進める意志がある状態かを表しています。(頻繁に更新されるためあくまで参考情報に過ぎません)</p>

<p><img src="http://azu.github.io/slide/2018/node/img/rockets.png" alt="inline, rockets.png"></p>

<p>:rocket: マークがついていない場合やしばらくステージが更新されていないプロポーザルは何かしらの課題や問題を抱えています。
ここではそれのプロポーザルがどのような課題を持っていて、ステージが更新されないのかを見ていきます。</p>

<h3 id="例-tc39-proposal-global">例: <a href="https://github.com/tc39/proposal-global" title="tc39/proposal-global">tc39/proposal-global</a></h3>

<p><code>global</code>はグローバルオブジェクトを取得するプロポーザルです。
現在(2018年2月の段階)はStage 3で止まっています。</p>

<p>なぜ止まっているかの理由はREADMEに書いています。</p>

<blockquote>
<p>however, due to <a href="https://github.com/tc39/proposal-global/issues/20">web compatibility concerns</a>, it is on hold pending a new global identifier name.</p>
</blockquote>

<p><a href="https://github.com/tc39/proposal-global/issues/20" title="global breaks flickr.com · Issue #20 · tc39/proposal-global">global breaks flickr.com · Issue #20 · tc39/proposal-global</a>のIssueで具体的に話し合われています。
このIssueやREADMEをみることで、<code>global</code>という名前によって壊れるサイトがいる問題がありこれが理由で止まっていることが割ります。</p>

<hr>

<h4 id="tips">Tips</h4>

<ul>
<li>プロポーザルはそれぞれGitHubリポジトリを持っている</li>
<li>プロポーザルのIssueには課題が書かれている</li>
<li>ウェブ互換性の問題については基本的にメトリクスデータを元に話を進める

<ul>
<li>壊れるウェブサイトはn%あるか</li>
<li><a href="https://www.chromestatus.com/metrics/feature/popularity" title="Chrome Platform Status">Chrome Platform Status</a>、<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/data/" title="Microsoft Edge Platform Data - Microsoft Edge Development">Microsoft Edge Platform Data</a>、<a href="https://blog.mozilla.org/data/" title="Firefox Data">Firefox Data</a></li>
</ul></li>
</ul>

<hr>

<h3 id="例-tc39-proposal-decorators">例: <a href="https://github.com/tc39/proposal-decorators" title="tc39/proposal-decorators">tc39/proposal-decorators</a></h3>

<p><code>proposal-decorators</code>はデコレーターを導入するプロポーザルです。
現時点(2018年3月)ではStage 2となっています。</p>

<p><a href="https://ecmascript-daily.github.io/2016/07/30/last-minutes-proposals-changes" title="ECMAScript proposal updates @ 2016-07 | ECMAScript Daily">ECMAScript proposal updates @ 2016-07 | ECMAScript Daily</a>というプロポーザルのステージ更新の記事を見ると、2016年7月からずっとステージ2となっていることが分かります。</p>

<p>ここではデコレーターにはどのような問題がありステージが更新されていないのかを調べてみましょう。
プロポーザルは2ヶ月に1度行われるTC39のミーティングでステージを更新をするかを判断します。</p>

<p>つまり、<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>に公開されているミーティングのログを見ることでわかりそうです。
それぞれのミーティングはアジェンダが事前に用意されており、事前に何を話し合うかが決められています(時間は有限であるため)</p>

<p>このアジェンダは<a href="https://github.com/tc39/agendas" title="tc39/agendas">tc39/agendas</a>で公開されているので、まずはアジェンダからデコレーターについて議論した月のミーティングを探してみます。</p>

<ul>
<li>何が原因で進んでないのかを調べる</li>
<li>=&gt; TC39のミーティングでどのような議論が行われてるのかを調べる</li>
<li>=&gt; 何が課題となっているかが話し合われているはず</li>
</ul>

<p><a href="https://github.com/tc39/agendas" title="tc39/agendas">tc39/agendas</a>（議事録のアジェンダ）を&quot;<a href="https://github.com/tc39/agendas/search?o=desc&amp;q=Decorators&amp;s=indexed&amp;type=&amp;utf8=%E2%9C%93" title="Search · Decorators">Decorators</a>&quot;で検索すると、<a href="https://github.com/tc39/agendas/blob/385085dead6e4f08a2100eccc7b8738dec97f236/2018/01.md" title="agendas/2018/01.md">agendas/2018/01.md</a>にも議題となったことが分かります。</p>

<p><img src="http://azu.github.io/slide/2018/node/img/decorators-agenda.png" alt="right, decorators-agenda.png"></p>

<p>このアジェンダと同じ月のミーティングノートを<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>で探すと<a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/summary.md" title="2018-01/summary.md">2018-01/summary.md</a>が見つかります。
ミーティングの議事録事態は長いですが、<code>summary.md</code>にはその内容がまとまっているのでまずはそちらを見てみます。</p>

<p><img src="http://azu.github.io/slide/2018/node/img/summary-decorator.png" alt="inline, summary-decorator.png"></p>

<p>デコレーターでの議事録や関連するスライドを見てみると、幾つかの課題がその課題を解決するまでステージ3にはできないという話が書かれています。</p>

<ul>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-25.md#13vc-decorators-towards-stage-3" title="13.v.c Decorators: towards Stage 3">13.v.c Decorators: towards Stage 3</a>という議論が2018年1月に行われている</li>
<li><a href="https://docs.google.com/presentation/d/1g6hrJp_nk_OeapuPXlkE4D_31OZbz4wQbXuIagsyoUI/edit#slide=id.p" title="Decorators: Towards Stage 3 - Google スライド">Decorators: Towards Stage 3 - Google スライド</a>

<ul>
<li>Stage 3に向けて何をサポートし、何をサポートしないかをはっきりさせる</li>
<li>他のクラスのプロポーザル(hard private)との協調性についての課題があり調整している</li>
<li>実装者、テスト作成者、ライブラリ作者に対しても意見を求めてる</li>
<li>次のミーティング(3月)までにステークホルダーにアプローチする</li>
</ul></li>
</ul>

<p>このような課題があるためデコレーターはまだステージ2となっています。
このようなことがミーティングログを見ることでわかります。</p>

<hr>

<h2 id="tips">Tips</h2>

<ul>
<li>Stage 1までアイデアや実験なのでプロポーザル間でも重複する</li>
<li>Stage 2+あたりからプロポーザル間での協調的な仕様を検討する

<ul>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#revisiting-mixins-vs-protocols-proposal" title="Revisiting mixins-vs-protocols proposal">Revisiting mixins-vs-protocols proposal</a></li>
</ul></li>
<li>Decoratorはclass field、privateなど色々関係する</li>
<li>最近のDecoratorの変更は他のプロポーザルとの協調性やDecoratorが目指す範囲を確定する作業

<ul>
<li>今まで雰囲気で動いてた部分を明示的に例外を投げるようにするなど</li>
</ul></li>
</ul>

<hr>

<h2 id="おわりに">おわりに</h2>

<p>最初に述べたようにここに書いてあることをすべて知る必要性はありません。
具体的に気になることを見つけたときにそれを調べる手段にたどり着ければ問題ありません。</p>

<p>また、ECMAScriptがLiving Standardであるという話をしましたが、Living Standardである以上その策定プロセスなども細かく修正されていきます。
以前、<a href="http://efcl.info/2015/10/18/ecmascript-paper/" title="ECMAScriptの仕様策定に関するカンニングペーパー | Web Scratch">ECMAScriptの仕様策定に関するカンニングペーパー | Web Scratch</a>で書いたものはES2015時点のものでしたが、現在も細かくプロセスが変わったりより分かりやすくなっています。(ミーティングログにサマリが増えたり、<a href="https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md" title="Contributing to ECMAScript">Contributing to ECMAScript</a>などのドキュメントが増えたりなど)</p>

<p>ECMAScriptはこのようなオープンな仕組みであり、同じくブラウザに乗る機能も現在はオープンな仕様や議論を元にしていることが多いです(例外はあります)。
そのため、仕様やその仕様がどのような経緯で実装されたかといった事実を調べることは特別に難しいことではありません。
このような状況においては、推測だけで行動したり推測だけの意見に影響を受けるよりも、事実を確認して見るほうが簡単な場合もあります。</p>

<p>知識そのものよりも調べ方を知ることが重要なのかもしれません。</p>

<h2 id="リンクまとめ">リンクまとめ</h2>

<p>この記事で紹介した簡単なリンクのまとめです。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer">js-primer</a>版: <a href="https://asciidwango.github.io/js-primer/basic/ecmascript/" title="ECMAScript · JavaScriptの入門書 #jsprimer">ECMAScript · JavaScriptの入門書 #jsprimer</a></li>
<li>ECMAScript関係の情報: <a href="https://twitter.com/ecmascriptdaily" title="@EcmascriptDaily">@EcmascriptDaily</a>をフォローしておけばとりあえず流れてくる</li>
<li>ECMAScriptのプロポーザル: <a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>、<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>に殆どの情報がある</li>
<li>ECMAScriptの策定プロセス: <a href="https://tc39.github.io/process-document/" title="The TC39 Process">The TC39 Process</a>に書かれてる</li>
<li>ECMAScriptの仕様: <a href="https://github.com/tc39/ecma262" title="tc39/ecma262">tc39/ecma262</a>にLiving Standard</li>
</ul>

    </div>
    <div class="post-post-toolbar">
        <a class="btn edit-on-github"
           href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2018/2018-03-07-ecmascript-usage.md"><span
                class="edit-on-github-label"></span>修正リクエストをする</a>
        <nav class="tags"
             id="js-post-tags"
             data-post-tags='["ECMAScript","JavaScript","Proposal"]'>
            <span>タグ:</span>
            <ul>
                
                <li><a href="/tags/?q=ECMAScript">ECMAScript</a></li>
                
                <li><a href="/tags/?q=JavaScript">JavaScript</a></li>
                
                <li><a href="/tags/?q=Proposal">Proposal</a></li>
                
            </ul>
        </nav>
    </div>
    <div class="announce-area">
        <h3>お知らせ欄</h3>
        <div class="announce-text">
            <!--お知らせ-->
JavaScriptに関する最新情報は週一で<a href="http://jser.info/" title="JSer.info">JSer.info</a>を更新しています。

        </div>
        <h3>次に書くかもしれない記事候補</h3>
        <p>興味がありましたら<a href="https://github.com/efcl/efcl.github.io/labels/%E8%A8%98%E4%BA%8B%E5%80%99%E8%A3%9C" title="Issues · efcl/efcl.github.io">Issues · efcl/efcl.github.io</a>からご意見下さい</p>
        <div class="announce-text">
            <iframe src="https://azu.github.io/github-issue-widget/?owner=efcl&repo=efcl.github.io&labels=記事候補&limit=4&random"
                    allowtransparency="true" frameborder="0" scrolling="0" width="100%" height="100%"></iframe>
        </div>
    </div>
    <div class="related-articles" id="js-related-articles">
        <h3>関連記事</h3>
    </div>
</div>
<div class="zenback-embed">
    <!-- X:S ZenBackWidget --><div id="zenback-widget-loader"></div><script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var r=Math.ceil((new Date()*1)*Math.random());var j=d.createElement("script");j.id=i;j.async=true;j.src="//w.zenback.jp/v1/?base_uri=http%3A//efcl.info/&nsid=89229392978401102%3A%3A89229398078677080&rand="+r;d.body.appendChild(j);}}(document,"zenback-widget-js");</script><!-- X:E ZenBackWidget -->
</div>
<div class="disqus-embed" id="js-disqus-embed">
    <button class="comment-button" id="js-comment-button">コメントを表示</button>
</div>

<script type="text/javascript" src="/public/js/tag-fetcher.js"></script>
<script type="text/javascript" src="/public/js/show-related-article.js"></script>
<script type="text/javascript" src="/public/js/show-disqus.js"></script>

    </div>
</article>
</body>
</html>
