<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        
        shallow-equal for Object/React props | Web Scratch
        
    </title>
    <meta name="description" content="オブジェクトとReactのProps向けのShallow(浅い) equalライブラリを書きました。Shallow Equalは対象のオブジェクトのプロパティをそれぞれ1段だけ比較することを言います。ものすごく単純に書くならば次のようなことをするライブラリです。">
    
    <meta name="keywords" content="JavaScript,React" />
    
    <meta name="author" content="azu">
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144"
          href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="http://efcl.info/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed/">
    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/main.css">
    <!-- JavaScript -->
    <!-- Open graph tags -->
<meta property="og:title" content="shallow-equal for Object/React props">
<meta property="og:type" content="article">
<meta property="og:url" content="http://efcl.info/2017/11/30/shallow-equal/">
<meta property="og:image" content="http://efcl.info/public/favicon.ico">

<meta property="og:description" content="オブジェクトとReactのProps向けのShallow(浅い) equalライブラリを書きました。Shallow Equalは対象のオブジェクトのプロパティをそれぞれ1段だけ比較することを言います。ものすごく単純に書くならば次のようなことをするライブラリです。">
<meta property="og:site_name" content="Web Scratch">




<meta property="article:published_time" content="2017-11-30T10:12:00+09:00">
<meta property="article:author" content="https://www.facebook.com/">

<meta property="og:see_also" content="http://efcl.info/2018/02/22/node29/">

<meta property="og:see_also" content="http://efcl.info/2018/02/02/snapshot-test/">

<meta property="og:see_also" content="http://efcl.info/2018/01/25/almin-0.15/">





<meta property="article:section" content="javascript">





<meta property="article:tag" content="JavaScript">

<meta property="article:tag" content="React">


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2184335-8', 'auto');
    ga('send', 'pageview');
</script>
    <script>
var blog_categories = [
{
    "title" : "greasemonkey",
    "count" : 61
},{
    "title" : "ニコニコ動画",
    "count" : 16
},{
    "title" : "小説電子化",
    "count" : 3
},{
    "title" : "vista",
    "count" : 12
},{
    "title" : "firefox",
    "count" : 55
},{
    "title" : "その他",
    "count" : 13
},{
    "title" : "webサービス",
    "count" : 22
},{
    "title" : "software",
    "count" : 59
},{
    "title" : "雑記",
    "count" : 37
},{
    "title" : "まとめ",
    "count" : 11
},{
    "title" : "zaurus",
    "count" : 3
},{
    "title" : "ハードウェア",
    "count" : 8
},{
    "title" : "アドオン",
    "count" : 31
},{
    "title" : "wordpress",
    "count" : 6
},{
    "title" : "javascript",
    "count" : 199
},{
    "title" : "インストール設定",
    "count" : 12
},{
    "title" : "iphone",
    "count" : 10
},{
    "title" : "loox u",
    "count" : 1
},{
    "title" : "tombloo",
    "count" : 3
},{
    "title" : "イベント",
    "count" : 92
},{
    "title" : "userchome.js",
    "count" : 8
},{
    "title" : "jetpack",
    "count" : 7
},{
    "title" : "onenote",
    "count" : 2
},{
    "title" : "nilscript",
    "count" : 4
},{
    "title" : "keysnail",
    "count" : 3
},{
    "title" : "ios",
    "count" : 15
},{
    "title" : "shell",
    "count" : 3
},{
    "title" : "r言語",
    "count" : 2
},{
    "title" : "node.js",
    "count" : 3
},{
    "title" : "mac",
    "count" : 2
},{
    "title" : "github",
    "count" : 11
},{
    "title" : "jekyll",
    "count" : 1
},{
    "title" : "golang",
    "count" : 1
},{
    "title" : "web",
    "count" : 1
},{
    "title" : "スライド",
    "count" : 1
},{
    "title" : "ie",
    "count" : 1
},{
    "title" : "書籍",
    "count" : 2
},{
    "title" : "textlint",
    "count" : 9
}
];
    blog_categories = blog_categories.filter(function(categoryObject){
        return !/^\d+$/.test(categoryObject.title);
    });
</script>
</head>


<body class="layout-reverse theme-base-0d">
<a href="https://github.com/efcl/efcl.github.io" class="github-ribbon">
    <img style="position: fixed; z-index:100; top: 0; right: 0; border: 0;"
         src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
         alt="Fork me on GitHub"
         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<header>
    <div class="site-header">
    <img src="/public/img/reimu-right.png" class="header-logo">

    <h1 class="site-title">
        <a href="/">
            Web Scratch
        </a>
    </h1>
    <p class="lead">ブラウザ/JavaScript等についてのブログ</p>

</div>
</header>
<aside>
    <div class="sidebar">
    <div class="container">
        <div class="profile">
            <a href="/about/" title="About"><img src="/public/img/azu.png" alt="Profile"></a>

            <h2><a href="/about/" title="About">azu</a></h2>
        </div>
        <div class="social">
            <a class="twitter" href="http://twitter.com/azu_re" title="Twitter">
                <img src="/public/svg/twitter.svg" alt="twitter" width="32" height="32"/>
            </a>
            <a class="github" href="https://github.com/azu" title="GitHub">
                <img src="/public/svg/github.svg" alt="GitHub" width="32" height="32"/>
            </a>
            <a class="rss" href="/feed/" title="RSS Feed">
                <img src="/public/svg/feed.svg" alt="RSS" width="32" height="32"/>
            </a>
        </div>
        <nav class="sidebar-nav">
            <div class="search">
                <form class="search-box" method="get" action="https://www.google.co.jp/search">
                    <label for="search-box-label">検索:</label>
                    <input type="hidden" name="q" value="site:efcl.info">
                    <input id="search-box-label" type="search" name="q">
                    <input type="submit" value="search">
                </form>
            </div>
            <div class="recent">
    <h3 class="recent-posts-list-title">
        <a href="/">最近の投稿</a>
    </h3>
    <ul class="recent-posts">
        
        <li>
            <a href="/2018/02/22/node29/">
                Node学園 29時限目でECMAScriptについて発表してきた
            </a>
        </li>
        
        <li>
            <a href="/2018/02/02/snapshot-test/">
                Jestなどを使わずにスナップショットテストを書く
            </a>
        </li>
        
        <li>
            <a href="/2018/01/25/almin-0.15/">
                Almin 0.15リリース
            </a>
        </li>
        
        <li>
            <a href="/2018/01/04/what-is-this/">
                ECMAScript 2015以降のJavaScriptの`this`を理解する
            </a>
        </li>
        
    </ul>
</div>
            <div class="recent">
    <h3 class="categories-list-title"><a href="/categories">カテゴリ一覧</a></h3>

    <div class="categories-list" id="js-categories-list">

    </div>
    <script>
        (function () {
            var categoriesList = window.blog_categories;
            var appendPoint = document.getElementById("js-categories-list");
            // big ... small
            var sortedCategories = categoriesList.sort(function (a, b) {
                return a.count < b.count ? 1 : -1;
            });
            var ulTag = document.createElement("ul");
            var displayCount = sortedCategories.length < 3 ? sortedCategories.length : 3;
            for (var i = 0; i < displayCount; i++) {
                var category = sortedCategories[i];
                var liTag = document.createElement("li");
                var aTag = document.createElement("a");
                aTag.href = "/categories#" + category.title;
                aTag.textContent = category.title;
                var spanTag = document.createElement("span");
                spanTag.appendChild(document.createTextNode("[" + category.count + "]"));
                liTag.appendChild(aTag);
                liTag.appendChild(spanTag);
                ulTag.appendChild(liTag);
            }
            var lastLiTag = document.createElement("li");
            var lastATag = document.createElement("a");
            lastATag.href = "/categories";
            lastATag.textContent = "その他のタグ…";
            lastLiTag.appendChild(lastATag);
            ulTag.appendChild(lastATag);
            appendPoint.appendChild(ulTag);
        })();
    </script>
</div>
        </nav>
    </div>
</div>

</aside>
<article>
    <div class="content container">
        <div class="post" id="js-post-url" data-post-url="/2017/11/30/shallow-equal/">
    <h1 class="post-title">shallow-equal for Object/React props</h1>

    <div class="pre-post-toolbar">
        <span class="post-date">2017年11月30日</span>
        <a class="btn edit-on-github" href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2017/2017-11-30-shallow-equal.md"><span class="edito-on-github-label"></span>Edit on GitHub</a>

    </div>
    <div class="post-content">
        <p>オブジェクトとReactのProps向けのShallow(浅い) equalライブラリを書きました。
Shallow Equalは対象のオブジェクトのプロパティをそれぞれ1段だけ比較することを言います。
ものすごく単純に書くならば次のようなことをするライブラリです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">targetObject</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kr">const</span> <span class="nx">isEqualed</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">object</span><span class="p">).</span><span class="nx">some</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">targetObject</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a></li>
<li><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a></li>
</ul>

<p>どちらもTypeScriptに対応していて、シンプルにオブジェクト同士を比較してbooleanを返すだけのライブラリです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="p">{</span> <span class="nx">shallowEqual</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;shallow-equal-object&quot;</span><span class="p">);</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// =&gt; true</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">42</span> <span class="p">});</span> <span class="c1">// =&gt; false</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="p">});</span> <span class="c1">// =&gt; false</span>
</code></pre></div>
<p><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>は、値の比較関数をカスタマイズできます。
デフォルトの比較関数は<code>Object.is</code>メソッド相当の実装がつかわれています。
これは、Reactの<code>PureComponent</code>やECMAScriptのProposalとして提出されていた(現在は取り下げ)<a href="https://github.com/sebmarkbage/ecmascript-shallow-equal" title="ecmascript-shallow-equal">ecmascript-shallow-equal</a>と同じ比較となります。</p>

<p><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>は、この値の比較関数をReactのProps向けにしただけのバージョンです。
具体的には、<code>React.Element</code>同士の比較を考慮したバージョンなので、<code>props</code>(<code>children</code>も含む)に<code>React.Element</code>を使っていないなら大した違いはありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">customEqual</span><span class="o">:</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">typeof</span> <span class="nx">a</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">b</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span> <span class="c1">// =&gt; false</span>
</code></pre></div>
<p>どちらもデバッグモードに対応しています。
実際にshallowEqualしたことがある人はわかると思いますが、なぜそれが<code>false</code>になるのかは結構分かりにくいことが多いです。どのプロパティが異なるから<code>false</code>になったということをデバッグ時に知りたいがことが多々あります。</p>

<p>どちらのライブラリも <code>{ debug: true }</code> をオプションに渡すことでコンソールに、比較結果が<code>false</code>となった理由とオブジェクトを表示してくれます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">shallowEqual</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;objectA is not object.&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({},</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;objectB is not object.&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;object key length is not same&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;key:a is not equals between A and B.&quot;</span>
</code></pre></div>
<p>このShallow Equalがどのようなときに役立つかというと大きなオブジェクトの塊を比較するときに、オブジェクトの作り方次第では比較コストが大きく変わります。</p>

<p>ReactやReduxなどでよく言われる状態のオブジェクトのをImmutableにするのはこれに関連しています。</p>

<ul>
<li><a href="http://nekogata.hatenablog.com/entry/2013/06/15/013752" title="「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く">「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く</a></li>
</ul>

<p>実際にReactの例を見てみます。
次のサンプルは、恣意的な<code>JSON.stringify</code>でのDeepな比較の問題点を見るために作ったものです。
そのためDeepEqualが悪いという話ではありません。</p>

<h2 id="deep-equal-json-stringify-とshallow-equal">Deep Equal(<code>JSON.stringify</code>)とShallow Equal</h2>

<p>サンプルコードは次のリポジトリにあります。</p>

<ul>
<li><a href="https://github.com/azu/avoid-json-stringify-on-react" title="azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&amp;#39;s shouldComponentUpdate">azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&#39;s shouldComponentUpdate</a></li>
</ul>

<p>このサンプルではDeep Equalの実装例として<code>JSON.stringify</code>した結果同士を比較するものを利用しています。最近、Reactのドキュメントにおいて<code>shouldComponentUpdate</code>の実装で<code>JSON.stringify</code>を使うべきではないということが追加されています。
これを検証する目的で作ったサンプルコードです。</p>

<blockquote>
<p>We do not recommend doing deep equality checks or using JSON.stringify() in shouldComponentUpdate(). It is very inefficient and will harm performance.
<a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">https://reactjs.org/docs/react-component.html#shouldcomponentupdate</a></p>
</blockquote>

<p><strong>関連するIssue</strong></p>

<ul>
<li><a href="https://github.com/erikras/redux-form/issues/3461">Performance issue (crash) in large apps when using Field with children in React v16 · Issue #3461 · erikras/redux-form</a></li>
<li><a href="https://github.com/reactjs/reactjs.org/issues/7">Document that deep equality checks and JSON.stringify() in shouldComponentUpdate() are a bad idea · Issue #7 · reactjs/reactjs.org</a></li>
</ul>

<p>このサンプルでは、すべてのコンポーネントは<code>BaseComponent</code>を継承しています。
<code>BaseComponent</code>はDeep Equal(<code>JSON.stringify</code>)とShallow Equalが切り替えできるようになっています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">shallowEqual</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;shallow-equal-object&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isDeepEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prevState</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">nextState</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">prevState</span><span class="p">)</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">nextState</span><span class="p">);</span>
<span class="p">};</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isShallowEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prevState</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">nextState</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">prevState</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">);</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isShallowEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>アプリの構造はシンプルで<code>&lt;A/&gt;</code>というネストが深い用途、でっかいリストを描画する<code>&lt;List /&gt;</code>があります。<code>&lt;button /&gt;</code>を押すたびに、<code>state.a</code>の中にある<code>count</code>が+1ずつ更新されるだけです。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/11/30-1512048718.png" alt="image"></p>

<p>ここで<code>&lt;List /&gt;</code>に渡す<code>state.largeList</code>は初回時に固定の10000コの値をもつ配列となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">frozenLargeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
</code></pre></div>
<p>ボタン押しても<code>List</code>のpropsである<code>state.largeList</code>は変更されないので、<code>&lt;List/&gt;</code>は一度描画されたら更新する必要がありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&quot;App&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">A</span> <span class="p">{...</span><span class="nx">state</span><span class="p">.</span><span class="nx">a</span><span class="p">}</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">}</span><span class="o">&gt;+</span><span class="mi">1</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
    <span class="o">&lt;</span><span class="nx">hr</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">List</span> <span class="nx">items</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">largeList</span><span class="p">}</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="err">/div&gt;</span>
</code></pre></div>
<p>この渡されたpropsが同じ値であるなら、更新しないというのをReactでは<code>BaseComponent</code>ででてきた<code>shouldComponentUpdate</code>メソッドの実装で解決できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>デフォルトの<code>shouldComponentUpdate</code>は常に<code>true</code>を返すので、常に新しい値が来たら更新することになります。
これを防止する方法として<code>this.props</code>(今のprops)と次にくる<code>nextProps</code>を比較して、同じなら<code>false</code>を返せば更新されないという寸法です。</p>

<p>今回はこの実装をDeep Equal(<code>JSON.stringify</code>)とShallow Equal(<a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>)で比較しています。(<code>React.PureComponent</code>はShallow Equalと同じ実装になります)</p>

<p><code>&lt;A /&gt;</code>は毎回新しいPropsを受け取るので更新されますが、<code>&lt;List items={state.largeList}/&gt;</code>は同じpropsを毎回受け取るので更新する必要がありません。</p>

<p>どちらもDeepもShallow(<code>state.largeList</code>の参照先は毎回同じ)も比較結果は<code>true</code>となり、つまりそれを反転して返せば更新されません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isShallowEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p>この例ではわざわざ<a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>を使ってますが、Reactには<code>React.PureComponent</code>があるので、そちらを使えば実装は特にいらないです。
(<a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>は<a href="https://github.com/facebook/react/issues/8669">React.PureComponentとはChildrenとかのReact.Elementの扱い</a>が違いますが、大抵は<code>React.PureComponent</code>で十分です。この例ではこの違いは特に関係ないので省きます。)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PureComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p>ここで本題のDeep Equal(<code>JSON.stringify</code>)とShallow Equalの比較のコストの差の話がでてきます。このコストの差は<code>shouldComponentUpdate</code>の処理自体にどれぐらいかかっているかを調べれば比較できます。</p>

<p>React 15まではreact-addon-perfsで比較できましたが、React 16では<code>?react_perf</code>の<code>performance.mark</code>の結果を使うのが簡単です。</p>

<p>実行前に<code>PerformanceObserver</code>でReactが<code>performance.measure</code>した結果をコンソールログに出すように仕込んでおきます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="nb">window</span> <span class="nx">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">PerformanceObserver</span><span class="p">((</span><span class="nx">list</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">components</span><span class="o">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">totalDuration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">getEntries</span><span class="p">().</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">entry</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Display each reported measurement on console</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;shouldComponentUpdate&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
            <span class="nx">totalDuration</span> <span class="o">+=</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">duration</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Name: &quot;</span> <span class="o">+</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span>
                <span class="s2">&quot;, Duration: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">duration</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;\n&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Total</span> <span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">totalDuration</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Updated</span> <span class="nx">components</span><span class="o">:</span><span class="err">`</span><span class="p">,</span> <span class="nx">components</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">});</span>
<span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">({</span> <span class="nx">entryTypes</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;measure&#39;</span><span class="p">]</span> <span class="p">});</span>
</code></pre></div>
<p>このログには、それぞれのコンポーネントの<code>shouldComponentUpdate</code>の時間が出力されます。</p>

<p>次の環境で3回更新を更新を起こした時の<code>shouldComponentUpdate</code>の時間を計測しました。</p>

<ul>
<li>MacBookPro14,1</li>
<li>CPU: Intel Core i7, 2.5 GHz</li>
<li>Browser: Chrome – 6x CPU throttling</li>
</ul>

<h3 id="deep-equal-json-stringify-の結果">Deep Equal(<code>JSON.stringify</code>)の結果</h3>

<p>Deep Equal (<code>JSON.stringify(prevProps) === JSON.stringify(nextProps)</code>):</p>

<p><img src="https://user-images.githubusercontent.com/19714/33408570-7e4ff248-d5ba-11e7-8470-684413a8fb25.png" alt="image"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Name: ⚛ A.shouldComponentUpdate, Duration: 0.9350000000004002

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 1.1300000000001091

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.364999999999782

App.tsx:32 Total shouldComponentUpdate: 7.4650000000001455
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.014999999999417923

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.019999999999527063

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.770000000000437

App.tsx:32 Total shouldComponentUpdate: 5.81499999999869
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate


App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000001018634

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.154999999999745

App.tsx:32 Total shouldComponentUpdate: 5.190000000001419
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate
</code></pre></div>
<h3 id="shallow-equal">Shallow Equal</h3>

<p>Shallow Equal(Use <a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>)</p>

<p><img src="https://user-images.githubusercontent.com/19714/33408628-d3677756-d5ba-11e7-83a3-5113a2e09739.png" alt="image"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Name: ⚛ A.shouldComponentUpdate, Duration: 0.13999999999941792

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.010000000001127773

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 1.125

App.tsx:32 Total shouldComponentUpdate: 1.305000000000291
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:32 Total shouldComponentUpdate: 0.03999999999814463
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:32 Total shouldComponentUpdate: 0.029999999998835847
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate
</code></pre></div>
<h2 id="結果">結果</h2>

<p>Deep Equalは合計で5ms程度かかるのに対して、Shallow Equalは0.02ms程度で済んでいます。
200倍程度の違いがでていますが、これは複雑で巨大なpropsになるほどDeep Equalは不利になります。
(<code>JSON.stringify</code>の結果をキャッシュすれば時間は半分程度になります)</p>

<p>この例は恣意的な比較なので、十分に早いデバイスでそこまで大きくないオブジェクトなら目に見えるコストにはなりにくいです。</p>

<p><code>shouldComponentUpdate</code>はかなり高頻度で呼ばれる処理であるため、この比較処理自体が重いとコンポーネントを更新しなかったとしても重たいことになります。</p>

<p>また、<code>JSON.stringify</code>はReact.Elementなど正しくstringifyできないものが来た場合にも問題がでてくるため実際にはその判定も必要です。(propsにはReactElementが渡されることがある。Childrenとか普通に属性として)
<a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>はReact Elementの比較も考慮したshallow equalの実装です。</p>

<p>BaseComponentなどでDeep Equalなどを使った<code>shouldComponentUpdate</code>は簡単でpropsが小さい間は効果的です。しかし、propsに巨大な配列などや循環参照しているもの、複雑なオブジェクトが入ってくると破綻しやすくなります。</p>

<p>Shallow Equalの場合はそのようなことはありませんが、参照する値の比較になるため状態をImmutableに作ったり、そのImmutableなツリーとして意識する必要がでてきます。</p>

<ul>
<li><a href="http://nekogata.hatenablog.com/entry/2013/06/15/013752" title="「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く">「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く</a></li>
</ul>

<p>Mutableな方法でStateの更新処理を行う場合は、Shallow Equalでは更新したつもりが更新されていないと判定されてしまう場合があります。
よくあるのは配列の値を追加するときに<code>Array#push</code>で行った場合などです。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/array/#mutable-immutable" title="配列 · JavaScriptの入門書 #jsprimer">配列 · JavaScriptの入門書 #jsprimer</a></li>
</ul>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">array</span><span class="o">:</span> <span class="p">[]</span>
<span class="p">};</span>
<span class="c1">// arrayの中身は更新されているけど、`state.array`の参照する配列オブジェクトは同じ</span>
<span class="c1">// Deep Equalでは異なるものとして判定できるけど、Shallow Equalでは同じオブジェクトとなる</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>これをImmutableな形で更新するには、<code>state.array</code>の参照する配列オブジェクトそのものを更新する必要があります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">array</span><span class="o">:</span> <span class="p">[]</span>
<span class="p">};</span>
<span class="c1">// arrayの中身は更新し、かつ`state.array`の参照する配列オブジェクトも更新</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">array</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">array</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>このように、Shallow Equalが効果的に動くようにするためには、状態の管理の仕方も大事になってきます。</p>

<p>例えば、ステート管理ライブラリと言われてるものを見てみると、色々なパターンでこのShallow EqualができるようなStateを作りやすくなっています。</p>

<p><a href="https://redux.js.org/">Redux</a>のReducerで<code>state</code>を受け取り、その<code>state</code>が更新する必要ないなら、そのまま<code>state</code>を返すというパターンはImmutableな状態の実装パターンの一つです。</p>

<p><a href="https://github.com/mobxjs/mobx">MobX</a>の<a href="https://github.com/mobxjs/mobx-state-tree" title="mobx-state-tree">mobx-state-tree</a>は、mutableなmodelを持っておき、immutableなオブジェクトをスナップショットとして取得できます。</p>

<p><a href="https://almin.js.org/">Almin</a>のStoreでは、ReduxのようなパターンでImmutableなStateを更新したり、Repositoryに保存したドメインモデルから必要になったタイミングで新しいStateに変換して返すなどのパターンで実装します。</p>

<p>UIを持つ多くのアプリでは、状態を更新する回数よりも、状態を読み取りUIを作る回数の方が多くなりやすいです。そのため、更新のコストをちょっと払って(Immutableな更新)、状態からUIを更新するコストを小さくする(Shallow Equalにより判定処理自体を簡潔にする)ことがパフォーマンスにも効果がでます。また、更新範囲を抑えることが重要になるので、状態を作るときにある程度コントールしないと影響範囲を抑えるのは難しくなります。</p>

<h2 id="おわり">おわり</h2>

<p>世の中には既にいろんなShallow Equalのライブラリがあります。(大体実装は同じです)
今回はTypeScript対応がなかったのと、デバッグの仕組みを持っているものが見つからなかったのでライブラリを作りました。</p>

<ul>
<li><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a></li>
<li><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a></li>
</ul>

    </div>
    <div class="post-post-toolbar">
        <a class="btn edit-on-github"
           href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2017/2017-11-30-shallow-equal.md"><span
                class="edit-on-github-label"></span>修正リクエストをする</a>
        <nav class="tags"
             id="js-post-tags"
             data-post-tags='["JavaScript","React"]'>
            <span>タグ:</span>
            <ul>
                
                <li><a href="/tags/?q=JavaScript">JavaScript</a></li>
                
                <li><a href="/tags/?q=React">React</a></li>
                
            </ul>
        </nav>
    </div>
    <div class="announce-area">
        <h3>お知らせ欄</h3>
        <div class="announce-text">
            <!--お知らせ-->
JavaScriptに関する最新情報は週一で<a href="http://jser.info/" title="JSer.info">JSer.info</a>を更新しています。

        </div>
        <h3>次に書くかもしれない記事候補</h3>
        <p>興味がありましたら<a href="https://github.com/efcl/efcl.github.io/labels/%E8%A8%98%E4%BA%8B%E5%80%99%E8%A3%9C" title="Issues · efcl/efcl.github.io">Issues · efcl/efcl.github.io</a>からご意見下さい</p>
        <div class="announce-text">
            <iframe src="https://azu.github.io/github-issue-widget/?owner=efcl&repo=efcl.github.io&labels=記事候補&limit=4&random"
                    allowtransparency="true" frameborder="0" scrolling="0" width="100%" height="100%"></iframe>
        </div>
    </div>
    <div class="related-articles" id="js-related-articles">
        <h3>関連記事</h3>
    </div>
</div>
<div class="zenback-embed">
    <!-- X:S ZenBackWidget --><div id="zenback-widget-loader"></div><script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var r=Math.ceil((new Date()*1)*Math.random());var j=d.createElement("script");j.id=i;j.async=true;j.src="//w.zenback.jp/v1/?base_uri=http%3A//efcl.info/&nsid=89229392978401102%3A%3A89229398078677080&rand="+r;d.body.appendChild(j);}}(document,"zenback-widget-js");</script><!-- X:E ZenBackWidget -->
</div>
<div class="disqus-embed" id="js-disqus-embed">
    <button class="comment-button" id="js-comment-button">コメントを表示</button>
</div>

<script type="text/javascript" src="/public/js/tag-fetcher.js"></script>
<script type="text/javascript" src="/public/js/show-related-article.js"></script>
<script type="text/javascript" src="/public/js/show-disqus.js"></script>

    </div>
</article>
</body>
</html>
