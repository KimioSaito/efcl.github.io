<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        
        Almin 0.12リリース: Read層におけるState更新のアプローチ | Web Scratch
        
    </title>
    <meta name="description" content="Almin 0.12をリリースしました。">
    
    <meta name="keywords" content="Almin,JavaScript,library,ReleaseNote" />
    
    <meta name="author" content="azu">
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144"
          href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed/">
    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/main.css">
    <!-- JavaScript -->
    <!-- Open graph tags -->
<meta property="og:title" content="Almin 0.12リリース: Read層におけるState更新のアプローチ">
<meta property="og:type" content="article">
<meta property="og:url" content="http://efcl.info/2017/05/11/almin-0.12/">
<meta property="og:image" content="http://efcl.info">

<meta property="og:description" content="Almin 0.12をリリースしました。">
<meta property="og:site_name" content="Web Scratch">




<meta property="article:published_time" content="2017-05-11T15:22:00+09:00">
<meta property="article:author" content="https://www.facebook.com/">

<meta property="og:see_also" content="http://efcl.info/2017/05/12/read-books/">

<meta property="og:see_also" content="http://efcl.info/2017/05/09/travis-ci-github-token/">

<meta property="og:see_also" content="http://efcl.info/2017/04/26/search-prototype.js/">





<meta property="article:section" content="javascript">





<meta property="article:tag" content="Almin">

<meta property="article:tag" content="JavaScript">

<meta property="article:tag" content="library">

<meta property="article:tag" content="ReleaseNote">


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2184335-8', 'auto');
    ga('send', 'pageview');
</script>
    <script>
var blog_categories = [
{
    "title" : "greasemonkey",
    "count" : 61
},{
    "title" : "ニコニコ動画",
    "count" : 16
},{
    "title" : "小説電子化",
    "count" : 3
},{
    "title" : "vista",
    "count" : 12
},{
    "title" : "firefox",
    "count" : 56
},{
    "title" : "その他",
    "count" : 13
},{
    "title" : "webサービス",
    "count" : 22
},{
    "title" : "software",
    "count" : 58
},{
    "title" : "雑記",
    "count" : 33
},{
    "title" : "まとめ",
    "count" : 11
},{
    "title" : "zaurus",
    "count" : 3
},{
    "title" : "ハードウェア",
    "count" : 8
},{
    "title" : "アドオン",
    "count" : 31
},{
    "title" : "wordpress",
    "count" : 6
},{
    "title" : "javascript",
    "count" : 177
},{
    "title" : "インストール設定",
    "count" : 12
},{
    "title" : "iphone",
    "count" : 10
},{
    "title" : "loox u",
    "count" : 1
},{
    "title" : "tombloo",
    "count" : 3
},{
    "title" : "イベント",
    "count" : 88
},{
    "title" : "userchome.js",
    "count" : 8
},{
    "title" : "jetpack",
    "count" : 7
},{
    "title" : "onenote",
    "count" : 2
},{
    "title" : "nilscript",
    "count" : 4
},{
    "title" : "keysnail",
    "count" : 3
},{
    "title" : "ios",
    "count" : 15
},{
    "title" : "shell",
    "count" : 3
},{
    "title" : "r言語",
    "count" : 2
},{
    "title" : "node.js",
    "count" : 3
},{
    "title" : "mac",
    "count" : 2
},{
    "title" : "github",
    "count" : 11
},{
    "title" : "jekyll",
    "count" : 1
},{
    "title" : "golang",
    "count" : 1
},{
    "title" : "web",
    "count" : 1
},{
    "title" : "スライド",
    "count" : 1
},{
    "title" : "ie",
    "count" : 1
},{
    "title" : "書籍",
    "count" : 2
},{
    "title" : "textlint",
    "count" : 8
}
];
    blog_categories = blog_categories.filter(function(categoryObject){
        return !/^\d+$/.test(categoryObject.title);
    });
</script>
</head>


<body class="layout-reverse theme-base-0d">
<a href="https://github.com/efcl/efcl.github.io" class="github-ribbon">
    <img style="position: fixed; z-index:100; top: 0; right: 0; border: 0;"
         src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
         alt="Fork me on GitHub"
         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<header>
    <div class="site-header">
    <img src="/public/img/reimu-right.png" class="header-logo">

    <h1 class="site-title">
        <a href="/">
            Web Scratch
        </a>
    </h1>
    <p class="lead">ブラウザ/JavaScript等についてのブログ</p>

</div>
</header>
<aside>
    <div class="sidebar">
    <div class="container">
        <div class="profile">
            <a href="/about/" title="About"><img src="/public/img/azu.png" alt="Profile"></a>

            <h2><a href="/about/" title="About">azu</a></h2>
        </div>
        <div class="social">
            <a class="twitter" href="http://twitter.com/azu_re" title="Twitter">
                <img src="/public/svg/twitter.svg" alt="twitter" width="32" height="32"/>
            </a>
            <a class="github" href="https://github.com/azu" title="GitHub">
                <img src="/public/svg/github.svg" alt="GitHub" width="32" height="32"/>
            </a>
            <a class="rss" href="/feed/" title="RSS Feed">
                <img src="/public/svg/feed.svg" alt="RSS" width="32" height="32"/>
            </a>
        </div>
        <nav class="sidebar-nav">
            <div class="search">
                <form class="search-box" method="get" action="https://www.google.co.jp/search">
                    <label for="search-box-label">検索:</label>
                    <input type="hidden" name="q" value="site:efcl.info">
                    <input id="search-box-label" type="search" name="q">
                    <input type="submit" value="search">
                </form>
            </div>
            <div class="recent">
    <h3 class="recent-posts-list-title">
        <a href="/">最近の投稿</a>
    </h3>
    <ul class="recent-posts">
        
        <li>
            <a href="/2017/05/12/read-books/">
                Living Documentation by design, with Domain-Driven Designを読んだ
            </a>
        </li>
        
        <li>
            <a href="/2017/05/11/almin-0.12/">
                Almin 0.12リリース: Read層におけるState更新のアプローチ
            </a>
        </li>
        
        <li>
            <a href="/2017/05/09/travis-ci-github-token/">
                Travis CIでGitHub Personal access tokensが漏れないようにする
            </a>
        </li>
        
        <li>
            <a href="/2017/04/26/search-prototype.js/">
                コード中にあるprototype.jsの拡張メソッドを使ってる部分を検索するツール
            </a>
        </li>
        
    </ul>
</div>
            <div class="recent">
    <h3 class="categories-list-title"><a href="/categories">カテゴリ一覧</a></h3>

    <div class="categories-list" id="js-categories-list">

    </div>
    <script>
        (function () {
            var categoriesList = window.blog_categories;
            var appendPoint = document.getElementById("js-categories-list");
            // big ... small
            var sortedCategories = categoriesList.sort(function (a, b) {
                return a.count < b.count ? 1 : -1;
            });
            var ulTag = document.createElement("ul");
            var displayCount = sortedCategories.length < 3 ? sortedCategories.length : 3;
            for (var i = 0; i < displayCount; i++) {
                var category = sortedCategories[i];
                var liTag = document.createElement("li");
                var aTag = document.createElement("a");
                aTag.href = "/categories#" + category.title;
                aTag.textContent = category.title;
                var spanTag = document.createElement("span");
                spanTag.appendChild(document.createTextNode("[" + category.count + "]"));
                liTag.appendChild(aTag);
                liTag.appendChild(spanTag);
                ulTag.appendChild(liTag);
            }
            var lastLiTag = document.createElement("li");
            var lastATag = document.createElement("a");
            lastATag.href = "/categories";
            lastATag.textContent = "その他のタグ…";
            lastLiTag.appendChild(lastATag);
            ulTag.appendChild(lastATag);
            appendPoint.appendChild(ulTag);
        })();
    </script>
</div>
        </nav>
    </div>
</div>

</aside>
<article>
    <div class="content container">
        <div class="post" id="js-post-url" data-post-url="/2017/05/11/almin-0.12/">
    <h1 class="post-title">Almin 0.12リリース: Read層におけるState更新のアプローチ</h1>

    <div class="pre-post-toolbar">
        <span class="post-date">2017年05月11日</span>
        <a class="btn edit-on-github" href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2017/2017-05-11-almin-0.12.md"><span class="edito-on-github-label"></span>Edit on GitHub</a>

    </div>
    <div class="post-content">
        <p><a href="https://github.com/almin/almin" title="Almin">Almin</a> 0.12をリリースしました。</p>

<ul>
<li><a href="https://github.com/almin/almin/releases/tag/almin%400.12.3" title="Release Almin 0.12 · almin/almin">Release Almin 0.12 · almin/almin</a></li>
</ul>

<p><code>Store</code>と<code>StoreGroup</code>が書き直されたので色々変わっていますが、マイグレーションツールでアップデートできます。</p>

<h2 id="変更点">変更点</h2>

<h3 id="storegroupを書き直した"><code>StoreGroup</code>を書き直した</h3>

<p><strong>Before</strong>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="nx">a</span> <span class="o">:</span> <span class="s2">&quot;a value&quot;</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">BStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="nx">b</span> <span class="o">:</span> <span class="s2">&quot;b value&quot;</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">aStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">bStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">(</span>
    <span class="nx">aStore</span><span class="p">,</span>
    <span class="nx">bStore</span>
<span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">storeGroup</span><span class="p">.</span><span class="nx">getState</span><span class="p">());</span>
<span class="c1">// { a: &quot;a value&quot;, b: &quot;b value&quot; }</span>
</code></pre></div>
<p><strong>After</strong>:</p>

<p>Almin 0.12 では次のように<code>StoreGroup</code>のコンストラクタに</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">{</span>
 <span class="s2">&quot;ステート名&quot;</span><span class="o">:</span> <span class="nx">store</span>
<span class="p">}</span>
</code></pre></div>
<p>という組み合わせで定義を渡すようになりました。
代わりに<code>Store#getState</code>でステート名を返さなくても良くなっています。</p>

<p>Reduxの<a href="http://redux.js.org/docs/api/combineReducers.html" title="combineReducers · Redux">combineReducers</a>と似たような感じです(変更してから似てるのに気づいた)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&quot;a value&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">BStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&quot;b value&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">aStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">bStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">({</span>
    <span class="c1">// stateName: store</span>
    <span class="nx">a</span><span class="o">:</span> <span class="nx">aStore</span><span class="p">,</span>
    <span class="nx">b</span><span class="o">:</span> <span class="nx">bStore</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">storeGroup</span><span class="p">.</span><span class="nx">getState</span><span class="p">());</span>
<span class="c1">// { a: &quot;a value&quot;, b: &quot;b value&quot; }</span>
</code></pre></div>
<p>古い<code>StoreGroup</code>の実装を使いたい場合は<a href="https://github.com/almin/legacy-store-group" title="legacy-store-group">legacy-store-group</a>にあるのでモジュールとして利用できます。</p>

<p>この変更の主な目的は次の2つです。</p>

<ul>
<li><code>Store#getState</code>を単純にStateを返すように</li>
<li>型の整合がとれたStoreGroup</li>
</ul>

<p>次のように<code>context.getState()</code>した結果が、最初にコンストラクタで渡した<code>Store</code>と<code>State</code>の関係でマッピングされて自動的に型付けされたstateのオブジェクトを返すようになっています。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="c1">// Store &lt;-&gt; Stateの関係を定義</span>
<span class="kr">interface</span> <span class="nx">AState</span> <span class="p">{</span>
    <span class="nx">a</span>: <span class="kt">number</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span><span class="o">&lt;</span><span class="nx">AState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">state</span>: <span class="kt">AState</span><span class="p">;</span>
    <span class="c1">// ..</span>
    <span class="nx">getState() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// StoreGroup</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">({</span>
    <span class="nx">aState</span>: <span class="kt">new</span> <span class="nx">AStore</span><span class="p">()</span>
<span class="p">});</span>
<span class="c1">// Context</span>
<span class="kr">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Context</span><span class="p">({</span>
    <span class="nx">dispatcher</span><span class="p">,</span>
    <span class="nx">store</span>: <span class="kt">storeGroup</span>
<span class="p">});</span>
<span class="c1">// get state</span>
<span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">getState</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">unknown</span><span class="p">);</span> <span class="c1">// &lt;= 知らないstateを参照してる</span>
</code></pre></div>
<p><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494484857.png" alt="storegroup"></p>

<p>ちゃんとTypeScriptでコンパイルエラーになる。</p>

<h3 id="store-receivepayload-payload-payload-の追加"><code>Store#receivePayload(payload: Payload)</code>の追加</h3>

<p>Storeに<code>receivePayload(payload: Payload)</code>というメソッドを実装するとAlminのライフサイクルにおいて、それが呼びされるようになりました。
Reactの<code>componentWillReceiveProps(nextProps)</code>と役割が似ています。</p>

<p>これを導入した経緯は以下のIssueにも書いているのですが、<a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">クライアントサイドでCQRSをちゃんとやろう</a>としたのがAlminの開発目的の一つなので、その目的を再確認した結果として生まれました。</p>

<ul>
<li><a href="https://github.com/almin/almin/pull/160" title="feat(Store): add Store#receivePayload(payload: Payload) by azu · Pull Request #160 · almin/almin">feat(Store): add Store#receivePayload(payload: Payload) by azu · Pull Request #160 · almin/almin</a></li>
</ul>

<p>Alminの最初の目的として、writeとreadの掛け算の複雑さを一つのモデルに持たせるのはやめようというところから始まっています。
1つのモデルですべてをやるのではなく、writeとreadの2つのモデルに分けることでこの複雑さの掛け算をなくす目的です。</p>

<hr>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a>より</p>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494485424.png" alt="slide 1"></a></p>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494485454.png" alt="slide 2"></a></p>

<hr>

<p>この考え方で、Domain(いわゆるロジックを持つモデル/Write model)とStore(ViewModelのようなViewのためのモデル/Read Model)の2種類にわけることで、ビジネスロジックはDomainに集中することができました。
またViewはどのようなUIを目指すかによって、色々な細かいStateがでてきます。</p>

<p>しかし、Viewを意識したコードはStore/Stateで吸収できるので、Domain modelが変にUIを意識して書くケースをかなり減らせていたと思います。</p>

<p>先ほどのスライドでいうと、DomainはWrite層で、StoreはRead層という分離ができていました。</p>

<p>しかし、書いていくとStore側はRead層であるにもかかわらず、次のような書き込む処理が出てきています。(<code>this.onDispatch</code>でイベントを受け取って、<code>Store</code>が保持する<code>state</code>を更新する処理)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">CounterState</span> <span class="nx">from</span> <span class="s2">&quot;./CounterState&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CounterStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">();</span>
        <span class="c1">// initial state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CounterState</span><span class="p">({</span>
            <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">});</span>
        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// return own state</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このRead層にも書き込み処理があるのが気持ち悪いなーと思いました。
しかし、Write層で作ったものをRead層に渡す方法(タイミング)がないとViewに反映されないので、Read層のどこかでStateを更新する必要があるのは明白です。</p>

<p>これについて考えていて、<a href="https://msdn.microsoft.com/en-us/library/jj554200.aspx" title="CQRS Journey">CQRS Journey</a>というCQRSについて書かれた文書中に次のような図がでてきます。</p>

<p><img src="https://msdn.microsoft.com/en-us/library/jj591579.2c44f48caf131a5a65fcb0799a3ad4e7(l=en-us).png" alt="image"></p>

<p>この図では<code>OrderViewModelGenerator</code>というRead層にあるものが、Read層のRepositoryにデータを書き込んでいる様子が見えます。
(Write modelからドメインイベントを受け取り、それを<code>OrderViewModelGenerator</code>がRead modelに変換して保存するという流れ)</p>

<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/jj591579" title="Journey 4: Extending and Enhancing the Orders and Registrations Bounded Context">Journey 4: Extending and Enhancing the Orders and Registrations Bounded Context</a></li>
</ul>

<p>Almin 0.11まではこの<code>OrderViewModelGenerator</code>にあたるような、Read層のデータを更新する要素が明示的には存在していませんでした。
そのため、次のようにRead層でWrite層からくるイベントを受け取って更新するという処理を各Storeに書いたりしていました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
</code></pre></div>
<p>この「Write層からくるイベントを受け取り、Read層を更新する」を明示的なStoreのライフサイクルとして取り入れようとしてできたのが、<code>Store#receivePayload(payload: Payload)</code>です。</p>

<p><code>Store#receivePayload(payload: Payload)</code>はWrite層からイベント発火やAlminのライフサイクルで呼び出されるため、先ほどのコードは次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"> import { Store } from &quot;almin&quot;;
 import CounterState from &quot;./CounterState&quot;;
 export class CounterStore extends Store {
     constructor() {
         super();
         // initial state
         this.state = new CounterState({
             count: 0
         });
<span class="gd">-        // receive event from UseCase, then update state</span>
<span class="gd">-        this.onDispatch(payload =&gt; {</span>
<span class="gd">-            const newState = this.state.reduce(payload);</span>
<span class="gd">-            if (newState !== this.state) {</span>
<span class="gd">-                this.state = newState;</span>
<span class="gd">-                this.emitChange();</span>
<span class="gd">-            }</span>
<span class="gd">-        });</span>
     }

<span class="gi">+    // receive event from UseCase, then update state</span>
<span class="gi">+    receivePayload(payload) {</span>
<span class="gi">+        this.setState(this.state.reduce(payload));</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    // return own state</span>
     getState() {
        return this.state;
     }
 }
</code></pre></div>
<p>単純に言えば、Storeのstateを更新する処理は<code>receivePayload</code>に書けばいいという形です。
(Reactで<code>componentWillReceiveProps(nextProps)</code>の中で<code>setState</code>が許可されているのと同じです)</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff">import { Store } from &quot;almin&quot;;
import CounterState from &quot;./CounterState&quot;;
export class CounterStore extends Store {
    constructor() {
        super();
        // initial state
        this.state = new CounterState({
            count: 0
        });
    }

    // receive event from UseCase, then update state
    receivePayload(payload) {
        this.setState(this.state.reduce(payload));
    }

    // return own state
    getState() {
        return this.state;
    }
}
</code></pre></div>
<p>Almin 0.12でも今までのように自分でイベントを監視して更新する方法も動きます。
しかし、<code>Store#receivePayload(payload: Payload)</code>を使ったほうが将来的な最適化の余地が生まれるのでこちらを推奨しています。
(簡単にいうと、自分で監視したイベントと違い<code>Store#receivePayload(payload: Payload)</code>はAlminのライフサイクル管理下にあるので、うまいこと処理をできる可能性があるということ)</p>

<p>次のTodoMVCのサンプルでもその説明をしています。</p>

<ul>
<li><a href="https://almin.js.org/docs/tutorial/todomvc/" title="Todo App · Almin.js">Todo App · Almin.js</a></li>
</ul>

<h3 id="read側のstate更新アプローチ">Read側のState更新アプローチ</h3>

<p>(次の前提の)Read側のState更新処理のアプローチ多く分けて2つあると思います。</p>

<p>前提として、Read側のStateというのはWrite側のドメインモデルやデータベースをソースにして、View向けのデータしたものという扱いです(つまりWrite -&gt; Readという順序と関係がある)</p>

<p>そのため、Read側のStateは元となるソースから計算した値を持つComputed propertyのような形になってます。</p>

<p>Mobxの<a href="https://github.com/mobxjs/mobx-state-tree" title="mobx-state-tree">mobx-state-tree</a>というライブラリについて紹介してる<a href="https://immer-mutable-state.surge.sh/#1" title="The Quest For Immer Mutable State Management">The Quest For Immer Mutable State Management</a>というスライドは、その2つの方法についてわかりやすく書かれています。</p>

<p><strong>Pull Based: Recompute every time value is needede</strong></p>

<p>簡単に言えばgetterです。
そのプロパティの値を取得するときに、計算して返すという形です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nx">firstName</span> <span class="o">=</span> <span class="s2">&quot;Michel&quot;</span>
    <span class="nx">lastName</span> <span class="o">=</span> <span class="s2">&quot;Weststrate&quot;</span>
    <span class="nx">get</span> <span class="nx">fullName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;calculating!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Push Based: Recompute when a source value changes</strong></p>

<p>もう一つは、ソースとなる値が変化した時に事前に計算結果を作って置くという方法です。
簡単に言えばキャッシュを事前に作っておくイメージです。</p>

<p>この場合は<code>lastName</code>か<code>firstName</code>の値が変化した時に<code>fullName</code>というプロパティを計算して更新するということです。
<code>person.fullName</code>へアクセスした時はその結果を返すだけです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="err">@</span><span class="nx">observable</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="s2">&quot;Michel&quot;</span>
    <span class="err">@</span><span class="nx">observable</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="s2">&quot;Weststrate&quot;</span>
    <span class="err">@</span><span class="nx">computed</span> <span class="nx">get</span> <span class="nx">fullName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;calculating!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このPullとPushの方法 どちらがいいのかはケースバイケースで、プロパティの値を読む回数が多いなら、事前に計算結果が作れる<strong>Push Based: Recompute when a source value changes</strong>の方がコストが低くなるかもしれません。
逆に、書き込む回数の方が圧倒的に多いなら、<strong>Pull Based: Recompute every time value is needede</strong>で実際に読むこむときに遅延評価的に結果を作って返したほうがコストが低いです。
(両方合わせるとかも考えられます)</p>

<p>話を戻して、先ほどのAlminのコードはソースの変更があったことを元に書き込んでいるのでPush Basedなやり方と言えます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">CounterState</span> <span class="nx">from</span> <span class="s2">&quot;./CounterState&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CounterStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">();</span>
        <span class="c1">// initial state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CounterState</span><span class="p">({</span>
            <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">});</span>
        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// return own state</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>しかし、先ほども書いたように自分でイベントを監視(<code>this.onDispatch</code>)だと、そのStoreがPush Basedで更新する処理があるかが外から(この場合はStoreGroupから)はわかりません。
イベントを監視 !== 更新処理がある ではないからです。</p>

<p><code>receivePayload</code>を実装している == 更新処理がある という形になります。(必ずも更新されるわけではないですが、更新を期待していい形になる)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">    <span class="c1">// receive event from UseCase, then update state</span>
    <span class="nx">receivePayload</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">));</span>
    <span class="p">}</span>
</code></pre></div>
<p>このようなインターフェースが決まると何が嬉しいかというと、次のようなReduxのreducerみたいなインターフェースでStoreを書けるようにしようといったことがやりやすくなります。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span><span class="p">,</span> <span class="nx">Payload</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">State</span> <span class="p">{</span>
    <span class="nx">reduce</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">State</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="o">|</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Reactor</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">State</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="kr">abstract</span> <span class="nx">state</span>: <span class="kt">T</span><span class="p">;</span>
    <span class="kr">abstract</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">prevState</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>

    <span class="nx">receivePayload</span><span class="p">(</span><span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span> <span class="nx">reduce</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">shouldStateUpdate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">newState</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">getState() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// The user implement this</span>
<span class="kr">class</span> <span class="nx">MyStore</span> <span class="kr">extends</span> <span class="nx">Reactor</span> <span class="p">{</span>
    <span class="nx">reduce</span><span class="p">(</span><span class="nx">prevState</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
            <span class="k">case</span> <span class="s2">&quot;INCREMENT&quot;</span><span class="o">:</span>
                <span class="k">return</span> <span class="nx">prevState</span> <span class="o">+</span> <span class="nx">1</span>:
            <span class="kt">default</span><span class="o">:</span>
                <span class="k">return</span> <span class="nx">prevState</span><span class="p">;</span>
        <span class="p">}</span>   
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>簡単にまとめると、まだ曖昧な部分があったStoreをもう少し明確な役割付けしたという話です。</p>

<p><strong>Notes:</strong></p>

<p><code>receivePayload</code>という名前がまだしっくりきてないところがある。
なんかもっと広い意味になる可能性がありそうなので、何かもっといい方法があるのかもしれない。</p>

<p>Read層にもRead用のRepositoryやRead用のDatabaseなどを用意すれば、もっとクラス的に分解できるけど、流石にそこまでやるととオーバーキルな感じがしたのでやらなかった。
理由として、Read(View)側のデータを永続的なデータベースに書き込んで保持したいというケースが浮かばなかった(Read側はそこまで複雑な永続データを持ちたくないはず)</p>

<p>UI的に保持したい状態ってIndexedDBじゃなくて、localStorageに保存するぐらいで終わる気がした。</p>

<blockquote>
<p>FluxのStoreの話</p>
</blockquote>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494492570.png" alt="Flux Store"></a></p>

<h2 id="マイグレーション方法">マイグレーション方法</h2>

<p>Almin 0.11から0.12へのアップグレードは次のマイグレーションツールが利用できます。</p>

<ul>
<li><a href="https://github.com/almin/migration-tools" title="almin/migration-tools: Migration scripts for Almin.">almin/migration-tools: Migration scripts for Almin.</a></li>
</ul>

<p>jscodeshiftというツールで動くマイグレーションスクリプトを用意しています。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># Installation
npm install -g jscodeshift @almin/migration-tools 
# 1. Storeクラスを一括で変換
jscodeshift --run-in-band -t `npm root -g`/@almin/migration-tools/scripts/store-get-state-return-object-to-flat.js src/store/*/**/*Store.js
# 2. 1.の変換結果を使ってStoreGroupを変換
jscodeshift --run-in-band -t `npm root -g`/@almin/migration-tools/scripts/store-group-arguments.js src/store/AppStore.js
# store-state-mapping.jsonは変換中に使うデータなので消していい
rm store-state-mapping.json
</code></pre></div>
<p>実際にアップデートしてる例は次のPRを見てください。</p>

<ul>
<li><a href="https://github.com/azu/presentation-annotator/pull/11" title="chore(deps): update dependencies by azu · Pull Request #11 · azu/presentation-annotator">chore(deps): update dependencies by azu · Pull Request #11 · azu/presentation-annotator</a></li>
<li><a href="https://github.com/textlint/textlint-app/pull/5" title="chore(almin): Update to Almin 0.12 by azu · Pull Request #5 · textlint/textlint-app">chore(almin): Update to Almin 0.12 by azu · Pull Request #5 · textlint/textlint-app</a></li>
</ul>

<p>その他の変更点についてはリリースノートをみてください。</p>

<ul>
<li><a href="https://github.com/almin/almin/releases/tag/almin%400.12.3" title="Release Almin 0.12 · almin/almin">Release Almin 0.12 · almin/almin</a></li>
</ul>

<h2 id="next">Next</h2>

<p>Almin 0.12 + TypeScriptならStoreは、型の整合がとれるように書けるようなったと思います。
(明示的なキャストなどむりやりやらなくても型がちゃんとついてくる)</p>

<p>UseCaseの部分が余計な情報を明示的に渡さないと型チェックが上手くできていません。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="nx">type</span> <span class="nx">MyUseCaseArgs</span> <span class="o">=</span> <span class="kt">string</span><span class="p">;</span>
<span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">MyUseCaseArgs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
            <span class="nx">value</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// execute UseCase</span>
<span class="kr">const</span> <span class="nx">useCase</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyUseCase</span><span class="p">();</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">(</span><span class="nx">useCase</span><span class="p">).</span><span class="nx">execute</span><span class="o">&lt;</span><span class="nx">MyUseCaseArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
     <span class="c1">// something</span>
  <span class="p">})</span><span class="o">:</span>
</code></pre></div>
<p>これを次期Alminでは次のように書けるようにしたいと思っています。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
            <span class="nx">value</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">(</span><span class="k">new</span> <span class="nx">MyUseCase</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">executor</span><span class="p">(</span><span class="nx">useCase</span> <span class="o">=&gt;</span> <span class="nx">useCase</span><span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span> <span class="c1">// &lt;= Error</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div>
<p>この辺で上手くBatch Action的な処理も解決できればなーと思って考えています。</p>

<p>次のIssueとPRで実験してるので何か意見があったらください。
(特に<code>executor</code>とかの命名が難しい…)</p>

<ul>
<li><a href="https://github.com/almin/almin/issues/193" title="UseCase: Fluent style UseCase · Issue #193 · almin/almin">UseCase: Fluent style UseCase · Issue #193 · almin/almin</a></li>
<li><a href="https://github.com/almin/almin/pull/194" title="[WIP] feat(UseCase): Fluent style UseCase by azu · Pull Request #194 · almin/almin">[WIP] feat(UseCase): Fluent style UseCase by azu · Pull Request #194 · almin/almin</a></li>
</ul>

    </div>
    <div class="post-post-toolbar">
        <a class="btn edit-on-github"
           href="https://github.com/efcl/efcl.github.io/edit/develop/_posts/2017/2017-05-11-almin-0.12.md"><span
                class="edit-on-github-label"></span>修正リクエストをする</a>
        <nav class="tags"
             id="js-post-tags"
             data-post-tags='["Almin","JavaScript","library","ReleaseNote"]'>
            <span>タグ:</span>
            <ul>
                
                <li><a href="/tags/?q=Almin">Almin</a></li>
                
                <li><a href="/tags/?q=JavaScript">JavaScript</a></li>
                
                <li><a href="/tags/?q=library">library</a></li>
                
                <li><a href="/tags/?q=ReleaseNote">ReleaseNote</a></li>
                
            </ul>
        </nav>
    </div>
    <div class="announce-area">
        <h3>お知らせ欄</h3>
        <div class="announce-text">
            <!--お知らせ-->
JavaScriptに関する最新情報は週一で<a href="http://jser.info/" title="JSer.info">JSer.info</a>を更新しています。

        </div>
        <h3>次に書くかもしれない記事候補</h3>
        <p>興味がありましたら<a href="https://github.com/efcl/efcl.github.io/labels/%E8%A8%98%E4%BA%8B%E5%80%99%E8%A3%9C" title="Issues · efcl/efcl.github.io">Issues · efcl/efcl.github.io</a>からご意見下さい</p>
        <div class="announce-text">
            <iframe src="https://azu.github.io/github-issue-widget/?owner=efcl&repo=efcl.github.io&labels=記事候補&limit=4&random"
                    allowtransparency="true" frameborder="0" scrolling="0" width="100%" height="100%"></iframe>
        </div>
    </div>
    <div class="related-articles" id="js-related-articles">
        <h3>関連記事</h3>
    </div>
</div>
<div class="zenback-embed">
    <!-- X:S ZenBackWidget --><div id="zenback-widget-loader"></div><script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var r=Math.ceil((new Date()*1)*Math.random());var j=d.createElement("script");j.id=i;j.async=true;j.src="//w.zenback.jp/v1/?base_uri=http%3A//efcl.info/&nsid=89229392978401102%3A%3A89229398078677080&rand="+r;d.body.appendChild(j);}}(document,"zenback-widget-js");</script><!-- X:E ZenBackWidget -->
</div>
<div class="disqus-embed" id="js-disqus-embed">
    <button class="comment-button" id="js-comment-button">コメントを表示</button>
</div>

<script type="text/javascript" src="/public/js/tag-fetcher.js"></script>
<script type="text/javascript" src="/public/js/show-related-article.js"></script>
<script type="text/javascript" src="/public/js/show-disqus.js"></script>

    </div>
</article>
</body>
</html>
