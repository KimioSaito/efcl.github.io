{"version":3,"sources":["../src/no-start-duplicated-conjunction.js"],"names":["splitSentence","require","split","SentenceSyntax","Syntax","defaultOptions","interval","pointing","getFirstPhrase","sentence","phrases","value","length","trim","module","exports","context","options","helper","ignoreNodeManager","getSource","report","RuleError","previousPhases","useDuplicatedPhase","Header","HorizontalRule","Paragraph","node","ignoreTypes","Code","Link","Image","BlockQuote","Emphasis","isChildNode","ignoreChildrenByTypes","source","text","toString","sentences","charRegExp","filter","type","Sentence","forEach","phrase","indexOf","sentenceStartIndex","range","originalIndex","originalIndexFromIndex","targetIndex","isIgnoredIndex","line","Math","max","loc","start","column","unshift","slice"],"mappings":"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","file":"no-start-duplicated-conjunction.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {RuleHelper, IgnoreNodeManager} from \"textlint-rule-helper\";\nimport ObjectAssign from \"object-assign\";\nconst splitSentence = require(\"sentence-splitter\").split;\nconst SentenceSyntax = require(\"sentence-splitter\").Syntax;\nimport StringSource from \"textlint-util-to-string\";\nconst defaultOptions = {\n    interval: 2\n};\nconst pointing = /[、,]/;\n// conjunction\nfunction getFirstPhrase(sentence) {\n    var phrases = sentence.value.split(pointing);\n    if (phrases.length > 0) {\n        return phrases[0].trim();\n    }\n}\nmodule.exports = function(context, options = {}) {\n    options = ObjectAssign({}, defaultOptions, options);\n    const helper = new RuleHelper(context);\n    const ignoreNodeManager = new IgnoreNodeManager();\n    const {Syntax, getSource, report, RuleError} = context;\n    let previousPhases = [];\n    let useDuplicatedPhase = false;\n    return {\n        // reset count\n        [Syntax.Header](){\n            previousPhases = [];\n        },\n        [Syntax.HorizontalRule](){\n            previousPhases = []\n        },\n        [Syntax.Paragraph](node){\n            // FIXME: linkReference should be defined in TxtAST.\n            const ignoreTypes = [\n                Syntax.Code, Syntax.Link, \"linkReference\", Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis\n            ];\n            if (helper.isChildNode(node, ignoreTypes)) {\n                return;\n            }\n            ignoreNodeManager.ignoreChildrenByTypes(node, ignoreTypes);\n            const source = new StringSource(node);\n            const text = source.toString();\n            const sentences = splitSentence(text, {\n                charRegExp: /[。]/\n            }).filter(sentence => {\n                return sentence.type === SentenceSyntax.Sentence;\n            });\n            sentences.forEach(sentence => {\n                const phrase = getFirstPhrase(sentence);\n                if (phrase.length === 0) {\n                    return;\n                }\n                if (previousPhases.indexOf(phrase) !== -1) {\n                    useDuplicatedPhase = true;\n                }\n                if (useDuplicatedPhase) {\n                    const sentenceStartIndex = node.range[0] + sentence.range[0];\n                    const originalIndex = source.originalIndexFromIndex(sentenceStartIndex);\n                    // adjust index \n                    // if  \"また、[import, a.js](a.js)\" then originalIndex is used.\n                    // if \"[import, binary-example.js](src/binary-example.js)\" then  originalIndex is undefined.\n                    const targetIndex = typeof originalIndex !== \"undefined\" ? originalIndex : sentenceStartIndex;\n                    if (!ignoreNodeManager.isIgnoredIndex(targetIndex)) {\n                        report(node, new RuleError(`Don't repeat \"${phrase}\" in ${options.interval} phrases`, {\n                            line: Math.max(sentence.loc.start.line - 1, 0),\n                            column: sentence.loc.start.column\n                        }));\n                    }\n                    useDuplicatedPhase = false;\n                }\n                // add first item\n                previousPhases.unshift(phrase);\n                previousPhases = previousPhases.slice(0, options.interval);\n            });\n        }\n    }\n};"]}