// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _textlintUtilToString = require("textlint-util-to-string");

var _textlintUtilToString2 = _interopRequireDefault(_textlintUtilToString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var splitSentence = require("sentence-splitter").split;
var SentenceSyntax = require("sentence-splitter").Syntax;

var defaultOptions = {
    interval: 2
};
var pointing = /[、,]/;
// conjunction
function getFirstPhrase(sentence) {
    var phrases = sentence.value.split(pointing);
    if (phrases.length > 0) {
        return phrases[0].trim();
    }
}
module.exports = function (context) {
    var _ref;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    options = (0, _objectAssign2.default)({}, defaultOptions, options);
    var helper = new _textlintRuleHelper.RuleHelper(context);
    var ignoreNodeManager = new _textlintRuleHelper.IgnoreNodeManager();
    var Syntax = context.Syntax,
        getSource = context.getSource,
        report = context.report,
        RuleError = context.RuleError;

    var previousPhases = [];
    var useDuplicatedPhase = false;
    return _ref = {}, _defineProperty(_ref, Syntax.Header, function () {
        previousPhases = [];
    }), _defineProperty(_ref, Syntax.HorizontalRule, function () {
        previousPhases = [];
    }), _defineProperty(_ref, Syntax.Paragraph, function (node) {
        // FIXME: linkReference should be defined in TxtAST.
        var ignoreTypes = [Syntax.Code, Syntax.Link, "linkReference", Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis];
        if (helper.isChildNode(node, ignoreTypes)) {
            return;
        }
        ignoreNodeManager.ignoreChildrenByTypes(node, ignoreTypes);
        var source = new _textlintUtilToString2.default(node);
        var text = source.toString();
        var sentences = splitSentence(text, {
            charRegExp: /[。]/
        }).filter(function (sentence) {
            return sentence.type === SentenceSyntax.Sentence;
        });
        sentences.forEach(function (sentence) {
            var phrase = getFirstPhrase(sentence);
            if (phrase.length === 0) {
                return;
            }
            if (previousPhases.indexOf(phrase) !== -1) {
                useDuplicatedPhase = true;
            }
            if (useDuplicatedPhase) {
                var sentenceStartIndex = node.range[0] + sentence.range[0];
                var originalIndex = source.originalIndexFromIndex(sentenceStartIndex);
                // adjust index 
                // if  "また、[import, a.js](a.js)" then originalIndex is used.
                // if "[import, binary-example.js](src/binary-example.js)" then  originalIndex is undefined.
                var targetIndex = typeof originalIndex !== "undefined" ? originalIndex : sentenceStartIndex;
                if (!ignoreNodeManager.isIgnoredIndex(targetIndex)) {
                    report(node, new RuleError("Don't repeat \"" + phrase + "\" in " + options.interval + " phrases", {
                        line: Math.max(sentence.loc.start.line - 1, 0),
                        column: sentence.loc.start.column
                    }));
                }
                useDuplicatedPhase = false;
            }
            // add first item
            previousPhases.unshift(phrase);
            previousPhases = previousPhases.slice(0, options.interval);
        });
    }), _ref;
};
//# sourceMappingURL=no-start-duplicated-conjunction.js.map