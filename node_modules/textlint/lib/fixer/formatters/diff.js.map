{"version":3,"sources":["../../../src/fixer/formatters/diff.js"],"names":[],"mappings":"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","file":"diff.js","sourcesContent":["\"use strict\";\nvar fs = require(\"fs\");\nvar existsSync = require(\"exists-sync\");\nvar jsdiff = require(\"diff\");\nvar chalk = require(\"chalk\");\n/**\n * Given a word and a count, append an s if count is not one.\n * @param {string} word A word in its singular form.\n * @param {int} count A number controlling whether word should be pluralized.\n * @returns {string} The original word with an s on the end if count is not one.\n */\nfunction pluralize(word, count) {\n    return count === 1 ? word : word + \"s\";\n}\n\nfunction isModified(part) {\n    if (!part) {\n        return false;\n    }\n    return typeof part === \"object\" && (part.removed || part.added);\n}\nfunction addMarkEachLine(mark, text) {\n    if (text.length === 0) {\n        return \"\\n\";\n    }\n    const lines = text.split(\"\\n\");\n    const markedLines = lines.filter(line => line.length > 0).map(line => {\n        return mark + line;\n    });\n    return markedLines.join(\"\\n\") + \"\\n\";\n}\nmodule.exports = function (results, options) {\n    // default: true\n    chalk.enabled = options.color !== undefined ? options.color : true;\n    var output = \"\\n\";\n    var totalFixed = 0;\n    var errors = 0;\n    var summaryColor = \"yellow\";\n    var greenColor = \"green\";\n\n    results.forEach(function (result) {\n        var filePath = result.filePath;\n        var messages = result.applyingMessages;\n        // still error count\n        var remainingMessages = result.remainingMessages;\n        errors += remainingMessages.length;\n        totalFixed += messages.length;\n        if (messages.length === 0) {\n            return;\n        }\n        if (!existsSync(filePath)) {\n            return;\n        }\n        output += chalk.underline(result.filePath) + \"\\n\";\n\n        var originalContent = fs.readFileSync(filePath, \"utf-8\");\n        var diff = jsdiff.diffLines(originalContent, result.output);\n\n        diff.forEach(function (part, index) {\n            var prevLine = diff[index - 1];\n            var nextLine = diff[index + 1];\n            if (!isModified(part) && part.count > 1) {\n                const greyColor = \"grey\";\n                /*\n                    <MODIFIED>\n                    first line\n                    ....\n                 */\n                if (isModified(prevLine)) {\n                    const lines = part.value.split(\"\\n\");\n                    output += chalk[greyColor](lines[0]) + \"\\n\";\n                }\n                output += chalk[greyColor](\"...\");\n                if (isModified(nextLine)) {\n                    const lines = part.value.split(\"\\n\");\n                    output += chalk[greyColor](lines[lines.length - 1]) + \"\\n\";\n                }\n                /*\n                    ...\n                    last line\n                    <MODIFIED>\n                 */\n                return;\n            }\n            // green for additions, red for deletions\n            // grey for common parts\n            let lineColor;\n            let diffMark = \"\";\n            if (part.added) {\n                lineColor = \"green\";\n                diffMark = \"+ \";\n            } else if (part.removed) {\n                lineColor = \"red\";\n                diffMark = \"- \";\n            } else {\n                lineColor = \"grey\";\n                diffMark = \"\";\n            }\n            output += chalk[lineColor](addMarkEachLine(diffMark, part.value));\n        });\n        output += \"\\n\\n\";\n    });\n\n    if (totalFixed > 0) {\n        output += chalk[greenColor].bold([\n            // http://www.fileformat.info/info/unicode/char/2714/index.htm\n            \"✔ Fixed \", totalFixed, pluralize(\" problem\", totalFixed), \"\\n\"\n        ].join(\"\"));\n    }\n\n    if (errors > 0) {\n        output += chalk[summaryColor].bold([\n            // http://www.fileformat.info/info/unicode/char/2716/index.htm\n            \"✖ Remaining \", errors, pluralize(\" problem\", errors), \"\\n\"\n        ].join(\"\"));\n    }\n\n    return totalFixed > 0 ? output : \"\";\n};\n"]}