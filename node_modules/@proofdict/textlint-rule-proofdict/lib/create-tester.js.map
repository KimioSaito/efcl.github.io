{"version":3,"sources":["../src/create-tester.js"],"names":["require","ProofdictTester","currentTester","checkedLastTime","createTester","lastUpdated","dictionary","whitelistTags","blacklistTags","disableTesterCache","getDictionary","options","mode","proofdict","undefined","proofDictData","NETWORK","cachedProofdict","getItem","JSON","parse","error","removeItem","LOCAL"],"mappings":"AAAA;AACA;;;;;;;AACA;;AACA;;eAE4BA,QAAQ,mBAAR,C;IAApBC,e,YAAAA,e;;AACR,IAAIC,gBAAgB,IAApB;AACA,IAAIC,kBAAkB,CAAC,CAAvB;AACA;;;;;;;;AAQO,IAAMC,sCAAe,SAAfA,YAAe,OAAmF;AAAA,QAAhFC,WAAgF,QAAhFA,WAAgF;AAAA,QAAnEC,UAAmE,QAAnEA,UAAmE;AAAA,QAAvDC,aAAuD,QAAvDA,aAAuD;AAAA,QAAxCC,aAAwC,QAAxCA,aAAwC;AAAA,QAAzBC,kBAAyB,QAAzBA,kBAAyB;;AAC3G,QAAIA,sBAAuBP,kBAAkB,IAAlB,IAA0BC,kBAAkBE,WAAvE,EAAqF;AACjFF,0BAAkBE,WAAlB;AACAH,wBAAgB,IAAID,eAAJ,CAAoB;AAChCK,kCADgC;AAEhCC,wCAFgC;AAGhCC;AAHgC,SAApB,CAAhB;AAKA,eAAON,aAAP;AACH;AACD,WAAOA,aAAP;AACH,CAXM;;AAaP;;;;;AAKO,IAAMQ,wCAAgB,SAAhBA,aAAgB,CAACC,OAAD,EAAUC,IAAV,EAAmB;AAC5C;AACA,QAAID,QAAQE,SAAR,KAAsBC,SAA1B,EAAqC;AACjC,eAAOH,QAAQE,SAAf;AACH;AACD,QAAIE,sBAAJ;AACA;AACA,QAAIH,SAAS,WAAKI,OAAlB,EAA2B;AACvB,YAAI;AACA,gBAAMC,kBAAkB,2BAAQC,OAAR,CAAgB,WAAhB,CAAxB;AACAH,4BAAgBI,KAAKC,KAAL,CAAWH,eAAX,CAAhB;AACH,SAHD,CAGE,OAAOI,KAAP,EAAc;AACZ,uCAAQC,UAAR,CAAmB,WAAnB;AACH;AACJ;AACD;AACA,QAAIV,SAAS,WAAKW,KAAlB,EAAyB;AACrB;AACH;AACD,WAAOR,aAAP;AACH,CApBM","file":"create-tester.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nimport { MODE } from \"./mode\";\nimport { storage } from \"./dictionary-storage\";\n\nconst { ProofdictTester } = require(\"@proofdict/tester\");\nlet currentTester = null;\nlet checkedLastTime = -1;\n/**\n * @param {number} lastUpdated\n * @param {*} dictionary\n * @param {string[]} whitelistTags\n * @param {string[]}  blacklistTags\n * @param {boolean}  disableTesterCache\n * @returns {ProofdictTester}\n */\nexport const createTester = ({ lastUpdated, dictionary, whitelistTags, blacklistTags, disableTesterCache }) => {\n    if (disableTesterCache || (currentTester === null && checkedLastTime < lastUpdated)) {\n        checkedLastTime = lastUpdated;\n        currentTester = new ProofdictTester({\n            dictionary,\n            whitelistTags,\n            blacklistTags\n        });\n        return currentTester;\n    }\n    return currentTester;\n};\n\n/**\n * @param options\n * @param {string} mode\n * @returns {*}\n */\nexport const getDictionary = (options, mode) => {\n    // prefer `dictionary` option\n    if (options.proofdict !== undefined) {\n        return options.proofdict;\n    }\n    let proofDictData;\n    // NETWORK\n    if (mode === MODE.NETWORK) {\n        try {\n            const cachedProofdict = storage.getItem(\"proofdict\");\n            proofDictData = JSON.parse(cachedProofdict);\n        } catch (error) {\n            storage.removeItem(\"proofdict\");\n        }\n    }\n    // LOCAL\n    if (mode === MODE.LOCAL) {\n        // TODO: not implemented\n    }\n    return proofDictData;\n};\n"]}