// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var helper = new _textlintRuleHelper.RuleHelper(context);
    // 最低間隔値
    var minInterval = options.min_interval || defaultOptions.min_interval;
    var isStrict = options.strict || defaultOptions.strict;
    var Syntax = context.Syntax;
    var report = context.report;
    var getSource = context.getSource;
    var RuleError = context.RuleError;

    return _defineProperty({}, Syntax.Str, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var text = getSource(node);
        var sentences = (0, _sentenceSplitter2.default)(text).filter(function (node) {
            return node.type === _sentenceSplitter.Syntax.Sentence;
        });
        return (0, _kuromojin.getTokenizer)().then(function (tokenizer) {
            var checkSentence = function checkSentence(sentence) {
                var tokens = tokenizer.tokenizeForSentence(sentence.raw);
                var joshiTokens = tokens.filter(function (token) {
                    return token.pos === "助詞";
                });
                var joshiTokenSurfaceKeyMap = createSurfaceKeyMap(joshiTokens);
                /*
                # Data Structure
                     joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]
                    joshiTokenSurfaceKeyMap = {
                        "は": [tokenA, tokenC, tokenE],
                        "で": [tokenB, tokenD, tokenF]
                    }
                 */
                Object.keys(joshiTokenSurfaceKeyMap).forEach(function (key) {
                    var tokens = joshiTokenSurfaceKeyMap[key];
                    // strict mode ではない時例外を除去する
                    if (!isStrict) {
                        if (matchExceptionRule(tokens)) {
                            return;
                        }
                    }
                    if (tokens.length <= 1) {
                        return; // no duplicated token
                    }
                    // if found differenceIndex less than
                    tokens.reduce(function (prev, current) {
                        var startPosition = joshiTokens.indexOf(prev);
                        var otherPosition = joshiTokens.indexOf(current);
                        // if difference
                        var differenceIndex = otherPosition - startPosition;
                        if (differenceIndex <= minInterval) {
                            report(node, new RuleError("一文に二回以上利用されている助詞 \"" + key + "\" がみつかりました。", {
                                line: sentence.loc.start.line - 1,
                                // matchLastToken.word_position start with 1
                                // this is padding column start with 0 (== -1)
                                column: sentence.loc.start.column + (current.word_position - 1)
                            }));
                        }
                        return current;
                    });
                });
            };
            sentences.forEach(checkSentence);
        });
    });
};

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = require("sentence-splitter");

var _sentenceSplitter2 = _interopRequireDefault(_sentenceSplitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * create a object that
 * map ={
 *   // these token.surface_form === "Hoge"
 *  "Hoge" [token, token]
 * }
 * @param tokens
 * @returns {*}
 */
function createSurfaceKeyMap(tokens) {
    return tokens.reduce(function (keyMap, token) {
        // "は" : [token]
        if (!keyMap[token.surface_form]) {
            keyMap[token.surface_form] = [];
        }
        keyMap[token.surface_form].push(token);
        return keyMap;
    }, {});
}
function matchExceptionRule(tokens) {
    var token = tokens[0];
    if (token.pos_detail_1 === "連体化") {
        return true;
    }
    if (token.pos_detail_1 === "格助詞" && token.surface_form === "を") {
        return true;
    }
    return false;
}
var defaultOptions = {
    min_interval: 1,
    strict: false
};
;
//# sourceMappingURL=no-doubled-joshi.js.map