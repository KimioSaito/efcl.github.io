<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Web Scratch</title>
 <link href="http://efcl.info/feed/atom/" rel="self"/>
 <link href="http://efcl.info"/>
 <updated>2017-05-22T10:47:18+09:00</updated>
 <id>http://efcl.info/</id>
 
 <author>
   <name>azu</name>
   
 </author>
 

 
 <entry>
   <title>GitHubのリポジトリをDprecatedにするスクリプト</title>
   <link href="http://efcl.info/2017/05/22/move-github-repository/"/>
   <updated>2017-05-22T10:02:00+09:00</updated>
   <id>http://efcl.info/2017/05/22/move-github-repository</id>
   <content type="html"><![CDATA[ <p>GitHubのリポジトリを別の場所に移す場合、リポジトリまるごと移動できるなら<a href="https://help.github.com/articles/about-repository-transfers/" title="repository transfers">repository transfers</a>を利用するのが正解です。</p>

<p>しかし、既存のリポジトリをmonorepoの一部として取り込む場合はそのようなことができません。リポジトリの履歴は<a href="https://lernajs.io/" title="Lerna">Lerna</a>などでは<code>lerna import</code>で取り込むことができますが、既に作ったリポジトリからリダイレクトさせることができません。</p>

<p>既存のリポジトリを消してしまうと、既に貼ったリンクなどが404になるためあまり良くありませんし、そのままにしておくと紛らわしいです。</p>

<p>そのため、よく取られるのはリポジトリは空にしてDescriptionなどで移動したことを書いておく手法です。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/05/22-1495415248.png" alt="moved"></p>

<p>これをやる<a href="https://github.com/azu/move-github-repository" title="azu/move-github-repository: Move GitHub repository(Update description &amp;amp;&amp;amp; URL &amp;amp;&amp;amp; default branch).">move-github-repository</a>というツールを書きました。</p>

<h2 id="move-github-repository"><a href="https://github.com/azu/move-github-repository" title="azu/move-github-repository: Move GitHub repository(Update description &amp;amp;&amp;amp; URL &amp;amp;&amp;amp; default branch).">move-github-repository</a></h2>

<p><a href="https://github.com/azu/move-github-repository" title="azu/move-github-repository: Move GitHub repository(Update description &amp;amp;&amp;amp; URL &amp;amp;&amp;amp; default branch).">move-github-repository</a>は、コマンド一発で次のようなことをします。</p>

<ul>
<li>リポジトリのdescription &amp;&amp; homepageを更新する</li>
<li><code>301_moved_permanently</code>ブランチを作る

<ul>
<li>このブランチは移転してことを書いたREADME.mdのみがある</li>
</ul></li>
<li><code>301_moved_permanently</code>をデフォルトブランチにする</li>
</ul>

<p>これによって既存のブランチは維持されるので、リンクなどは切れません。</p>

<h2 id="インストール">インストール</h2>

<p>npmでインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install -g move-github-repository
</code></pre></div>
<p>GitHubのTokenと更新後に付けたいdescriptionとhomepageを引数に渡して実行できます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Usage
  $ GH_TOKEN=xxx move-github-repository --description &quot;[[MOVED]]&quot; --homepage http://example.com/new

Options
  --description -d Description repository
  --homepage -h    New URL

Env
  GH_TOKEN=xxx move-github-repository --description &quot;[[MOVED]]&quot; --homepage http://example.com/new

Examples
  $ GH_TOKEN=xxx move-github-repository --description &quot;[[MOVED]]&quot; --homepage http://example.com/new
</code></pre></div>
<h2 id="サンプル">サンプル</h2>

<p><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>をmonorepoに移動させていたので、実際に移動させたリポジトリなどは次のような感じです。</p>

<ul>
<li><a href="https://github.com/textlint/txt-to-ast" title="textlint/txt-to-ast: [CAUTION] This repository is MOVED to monorepo.">textlint/txt-to-ast: [CAUTION] This repository is MOVED to monorepo.</a></li>
<li><a href="https://github.com/textlint/textlint-plugin-text" title="textlint/textlint-plugin-text: [CAUTION] This repository is MOVED to monorepo.">textlint/textlint-plugin-text: [CAUTION] This repository is MOVED to monorepo.</a></li>
<li><a href="https://github.com/textlint/textlint-plugin-markdown" title="textlint/textlint-plugin-markdown: [CAUTION] This repository is MOVED to monorepo.">textlint/textlint-plugin-markdown: [CAUTION] This repository is MOVED to monorepo.</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>GitHubのラベルをいい感じにセットアップするツール</title>
   <link href="http://efcl.info/2017/05/17/github-label/"/>
   <updated>2017-05-17T10:23:00+09:00</updated>
   <id>http://efcl.info/2017/05/17/github-label</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/azu/github-label-setup" title="github-label-setup">github-label-setup</a>というGitHubリポジトリのラベルにいい感じのプリセットを追加する自分用のツールを書きました。</p>

<p>次のIssueに追加されるラベルが全部貼ってあります。</p>

<p><a href="https://github.com/azu/github-label-setup/issues/1"><img src="./img/demo.png" alt="demo"></a></p>

<h2 id="install">Install</h2>

<p>npmでインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install @azu/github-label-setup -g
</code></pre></div>
<h2 id="usage">Usage</h2>

<p>基本的にはデフォルトのプリセットがあるので、<code>--token</code>でGitHubのtokenを渡すだけで後は自動でやってくれます。</p>

<p>ラベルを設定したいプロジェクトのディレクトリに移動してコマンドを叩くだけです。
(git remoteのoriginを見ます)</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Usage
  $ github-label-setup --token xxx

Options

  -h, --help                  output usage information
  -l, --labels &lt;path&gt;         the path or npm packages name to look for the label configuration in. Default: labels.json
  --token &lt;token&gt;  a GitHub access token (also settable with a GITHUB_ACCESS_TOKEN environment variable)
  -d, --dry-run               calculate the required label changes but do not apply them
</code></pre></div>
<p>アクセストークンは<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>から <code>&quot;repo&quot;</code> scope が有効になったものがあれば良いです。</p>

<p><code>--dry-run</code>オプションを使えば、実際にどういう変更が行われるかを見れるのでまずはそちらで確認してください。</p>

<p>デフォルトのGitHubのラベルやよく使われる似た意味のラベルはマイグレーションしますが、リストにないラベルは単純に消えてしまうので注意が必要です。</p>

<ul>
<li><a href="https://github.com/azu/github-label-setup/blob/master/labels.json" title="github-label-setup/labels.json at master · azu/github-label-setup">github-label-setup/labels.json at master · azu/github-label-setup</a></li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">Fetching labels from GitHub
Changed: the &quot;duplicate&quot; label in the repo is out of date. It will be updated to &quot;duplicate&quot; with color &quot;#ededed&quot;.
Changed: the &quot;help wanted&quot; label in the repo is out of date. It will be updated to &quot;help wanted&quot; with color &quot;#e99695&quot;.
Missing: the &quot;good for beginner&quot; label is missing from the repo. It will be created.
Missing: the &quot;Priority: Critical&quot; label is missing from the repo. It will be created.
Missing: the &quot;Priority: High&quot; label is missing from the repo. It will be created.
Missing: the &quot;Priority: Low&quot; label is missing from the repo. It will be created.
Missing: the &quot;Priority: Medium&quot; label is missing from the repo. It will be created.
Changed: the &quot;invalid&quot; label in the repo is out of date. It will be updated to &quot;Status: Abandoned&quot; with color &quot;#000000&quot;.
Missing: the &quot;Status: Blocked&quot; label is missing from the repo. It will be created.
Missing: the &quot;Status: In Progress&quot; label is missing from the repo. It will be created.
Changed: the &quot;Idea&quot; label in the repo is out of date. It will be updated to &quot;Status: Proposal&quot; with color &quot;#d4c5f9&quot;.
Missing: the &quot;Status: Ready for PR&quot; label is missing from the repo. It will be created.
Missing: the &quot;Status: Review Needed&quot; label is missing from the repo. It will be created.
Changed: the &quot;breaking&quot; label in the repo is out of date. It will be updated to &quot;Type: Breaking Change&quot; with color &quot;#b60205&quot;.
Changed: the &quot;bug&quot; label in the repo is out of date. It will be updated to &quot;Type: Bug&quot; with color &quot;#ee0701&quot;.
Changed: the &quot;documents&quot; label in the repo is out of date. It will be updated to &quot;Type: Documentation&quot; with color &quot;#5319e7&quot;.
Changed: the &quot;enhancement&quot; label in the repo is out of date. It will be updated to &quot;Type: Feature&quot; with color &quot;#1d76db&quot;.
Missing: the &quot;Type: Refactoring&quot; label is missing from the repo. It will be created.
Changed: the &quot;greenkeeper&quot; label in the repo is out of date. It will be updated to &quot;Type: Maintenance&quot; with color &quot;#0e8a16&quot;.
Changed: the &quot;question&quot; label in the repo is out of date. It will be updated to &quot;Type: Question&quot; with color &quot;#cc317c&quot;.
Added: the &quot;example&quot; label in the repo is not expected. It will be deleted.
Added: the &quot;implementing&quot; label in the repo is not expected. It will be deleted.
Added: the &quot;Patch Welcome&quot; label in the repo is not expected. It will be deleted.
Added: the &quot;proposal&quot; label in the repo is not expected. It will be deleted.
Added: the &quot;wontfix&quot; label in the repo is not expected. It will be deleted.
This is a dry run. No changes have been made on GitHub
</code></pre></div>
<p>このツールは <code>github-label-sync</code> のラッパーなので、細かい部分はそちらをみてください。</p>

<ul>
<li><a href="https://github.com/Financial-Times/github-label-sync" title="Financial-Times/github-label-sync: Synchronise your GitHub labels with as few destructive operations as possible">Financial-Times/github-label-sync: Synchronise your GitHub labels with as few destructive operations as possible</a></li>
</ul>

<h3 id="npm-packages-for-labels">Npm packages for labels</h3>

<p><code>-l</code>オプションでラベルファイルを指定できますが、<code>require</code>できればなんでも通るので、npmパッケージを作っても多分通ります。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ github-label-setup --token xxx --labels @owner/github-label-presets
</code></pre></div>
<p>ラベルのフォーマットは<a href="https://github.com/Financial-Times/github-label-sync#label-json" title="Label JSON">Label JSON</a>をみてください。</p>

<h2 id="デフォルトのラベル">デフォルトのラベル</h2>

<p>最初に書いたように自分用のツールなので、ラベルのデフォルトは自分がよく使う感じのものになってます。</p>

<p><a href="https://github.com/azu/github-label-setup/issues/1"><img src="./img/demo.png" alt="demo"></a></p>

<ul>
<li>duplicate</li>
<li>help wanted</li>
<li>good for beginner

<ul>
<li><a href="https://github.com/MunGell/awesome-for-beginners" title="MunGell/awesome-for-beginners: A list of awesome beginners-friendly projects.">MunGell/awesome-for-beginners: A list of awesome beginners-friendly projects.</a>を参考に</li>
</ul></li>
<li>Priority: Critical</li>
<li>Priority: High</li>
<li>Priority: Low</li>
<li>Priority: Medium

<ul>
<li>優先度管理</li>
</ul></li>
<li>Status: Abandoned</li>
<li>Status: Blocked</li>
<li>Status: In Progress</li>
<li>Status: Proposal</li>
<li>Status: Ready for PR</li>
<li>Status: Review Needed

<ul>
<li>ステータス管理</li>
</ul></li>
<li>Type: Breaking Change</li>
<li>Type: Bug</li>
<li>Type: Feature</li>
<li>Type: Documentation</li>
<li>Type: Refactoring</li>
<li>Type: Maintenance

<ul>
<li>Related: <a href="https://conventionalcommits.org/" title="Conventional Commits">Conventional Commits</a></li>
<li>これはコミットのスコープに大分近いです。</li>
<li><a href="https://github.com/lerna/lerna-changelog" title="lerna-changelog">lerna-changelog</a>などラベルをCHANGELOGのソースに使うツールなどもあるのを考えて、コミットのスコープに合わせたセットを作っています</li>
</ul></li>
<li>Type: Question&quot;</li>
</ul>

<p>Typeに関してはプロジェクト特有のTypeが増えていくと思います。
このスクリプトはリポジトリを作った直後に動かす目的が大きいです。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">hub create &amp;&amp; github-label-setup --token XXXX
</code></pre></div>
<h2 id="関連">関連</h2>

<p>似たようなものは色々あるのでお気に入りを探してみてください。
<a href="https://github.com/Financial-Times/github-label-sync" title="github-label-sync">github-label-sync</a>をベースにしたのは既存のラベルをマイグレーションすることができるからです(紐付いていたIssueを保持できる)</p>

<ul>
<li><a href="https://github.com/yoshuawuyts/github-standard-labels" title="yoshuawuyts/github-standard-labels: Create a standard set of issue labels for a GitHub project">yoshuawuyts/github-standard-labels: Create a standard set of issue labels for a GitHub project</a></li>
<li><a href="https://github.com/Financial-Times/github-label-sync" title="Financial-Times/github-label-sync: Synchronise your GitHub labels with as few destructive operations as possible">Financial-Times/github-label-sync: Synchronise your GitHub labels with as few destructive operations as possible</a></li>
<li><a href="https://github.com/MunGell/awesome-for-beginners" title="MunGell/awesome-for-beginners: A list of awesome beginners-friendly projects.">MunGell/awesome-for-beginners: A list of awesome beginners-friendly projects.</a></li>
<li><a href="https://github.com/himynameisdave/git-labelmaker" title="himynameisdave/git-labelmaker: Manage your GitHub labels from the command line!">himynameisdave/git-labelmaker: Manage your GitHub labels from the command line!</a></li>
<li><a href="https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63" title="Sane GitHub Labels – Dave Lunny – Medium">Sane GitHub Labels – Dave Lunny – Medium</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>textlintのElectronアプリを作った</title>
   <link href="http://efcl.info/2017/05/12/textlint-app/"/>
   <updated>2017-05-12T19:36:00+09:00</updated>
   <id>http://efcl.info/2017/05/12/textlint-app</id>
   <content type="html"><![CDATA[ <h1 id="textlint-app">textlint-app</h1>

<p><a href="https://github.com/textlint/textlint-app" title="textlint-app">textlint-app</a>という、インストールするだけで動くtextlintのElectronアプリを作成しました。</p>

<p><a href="https://github.com/textlint/textlint-app"><img src="https://media.giphy.com/media/3o7buj7KnuEurvGVm8/giphy.gif" alt="gif"></a></p>

<h2 id="インストール方法">インストール方法</h2>

<ul>
<li><a href="https://github.com/textlint/textlint-app/releases/latest">https://github.com/textlint/textlint-app/releases/latest</a> からバイナリをダウンロード</li>
</ul>

<p>ダウンロードしたインストーラー（Windows）、<code>app</code>（Mac）を実行すれば動きます。（Node.jsの環境なども不要です）
実行する際に署名されてないバイナリなので警告がでるので、その辺は許可しないと動きません。</p>

<ul>
<li>Windows: インストーラーで許可を選択する必要がある</li>
<li>Mac: <code>/Application/textlint.app</code> をコンテキストメニューから&quot;開く&quot;をして許可する必要がある</li>
</ul>

<h2 id="特徴">特徴</h2>

<p>一番の特徴はNode.jsなどの環境を作る必要なくインストールするだけで動く点です。
<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>はNode.js（一応ブラウザも動く）で動くツールです。
しかし、Node.jsのセットアップに慣れてない人には大変そうなので作成しました。</p>

<p>内部的にはElectronアプリで、Node.jsとnpmを同梱しています。
また<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールもアプリ上でインストールして動かします。</p>

<p>利用できるルールはNode.jsのCLI版と全く同じ、設定ファイルの<code>.textlintrc</code>も同じです。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule" title="Collection of textlint rule · textlint/textlint Wiki">Collection of textlint rule · textlint/textlint Wiki</a></li>
</ul>

<p>簡単にまとめると次のようなアプリです。</p>

<ul>
<li>Node.js環境がなくても動く<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>同梱のエディタ</li>
<li><code>.textlintrc</code>をそのままコピペすれば動く</li>
<li><code>textlint --fix</code>を使った自動修正に対応</li>
<li>Markdownファイルを読み書きできる</li>
</ul>

<h2 id="使い方">使い方</h2>

<p>アプリを開くとエディタ画面が出てきます。
最初はtextlintのルールが一切入っていない状態なので、ルールをインストールする必要があります。</p>

<ul>
<li><strong>1.</strong> &quot;Settings&quot;のタブを開く:</li>
</ul>

<p><img src="http://efcl.info/wp-content/uploads/2017/05/12-1494586278.png" alt="Step 1"></p>

<ul>
<li><strong>2.</strong> <code>.textlintrc</code>の設定を書く</li>
</ul>

<p><img src="http://efcl.info/wp-content/uploads/2017/05/12-1494586443.png" alt="Step 2"></p>

<p>次のような設定を<code>.textlintrc</code>へコピペします。</p>

<p><strong>例</strong>: <a href="https://github.com/textlint-ja/textlint-rule-preset-ja-technical-writing" title="textlint-ja/textlint-rule-preset-ja-technical-writing: 技術文書向けのtextlintルールプリセット">textlint-ja/textlint-rule-preset-ja-technical-writing: 技術文書向けのtextlintルールプリセット</a>を使う設定</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;preset-ja-technical-writing&quot;</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>3.</strong>: &quot;Install&quot;ボタンを押して完了する待つ</li>
</ul>

<p>&quot;Install&quot;ボタンを押すと内蔵しているnpm（パッケージマネージャ）を使ってルールをダウンロードしてきます。</p>

<p>（ダウンロードしたルールや<code>package.json</code>、<code>.textlintrc</code>は &quot;Working directory&quot; に自動的に配置されるので、CLI版でもそこを参照すれば共有できます）</p>

<ul>
<li><strong>4.</strong> &quot;Edit with textlint&quot;でテキストを書く</li>
</ul>

<p>現状はMarkdownしかサポートしてませんが、エディタ部分に書いていくとリアルタイムで先ほどインストールしたルールでチェックされます。</p>

<ul>
<li><a href="https://github.com/textlint/textlint-app/issues/8" title="Support html/rst/re:view · Issue #8 · textlint/textlint-app">Support html/rst/re:view · Issue #8 · textlint/textlint-app</a></li>
</ul>

<p><img src="http://efcl.info/wp-content/uploads/2017/05/12-1494586618.png" alt="Screenshot"></p>

<p>また&quot;Fix all errors&quot;ボタンを押すことで、修正可能なエラーは自動的に修正できます。</p>

<h2 id="おわりに">おわりに</h2>

<p><a href="https://github.com/textlint/textlint-app" title="textlint/textlint-app: textlint standalone application top on Electron.">textlint/textlint-app</a>はまだ開発段階の状態です。</p>

<p>目的としてNode.jsを普段使ってない人がてっとり早くtextlintを使えるようにすることです。
また、<code>.textlintrc</code>の設定ファイルはCLIやアプリで共有できるので、コピペして使い始めることができる所にフォーカスしています。
(この設定コピペすればとりあえずいい感じにチェックできるよみたいな）</p>

<p><a href="https://github.com/textlint/textlint-app#development">https://github.com/textlint/textlint-app#development</a>にローカルでの開発方法についてドキュメントが書いてあります。
デザインがまだまだだったり、目的に反してそこまで優しい感じではないのでその辺へのコントリビュートまってます。
（CodeMirrorのパフォーマンスとかガタガタする問題をどうにかしたいです…）</p>

<ul>
<li><a href="https://github.com/textlint/textlint-app/issues" title="Issues · textlint/textlint-app">Issues · textlint/textlint-app</a></li>
</ul>

<h2 id="おまけ">おまけ</h2>

<p>この記事を書いているときの<code>.textlintrc</code>の設定は次のようなものでした。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&quot;filters&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;comments&quot;</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span>
  <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;ja-no-redundant-expression&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;period-in-list-item&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;periodMark&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
    <span class="p">},</span>
    <span class="nt">&quot;preset-ja-technical-writing&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;no-exclamation-question-mark&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;allowFullWidthQuestion&quot;</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">},</span>
      <span class="nt">&quot;max-kanji-continuous-len&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;max&quot;</span><span class="p">:</span> <span class="mi">6</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> ]]></content>
 </entry>
 
 <entry>
   <title>Living Documentation by design, with Domain-Driven Designを読んだ</title>
   <link href="http://efcl.info/2017/05/12/Living-Documentation-DDD/"/>
   <updated>2017-05-12T09:55:00+09:00</updated>
   <id>http://efcl.info/2017/05/12/Living-Documentation-DDD</id>
   <content type="html"><![CDATA[ <p><a href="https://leanpub.com/livingdocumentation" title="Living Documentation by… by Cyrille Martraire [PDF/iPad/Kindle]">Living Documentation by design, with Domain-Driven Design by Cyrille Martraire [PDF/iPad/Kindle]</a>という電子書籍を読んだ。</p>

<p>leanpubで$0から購入できて、任意の値段で購入できるドキュメンテーションとDDDについての書籍。</p>

<p>ドキュメンテーションもソフトウェア開発のように設計やテストといったパターンやアプローチがあります。
これは以前書いた技術文書をソフトウェア開発する話と似ているところがあります。</p>

<ul>
<li><a href="https://azu.gitbooks.io/nodefest-technical-writing/" title="Introduction | 技術文書をソフトウェア開発する話">Introduction | 技術文書をソフトウェア開発する話</a></li>
</ul>

<p>ドキュメントに書かれる知識としてGenericなものとSpecificなものがあります。
ドキュメントもソフトウェアと同じように更新され続けるべきですが、
会社やチーム、プロダクトにおけるSpecificな知識には次のような問題が生まれやすいです。</p>

<ul>
<li>アクセスできない</li>
<li>古すぎる</li>
<li>フラグメント化してる</li>
<li>暗黙的になってる</li>
<li>理解できない</li>
<li>書かれてない</li>
</ul>

<p>要はドキュメントはコストがかかるので、更新されなくなって管理されなくなる。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">知識は会話から生まれ、知識がstableとなるには時間がかかる。<br>これは、その知識を記述したドキュメントにはメンテナンスコストが掛かることを示唆してる。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/840907540586102785">March 12, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>一番良いドキュメントはNo Documentationであることではあるが、これらのドキュメントをどうやって更新され続けるようにするかという戦略、パターン、仕組みなどについて書かれている書籍です。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> 良いドキュメンテーションのアプローチは設計が関わる。<br>急速に変化するプロジェクトに対するドキュメンテーションには設計的なアプローチが必要になる <a href="https://t.co/EPBf6yldDs">pic.twitter.com/EPBf6yldDs</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/840915700575215616">March 12, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="livingdocumentationのコア原則">LivingDocumentationのコア原則</h2>

<ul>
<li>Reliable

<ul>
<li>信頼性の高いドキュメントを作る2つの方法</li>
<li>single source of truth

<ul>
<li>ソースは一つにする</li>
</ul></li>
<li>reconciliation mechanism

<ul>
<li>ソースが複数の場所にあることを認め、それをテストする</li>
<li>Specifiction by Example</li>
</ul></li>
</ul></li>
<li>Low-Effort</li>
<li>Collaborative

<ul>
<li>Conversations over Documentations</li>
<li>ペアプロは強い</li>
<li>アクセスできる場所に知識は置く</li>
</ul></li>
<li>Insightful

<ul>
<li>意図を残す</li>
</ul></li>
</ul>

<h2 id="メモ">メモ</h2>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">憶測をドキュメント化しない<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> では逐次的にドキュメントを作っていく。<br>そのため実際のニーズに基づくドキュメンテーションを行う。</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/840944746684067841">March 12, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">多すぎる情報は、情報が全くないのと同じぐらい役に立たない。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/840946011761647616">March 12, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">実装のドキュメントはよく変わるため別のアプローチを用意すべき。<br>戦略のドキュメントは複数のプロジェクト間で共有できるStableなドキュメントすべき。<br>そのためにプロジェクト特有の細部、変更されやすい所は戦略のドキュメントからは省略する。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/842031191368769537">March 15, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>この辺は読んでいて、<a href="https://www.amazon.co.jp/dp/B01MQG41Y0/" title="関数型プログラミングの基礎">関数型プログラミングの基礎</a>も最近読んだのもあって、ドキュメントとプログラミングの次のような対比が浮かんだ。</p>

<p>戦略というドキュメンテーションは、複数のプロジェクトで共有して参照できるStableなものであるべきで、逆にプロジェクト特有のものは変更の可能性が高いので、戦略からの参照はしない。</p>

<ul>
<li>OK: Unstable -&gt; Stable</li>
<li>NG: Stable -&gt; Unstable</li>
</ul>

<p>プログラミングにおいて、副作用を持つ部分と副作用を持たない部分をきちんと分離する。
副作用のあるものから純粋なものを参照するが、逆はしない(純粋なものが副作用を持って本末転倒)</p>

<ul>
<li>OK: 副作用を持つ関数 -&gt; 純粋な関数</li>
<li>NG: 純粋な関数 -&gt; 副作用を持つ関数</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">URLはKnowledge Networkの一部である。<br>URLでリンクすることは知識を伝達するの有用。<br>壊れたリンクを回避するためのメカニズムも必要。<br>参照をするときは、揮発性の高いもの -&gt; 安定したものとなるようにリンクをする。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/842035348204994560">March 15, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>これ読んでいて一番面白かった話。
よくよく考えると当たり前だけど、文章からソースコードへリンクを貼るとすぐ壊れてしまうので、ソースコードから文章へリンクを貼ったほうが安定するという話。</p>

<p>ソースコードへリンクする際に間接的な方法があるという話も何か面白かった。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> ファイルへ直接リンクするんじゃなくて、検索キーワードへ間接的にリンクするという話。 <a href="https://t.co/Vo4P3Q0xBi">pic.twitter.com/Vo4P3Q0xBi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/842036645029322753">March 15, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> ドメイン学び方<br>- 調査結果を壁にはりつけるようにまとめる<br>- チームについてトレーニングを受ける<br>- 他の開発者がやってることを半日ぐらい観察する Live-my-Life Sessions<br>- そのプロダクトのユーザーの行動を見てみる</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843813350660173824">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a><br>これのペアプロ、クロスプログラミング、モブプログラミングのような形は、継続的なドキュメンテーションに役立つ。<br>ならならFace to Faceでインタラクティブに進む得ることで、お互いの知識を共有でき、<br>疑問点をすぐに質問することができる</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843818057076097024">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> Working collectivelyはトラック係数(Truck Factor)の改善にも役立つ。<br><br>単一障害点を避け、情報の集中度を分散できる。</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843818978225012736">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">小さなTruck Factorはそのプロジェクトのヒーローであり、<br>他のチームメイトと共有されていない多くの知識があることを意味している。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843819605499895808">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>ドメイン知識の共有の仕方と単一障害点の話。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a><br>現実的な例の話として、<br>コードスタイルのLintツールとLint結果の参考文献としてのガイドラインのドキュメントがベストな関係。<br>ユーザーは必要となるまでそのドキュメントを読まずにすみ、必要なタイミングはLintツールが教えてくれる。</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843829013319639040">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>これは読んでいてESLintとかのドキュメントを思い浮かべた。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ガイドラインの&quot;強制&quot;と&quot;推奨&quot;どっちをとるか。<br>新しく追加されたコードに対しては強制的にエラーとし、<br>既存のコードベースは、そのガイドラインを違反していることが多いため、警告に留める。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843829944270516225">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> ガイドラインを決めたとしても、そのルールは既存のLintツールではカバーできないことがある。<br>このときに、コード自体を文書化することでできるかもという話。 annotationある言語は便利だなー <a href="https://t.co/6DHksjYiGl">pic.twitter.com/6DHksjYiGl</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843832241063047168">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>ガイドラインに向かって少しづつに移行する方法</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">例外はあるが、トラブルシューティングはShameful Documentationの一種とも言える。<br>そこに書かれているものは、つまり解決されていない問題で修正されていないことを意味してる。<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843834095599673344">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">問題を解決するためにトラブルシューティングのようなドキュメントを追加するよりも、その問題を直すために時間を使うべきであるという話<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/843834201291931650">March 20, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>なんでもかんでもトラブルシューティングに逃げてはいけないという話。</p>

<p><strong>ADR(Architecture Decision Records)</strong></p>

<p>重要なアーキテクチャの意思決定のプロセスを記録するフォーマットであるADRというやつがあるのを読んでて初めて知った。</p>

<ul>
<li><a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions" title="Blog | Documenting Architecture Decisions | Relevance">Blog | Documenting Architecture Decisions | Relevance</a></li>
<li><a href="http://tbpgr.hatenablog.com/entry/2017/02/22/080000" title="アーキテクチャの意思決定を記録する Lightweight Architecture Decision Records について - Tbpgr Blog">アーキテクチャの意思決定を記録する Lightweight Architecture Decision Records について - Tbpgr Blog</a></li>
</ul>

<p><a href="https://github.com/rwaldron/tc39-notes" title="ECMA, TC39 Meeting Notes">ECMA, TC39 Meeting Notes</a>とかもこれと似たようなフォーマットになっていて、自分がミーティングノートを書いたときも真似ていたので面白かった。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer/tree/master/meetings" title="js-primer/meetings at master · asciidwango/js-primer">js-primer/meetings at master · asciidwango/js-primer</a></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">実際の問題の小さな模型でシミュレートする。<br>頭で理解できる(複雑さの)サイズにし、シミュレートすることで、<br>後の議論において具体的に参照できるコードが作れる。<br>これがコミュニケーションツールとして役に立つ<a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> <a href="https://t.co/GvFG2hZGKy">pic.twitter.com/GvFG2hZGKy</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/861242247991271424">May 7, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/LivingDocumentation?src=hash">#LivingDocumentation</a> を取り入れるときは、セオリーの話をするんじゃなくて、シンプルな話として始める <a href="https://t.co/sG523au8O9">pic.twitter.com/sG523au8O9</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/861243980570177539">May 7, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>実践する時のやり方。</p>

<hr>

<p><a href="https://leanpub.com/livingdocumentation" title="Living Documentation by… by Cyrille Martraire [PDF/iPad/Kindle]">Living Documentation by design, with Domain-Driven Design by Cyrille Martraire [PDF/iPad/Kindle]</a> 400-500ページぐらいあって長かったけど読んでいて面白い話が多かったので良かった。
感覚的なものが結構文章化されてので面白い。</p>

<p>一応DDDの本ではあるので、DDDについては簡単に知っておくと読みやすいかも(コード的な話はあんまりないので、概念だけでもよさそう)</p>

<ul>
<li><a href="https://booth.pm/ja/items/392260" title="わかる！ドメイン駆動設計 ～もちこちゃんの大冒険～【C91新刊】 - TechBooster - BOOTH">わかる！ドメイン駆動設計 ～もちこちゃんの大冒険～【C91新刊】 - TechBooster - BOOTH</a></li>
</ul>

<p>あたりを見ておけば大体概念としての事前知識は大丈夫そうな気がする。
後は、IA(情報設計)的なことが好きな人は読むといいのかもしれない。</p>

<ul>
<li><a href="https://www.amazon.co.jp/dp/4802510012/" title="今日からはじめる情報設計 -センスメイキングするための7ステップ | アビー・コバート, 長谷川敦士, 安藤 幸央 |本 | 通販 | Amazon">今日からはじめる情報設計 -センスメイキングするための7ステップ | アビー・コバート, 長谷川敦士, 安藤 幸央 |本 | 通販 | Amazon</a></li>
<li><a href="http://efcl.info/2016/09/30/architecture-refs/" title="アーキテクチャをめぐるたび | Web Scratch">アーキテクチャをめぐるたび | Web Scratch</a></li>
</ul>

<p>実際のコードからドキュメントを同期するアプローチはアノテーション前提がちょっと強いので簡単には実践できない気はするけど、話として読むといいかなーと思った。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>Almin 0.12リリース: Read層におけるState更新のアプローチ</title>
   <link href="http://efcl.info/2017/05/11/almin-0.12/"/>
   <updated>2017-05-11T15:22:00+09:00</updated>
   <id>http://efcl.info/2017/05/11/almin-0.12</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/almin/almin" title="Almin">Almin</a> 0.12をリリースしました。</p>

<ul>
<li><a href="https://github.com/almin/almin/releases/tag/almin%400.12.3" title="Release Almin 0.12 · almin/almin">Release Almin 0.12 · almin/almin</a></li>
</ul>

<p><code>Store</code>と<code>StoreGroup</code>が書き直されたので色々変わっていますが、マイグレーションツールでアップデートできます。</p>

<h2 id="変更点">変更点</h2>

<h3 id="storegroupを書き直した"><code>StoreGroup</code>を書き直した</h3>

<p><strong>Before</strong>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="nx">a</span> <span class="o">:</span> <span class="s2">&quot;a value&quot;</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">BStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="nx">b</span> <span class="o">:</span> <span class="s2">&quot;b value&quot;</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">aStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">bStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">(</span>
    <span class="nx">aStore</span><span class="p">,</span>
    <span class="nx">bStore</span>
<span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">storeGroup</span><span class="p">.</span><span class="nx">getState</span><span class="p">());</span>
<span class="c1">// { a: &quot;a value&quot;, b: &quot;b value&quot; }</span>
</code></pre></div>
<p><strong>After</strong>:</p>

<p>Almin 0.12 では次のように<code>StoreGroup</code>のコンストラクタに</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">{</span>
 <span class="s2">&quot;ステート名&quot;</span><span class="o">:</span> <span class="nx">store</span>
<span class="p">}</span>
</code></pre></div>
<p>という組み合わせで定義を渡すようになりました。
代わりに<code>Store#getState</code>でステート名を返さなくても良くなっています。</p>

<p>Reduxの<a href="http://redux.js.org/docs/api/combineReducers.html" title="combineReducers · Redux">combineReducers</a>と似たような感じです(変更してから似てるのに気づいた)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&quot;a value&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">BStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&quot;b value&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">aStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">bStore</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BStore</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">({</span>
    <span class="c1">// stateName: store</span>
    <span class="nx">a</span><span class="o">:</span> <span class="nx">aStore</span><span class="p">,</span>
    <span class="nx">b</span><span class="o">:</span> <span class="nx">bStore</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">storeGroup</span><span class="p">.</span><span class="nx">getState</span><span class="p">());</span>
<span class="c1">// { a: &quot;a value&quot;, b: &quot;b value&quot; }</span>
</code></pre></div>
<p>古い<code>StoreGroup</code>の実装を使いたい場合は<a href="https://github.com/almin/legacy-store-group" title="legacy-store-group">legacy-store-group</a>にあるのでモジュールとして利用できます。</p>

<p>この変更の主な目的は次の2つです。</p>

<ul>
<li><code>Store#getState</code>を単純にStateを返すように</li>
<li>型の整合がとれたStoreGroup</li>
</ul>

<p>次のように<code>context.getState()</code>した結果が、最初にコンストラクタで渡した<code>Store</code>と<code>State</code>の関係でマッピングされて自動的に型付けされたstateのオブジェクトを返すようになっています。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="c1">// Store &lt;-&gt; Stateの関係を定義</span>
<span class="kr">interface</span> <span class="nx">AState</span> <span class="p">{</span>
    <span class="nx">a</span>: <span class="kt">number</span>
<span class="p">}</span>
<span class="kr">class</span> <span class="nx">AStore</span> <span class="kr">extends</span> <span class="nx">Store</span><span class="o">&lt;</span><span class="nx">AState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">state</span>: <span class="kt">AState</span><span class="p">;</span>
    <span class="c1">// ..</span>
    <span class="nx">getState() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// StoreGroup</span>
<span class="kr">const</span> <span class="nx">storeGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">({</span>
    <span class="nx">aState</span>: <span class="kt">new</span> <span class="nx">AStore</span><span class="p">()</span>
<span class="p">});</span>
<span class="c1">// Context</span>
<span class="kr">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Context</span><span class="p">({</span>
    <span class="nx">dispatcher</span><span class="p">,</span>
    <span class="nx">store</span>: <span class="kt">storeGroup</span>
<span class="p">});</span>
<span class="c1">// get state</span>
<span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">getState</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">unknown</span><span class="p">);</span> <span class="c1">// &lt;= 知らないstateを参照してる</span>
</code></pre></div>
<p><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494484857.png" alt="storegroup"></p>

<p>ちゃんとTypeScriptでコンパイルエラーになる。</p>

<h3 id="store-receivepayload-payload-payload-の追加"><code>Store#receivePayload(payload: Payload)</code>の追加</h3>

<p>Storeに<code>receivePayload(payload: Payload)</code>というメソッドを実装するとAlminのライフサイクルにおいて、それが呼びされるようになりました。
Reactの<code>componentWillReceiveProps(nextProps)</code>と役割が似ています。</p>

<p>これを導入した経緯は以下のIssueにも書いているのですが、<a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">クライアントサイドでCQRSをちゃんとやろう</a>としたのがAlminの開発目的の一つなので、その目的を再確認した結果として生まれました。</p>

<ul>
<li><a href="https://github.com/almin/almin/pull/160" title="feat(Store): add Store#receivePayload(payload: Payload) by azu · Pull Request #160 · almin/almin">feat(Store): add Store#receivePayload(payload: Payload) by azu · Pull Request #160 · almin/almin</a></li>
</ul>

<p>Alminの最初の目的として、writeとreadの掛け算の複雑さを一つのモデルに持たせるのはやめようというところから始まっています。
1つのモデルですべてをやるのではなく、writeとreadの2つのモデルに分けることでこの複雑さの掛け算をなくす目的です。</p>

<hr>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a>より</p>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494485424.png" alt="slide 1"></a></p>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494485454.png" alt="slide 2"></a></p>

<hr>

<p>この考え方で、Domain(いわゆるロジックを持つモデル/Write model)とStore(ViewModelのようなViewのためのモデル/Read Model)の2種類にわけることで、ビジネスロジックはDomainに集中することができました。
またViewはどのようなUIを目指すかによって、色々な細かいStateがでてきます。</p>

<p>しかし、Viewを意識したコードはStore/Stateで吸収できるので、Domain modelが変にUIを意識して書くケースをかなり減らせていたと思います。</p>

<p>先ほどのスライドでいうと、DomainはWrite層で、StoreはRead層という分離ができていました。</p>

<p>しかし、書いていくとStore側はRead層であるにもかかわらず、次のような書き込む処理が出てきています。(<code>this.onDispatch</code>でイベントを受け取って、<code>Store</code>が保持する<code>state</code>を更新する処理)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">CounterState</span> <span class="nx">from</span> <span class="s2">&quot;./CounterState&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CounterStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">();</span>
        <span class="c1">// initial state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CounterState</span><span class="p">({</span>
            <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">});</span>
        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// return own state</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このRead層にも書き込み処理があるのが気持ち悪いなーと思いました。
しかし、Write層で作ったものをRead層に渡す方法(タイミング)がないとViewに反映されないので、Read層のどこかでStateを更新する必要があるのは明白です。</p>

<p>これについて考えていて、<a href="https://msdn.microsoft.com/en-us/library/jj554200.aspx" title="CQRS Journey">CQRS Journey</a>というCQRSについて書かれた文書中に次のような図がでてきます。</p>

<p><img src="https://msdn.microsoft.com/en-us/library/jj591579.2c44f48caf131a5a65fcb0799a3ad4e7(l=en-us).png" alt="image"></p>

<p>この図では<code>OrderViewModelGenerator</code>というRead層にあるものが、Read層のRepositoryにデータを書き込んでいる様子が見えます。
(Write modelからドメインイベントを受け取り、それを<code>OrderViewModelGenerator</code>がRead modelに変換して保存するという流れ)</p>

<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/jj591579" title="Journey 4: Extending and Enhancing the Orders and Registrations Bounded Context">Journey 4: Extending and Enhancing the Orders and Registrations Bounded Context</a></li>
</ul>

<p>Almin 0.11まではこの<code>OrderViewModelGenerator</code>にあたるような、Read層のデータを更新する要素が明示的には存在していませんでした。
そのため、次のようにRead層でWrite層からくるイベントを受け取って更新するという処理を各Storeに書いたりしていました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
</code></pre></div>
<p>この「Write層からくるイベントを受け取り、Read層を更新する」を明示的なStoreのライフサイクルとして取り入れようとしてできたのが、<code>Store#receivePayload(payload: Payload)</code>です。</p>

<p><code>Store#receivePayload(payload: Payload)</code>はWrite層からイベント発火やAlminのライフサイクルで呼び出されるため、先ほどのコードは次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"> import { Store } from &quot;almin&quot;;
 import CounterState from &quot;./CounterState&quot;;
 export class CounterStore extends Store {
     constructor() {
         super();
         // initial state
         this.state = new CounterState({
             count: 0
         });
<span class="gd">-        // receive event from UseCase, then update state</span>
<span class="gd">-        this.onDispatch(payload =&gt; {</span>
<span class="gd">-            const newState = this.state.reduce(payload);</span>
<span class="gd">-            if (newState !== this.state) {</span>
<span class="gd">-                this.state = newState;</span>
<span class="gd">-                this.emitChange();</span>
<span class="gd">-            }</span>
<span class="gd">-        });</span>
     }

<span class="gi">+    // receive event from UseCase, then update state</span>
<span class="gi">+    receivePayload(payload) {</span>
<span class="gi">+        this.setState(this.state.reduce(payload));</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    // return own state</span>
     getState() {
        return this.state;
     }
 }
</code></pre></div>
<p>単純に言えば、Storeのstateを更新する処理は<code>receivePayload</code>に書けばいいという形です。
(Reactで<code>componentWillReceiveProps(nextProps)</code>の中で<code>setState</code>が許可されているのと同じです)</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff">import { Store } from &quot;almin&quot;;
import CounterState from &quot;./CounterState&quot;;
export class CounterStore extends Store {
    constructor() {
        super();
        // initial state
        this.state = new CounterState({
            count: 0
        });
    }

    // receive event from UseCase, then update state
    receivePayload(payload) {
        this.setState(this.state.reduce(payload));
    }

    // return own state
    getState() {
        return this.state;
    }
}
</code></pre></div>
<p>Almin 0.12でも今までのように自分でイベントを監視して更新する方法も動きます。
しかし、<code>Store#receivePayload(payload: Payload)</code>を使ったほうが将来的な最適化の余地が生まれるのでこちらを推奨しています。
(簡単にいうと、自分で監視したイベントと違い<code>Store#receivePayload(payload: Payload)</code>はAlminのライフサイクル管理下にあるので、うまいこと処理をできる可能性があるということ)</p>

<p>次のTodoMVCのサンプルでもその説明をしています。</p>

<ul>
<li><a href="https://almin.js.org/docs/tutorial/todomvc/" title="Todo App · Almin.js">Todo App · Almin.js</a></li>
</ul>

<h3 id="read側のstate更新アプローチ">Read側のState更新アプローチ</h3>

<p>(次の前提の)Read側のState更新処理のアプローチ多く分けて2つあると思います。</p>

<p>前提として、Read側のStateというのはWrite側のドメインモデルやデータベースをソースにして、View向けのデータしたものという扱いです(つまりWrite -&gt; Readという順序と関係がある)</p>

<p>そのため、Read側のStateは元となるソースから計算した値を持つComputed propertyのような形になってます。</p>

<p>Mobxの<a href="https://github.com/mobxjs/mobx-state-tree" title="mobx-state-tree">mobx-state-tree</a>というライブラリについて紹介してる<a href="https://immer-mutable-state.surge.sh/#1" title="The Quest For Immer Mutable State Management">The Quest For Immer Mutable State Management</a>というスライドは、その2つの方法についてわかりやすく書かれています。</p>

<p><strong>Pull Based: Recompute every time value is needede</strong></p>

<p>簡単に言えばgetterです。
そのプロパティの値を取得するときに、計算して返すという形です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nx">firstName</span> <span class="o">=</span> <span class="s2">&quot;Michel&quot;</span>
    <span class="nx">lastName</span> <span class="o">=</span> <span class="s2">&quot;Weststrate&quot;</span>
    <span class="nx">get</span> <span class="nx">fullName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;calculating!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Push Based: Recompute when a source value changes</strong></p>

<p>もう一つは、ソースとなる値が変化した時に事前に計算結果を作って置くという方法です。
簡単に言えばキャッシュを事前に作っておくイメージです。</p>

<p>この場合は<code>lastName</code>か<code>firstName</code>の値が変化した時に<code>fullName</code>というプロパティを計算して更新するということです。
<code>person.fullName</code>へアクセスした時はその結果を返すだけです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="err">@</span><span class="nx">observable</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="s2">&quot;Michel&quot;</span>
    <span class="err">@</span><span class="nx">observable</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="s2">&quot;Weststrate&quot;</span>
    <span class="err">@</span><span class="nx">computed</span> <span class="nx">get</span> <span class="nx">fullName</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;calculating!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このPullとPushの方法 どちらがいいのかはケースバイケースで、プロパティの値を読む回数が多いなら、事前に計算結果が作れる<strong>Push Based: Recompute when a source value changes</strong>の方がコストが低くなるかもしれません。
逆に、書き込む回数の方が圧倒的に多いなら、<strong>Pull Based: Recompute every time value is needede</strong>で実際に読むこむときに遅延評価的に結果を作って返したほうがコストが低いです。
(両方合わせるとかも考えられます)</p>

<p>話を戻して、先ほどのAlminのコードはソースの変更があったことを元に書き込んでいるのでPush Basedなやり方と言えます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">CounterState</span> <span class="nx">from</span> <span class="s2">&quot;./CounterState&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CounterStore</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">();</span>
        <span class="c1">// initial state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CounterState</span><span class="p">({</span>
            <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
        <span class="p">});</span>
        <span class="c1">// receive event from UseCase, then update state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">onDispatch</span><span class="p">(</span><span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// return own state</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>しかし、先ほども書いたように自分でイベントを監視(<code>this.onDispatch</code>)だと、そのStoreがPush Basedで更新する処理があるかが外から(この場合はStoreGroupから)はわかりません。
イベントを監視 !== 更新処理がある ではないからです。</p>

<p><code>receivePayload</code>を実装している == 更新処理がある という形になります。(必ずも更新されるわけではないですが、更新を期待していい形になる)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js">    <span class="c1">// receive event from UseCase, then update state</span>
    <span class="nx">receivePayload</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">payload</span><span class="p">));</span>
    <span class="p">}</span>
</code></pre></div>
<p>このようなインターフェースが決まると何が嬉しいかというと、次のようなReduxのreducerみたいなインターフェースでStoreを書けるようにしようといったことがやりやすくなります。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Store</span><span class="p">,</span> <span class="nx">Payload</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">State</span> <span class="p">{</span>
    <span class="nx">reduce</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">State</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="o">|</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Reactor</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">State</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">Store</span> <span class="p">{</span>
    <span class="kr">abstract</span> <span class="nx">state</span>: <span class="kt">T</span><span class="p">;</span>
    <span class="kr">abstract</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">prevState</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>

    <span class="nx">receivePayload</span><span class="p">(</span><span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">newState</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span> <span class="nx">reduce</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">shouldStateUpdate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">newState</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">getState() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// The user implement this</span>
<span class="kr">class</span> <span class="nx">MyStore</span> <span class="kr">extends</span> <span class="nx">Reactor</span> <span class="p">{</span>
    <span class="nx">reduce</span><span class="p">(</span><span class="nx">prevState</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">payload</span>: <span class="kt">Payload</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
            <span class="k">case</span> <span class="s2">&quot;INCREMENT&quot;</span><span class="o">:</span>
                <span class="k">return</span> <span class="nx">prevState</span> <span class="o">+</span> <span class="nx">1</span>:
            <span class="kt">default</span><span class="o">:</span>
                <span class="k">return</span> <span class="nx">prevState</span><span class="p">;</span>
        <span class="p">}</span>   
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>簡単にまとめると、まだ曖昧な部分があったStoreをもう少し明確な役割付けしたという話です。</p>

<p><strong>Notes:</strong></p>

<p><code>receivePayload</code>という名前がまだしっくりきてないところがある。
なんかもっと広い意味になる可能性がありそうなので、何かもっといい方法があるのかもしれない。</p>

<p>Read層にもRead用のRepositoryやRead用のDatabaseなどを用意すれば、もっとクラス的に分解できるけど、流石にそこまでやるととオーバーキルな感じがしたのでやらなかった。
理由として、Read(View)側のデータを永続的なデータベースに書き込んで保持したいというケースが浮かばなかった(Read側はそこまで複雑な永続データを持ちたくないはず)</p>

<p>UI的に保持したい状態ってIndexedDBじゃなくて、localStorageに保存するぐらいで終わる気がした。</p>

<blockquote>
<p>FluxのStoreの話</p>
</blockquote>

<p><a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html"><img src="http://efcl.info/wp-content/uploads/2017/05/11-1494492570.png" alt="Flux Store"></a></p>

<h2 id="マイグレーション方法">マイグレーション方法</h2>

<p>Almin 0.11から0.12へのアップグレードは次のマイグレーションツールが利用できます。</p>

<ul>
<li><a href="https://github.com/almin/migration-tools" title="almin/migration-tools: Migration scripts for Almin.">almin/migration-tools: Migration scripts for Almin.</a></li>
</ul>

<p>jscodeshiftというツールで動くマイグレーションスクリプトを用意しています。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># Installation
npm install -g jscodeshift @almin/migration-tools 
# 1. Storeクラスを一括で変換
jscodeshift --run-in-band -t `npm root -g`/@almin/migration-tools/scripts/store-get-state-return-object-to-flat.js src/store/*/**/*Store.js
# 2. 1.の変換結果を使ってStoreGroupを変換
jscodeshift --run-in-band -t `npm root -g`/@almin/migration-tools/scripts/store-group-arguments.js src/store/AppStore.js
# store-state-mapping.jsonは変換中に使うデータなので消していい
rm store-state-mapping.json
</code></pre></div>
<p>実際にアップデートしてる例は次のPRを見てください。</p>

<ul>
<li><a href="https://github.com/azu/presentation-annotator/pull/11" title="chore(deps): update dependencies by azu · Pull Request #11 · azu/presentation-annotator">chore(deps): update dependencies by azu · Pull Request #11 · azu/presentation-annotator</a></li>
<li><a href="https://github.com/textlint/textlint-app/pull/5" title="chore(almin): Update to Almin 0.12 by azu · Pull Request #5 · textlint/textlint-app">chore(almin): Update to Almin 0.12 by azu · Pull Request #5 · textlint/textlint-app</a></li>
</ul>

<p>その他の変更点についてはリリースノートをみてください。</p>

<ul>
<li><a href="https://github.com/almin/almin/releases/tag/almin%400.12.3" title="Release Almin 0.12 · almin/almin">Release Almin 0.12 · almin/almin</a></li>
</ul>

<h2 id="next">Next</h2>

<p>Almin 0.12 + TypeScriptならStoreは、型の整合がとれるように書けるようなったと思います。
(明示的なキャストなどむりやりやらなくても型がちゃんとついてくる)</p>

<p>UseCaseの部分が余計な情報を明示的に渡さないと型チェックが上手くできていません。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="nx">type</span> <span class="nx">MyUseCaseArgs</span> <span class="o">=</span> <span class="kt">string</span><span class="p">;</span>
<span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">MyUseCaseArgs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
            <span class="nx">value</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// execute UseCase</span>
<span class="kr">const</span> <span class="nx">useCase</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyUseCase</span><span class="p">();</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">(</span><span class="nx">useCase</span><span class="p">).</span><span class="nx">execute</span><span class="o">&lt;</span><span class="nx">MyUseCaseArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
     <span class="c1">// something</span>
  <span class="p">})</span><span class="o">:</span>
</code></pre></div>
<p>これを次期Alminでは次のように書けるようにしたいと思っています。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
            <span class="nx">value</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">(</span><span class="k">new</span> <span class="nx">MyUseCase</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">executor</span><span class="p">(</span><span class="nx">useCase</span> <span class="o">=&gt;</span> <span class="nx">useCase</span><span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span> <span class="c1">// &lt;= Error</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div>
<p>この辺で上手くBatch Action的な処理も解決できればなーと思って考えています。</p>

<p>次のIssueとPRで実験してるので何か意見があったらください。
(特に<code>executor</code>とかの命名が難しい…)</p>

<ul>
<li><a href="https://github.com/almin/almin/issues/193" title="UseCase: Fluent style UseCase · Issue #193 · almin/almin">UseCase: Fluent style UseCase · Issue #193 · almin/almin</a></li>
<li><a href="https://github.com/almin/almin/pull/194" title="[WIP] feat(UseCase): Fluent style UseCase by azu · Pull Request #194 · almin/almin">[WIP] feat(UseCase): Fluent style UseCase by azu · Pull Request #194 · almin/almin</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Travis CIでGitHub Personal access tokensが漏れないようにする</title>
   <link href="http://efcl.info/2017/05/09/travis-ci-github-token/"/>
   <updated>2017-05-09T09:20:00+09:00</updated>
   <id>http://efcl.info/2017/05/09/travis-ci-github-token</id>
   <content type="html"><![CDATA[ <p>2017-05-09 漏れていた人はメールで通知が来ていると思いますが、Travis CIのログ上にGitHubのTokenが漏れていたケースがあるという話がありました。
(漏れていたTokenはGitHub側で既にrevokeされていると思います。またメールに漏れている一覧が載ってるはず)</p>

<ul>
<li><a href="https://blog.travis-ci.com/2017-05-08-security-advisory" title="The Travis CI Blog: Security Advisory: Secured Environment Variables">The Travis CI Blog: Security Advisory: Secured Environment Variables</a></li>
</ul>

<p>これ自体はTravis CIのバグではなくて、ユーザーが書いたデプロイスクリプトなどのツール側のバグによってGitHubのTokenなどsecretな環境変数がログ上に出ている話です。
Travis CIのログはPublicで誰でも見ることができるので、標準出力にTokenが露出していると問題があります。</p>

<p>どのようなケースでGitHubのTokenが標準出力に出てしまうかというと、<code>git push</code>のミスが一番多いと思います。</p>

<p>例えば次のようにGitHubのTokenを使って、Travis CIからGitHubへpushしているスクリプトは問題があります。</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">git push --force --quiet <span class="s2">&quot;https://${GH_TOKEN}@github.com/example/test.git&quot;</span> gh-pages
</code></pre></div>
<p>このスクリプトは、<code>--quiet</code>が付いてるので <code>GH_TOKEN</code> が漏れないように見えますが、
<code>git push</code>に失敗すると、エラー結果に含まれるpush先(<code>&quot;https://${GH_TOKEN}@github.com/example/test.git&quot;</code>)がログにでるため安全ではありません。</p>

<p>そのため、標準出力と標準エラー出力を両方共潰さないと、<code>GH_TOKEN</code>が漏れるケースがあります。</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">git push --force --quiet <span class="s2">&quot;https://${GH_TOKEN}@github.com/example/test.git&quot;</span> gh-pages &gt;/dev/null 2&gt;<span class="p">&amp;</span>1
</code></pre></div>
<ul>
<li><a href="https://docs.travis-ci.com/user/best-practices-security/" title="Best Practices in Securing Your Data - Travis CI">Best Practices in Securing Your Data - Travis CI</a></li>
</ul>

<p>この手法は<a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd" title="Auto-deploying built products to gh-pages with Travis">Auto-deploying built products to gh-pages with Travis</a>の古いバージョンで紹介されていたので知ってる人も多いと思います。</p>

<p>このTravis CI上のGitHub Token(GitHubには限らないけど)漏れは結構前から見かけることがあって、いくつか報告した記憶もあります。</p>

<ul>
<li><a href="https://github.com/jirutka/rake-jekyll/issues/8" title="GH_TOKEN is leaked · Issue #8 · jirutka/rake-jekyll">GH_TOKEN is leaked · Issue #8 · jirutka/rake-jekyll</a></li>
<li><a href="https://github.com/babel/babel/issues/3727" title="Security concern about merge-development-with-master.sh (T6661) · Issue #3727 · babel/babel">Security concern about merge-development-with-master.sh (T6661) · Issue #3727 · babel/babel</a></li>
</ul>

<p>この辺の問題があるリポジトリについて、Travis側が過去のログを調査して今回の通知を出したようです。
また、今日から環境変数とマッチする文字列は、ログ上では<code>[secure]</code>に自動で置換されるようになっています。</p>

<blockquote>
<p>Both new builds and archived build logs with this issue will see the string [secure] instead of potentially exposed secure environment variables. Logs on both our open-source .org, and closed-source .com platforms have been updated.
-- <a href="https://blog.travis-ci.com/2017-05-08-security-advisory" title="The Travis CI Blog: Security Advisory: Secured Environment Variables">The Travis CI Blog: Security Advisory: Secured Environment Variables</a></p>
</blockquote>

<p><img src="http://efcl.info/wp-content/uploads/2017/05/09-1494289700.png" alt="image"></p>

<h2 id="travis-ciからgithubへpushする">Travis CIからGitHubへpushする</h2>

<p>Travis CIからGitHub(gh-pages)へpushしたい場合、自分の場合はGitHubのtokenではなくSSHのキーを使うようにしています。</p>

<p>GitHubにはリポジトリごとにreadまたはwriteの<a href="https://developer.github.com/guides/managing-deploy-keys/" title="Deploy Keys">Deploy Keys</a>としてSSHの公開鍵を登録することができます。</p>

<ul>
<li><a href="https://developer.github.com/guides/managing-deploy-keys/" title="Deploy Keys">Deploy Keys</a></li>
<li><a href="https://docs.travis-ci.com/user/deployment/custom/" title="Custom Deployment - Travis CI">Custom Deployment - Travis CI</a></li>
<li><a href="https://circleci.com/docs/1.0/adding-read-write-deployment-key/" title="Adding read/write deployment key - CircleCI">Adding read/write deployment key - CircleCI</a></li>
</ul>

<p>GitHubのTokenは権限は設定できますがユーザー単位なので、一度漏れるとそのユーザーのすべてのリポジトリに影響があります。
GitHubの<a href="https://developer.github.com/guides/managing-deploy-keys/" title="Deploy Keys">Deploy Keys</a>はリポジトリごとなので、漏れてもそのリポジトリのみしか読み書きすることができません。</p>

<p><a href="https://github.com/azu/add-deploy-key-to-github" title="add-deploy-key-to-github">add-deploy-key-to-github</a>などを使うと、CLIから<a href="https://developer.github.com/guides/managing-deploy-keys/" title="Deploy Keys">Deploy Keys</a>を作ってリポジトリに登録できるので、それを使ってgit pushすると簡単です。
(Token方式みたいにgit push先を変更する必要もないけど、ssh経由にする必要があるので <code>git config --global url.ssh://git@github.com/.insteadOf https://github.com/</code> などしておくとデプロイスクリプトの変更がいらない)</p>

<p><a href="https://developer.github.com/guides/managing-deploy-keys/" title="Deploy Keys">Deploy Keys</a>(SSHキー)を使った<code>gh-pages</code>へのpush方法は次の記事などで解説されています。</p>

<ul>
<li><a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd" title="Auto-deploying built products to gh-pages with Travis">Auto-deploying built products to gh-pages with Travis</a></li>
<li><a href="http://efcl.info/2016/09/27/deploy-from-travis-ci-to-gh-pages/" title="Travis CIからgh-pagesへデプロイする設定 via SSH/git push | Web Scratch">Travis CIからgh-pagesへデプロイする設定 via SSH/git push | Web Scratch</a></li>
<li><a href="https://www.tam-tam.co.jp/tipsnote/program/post11795.html" title="Travis CI から GitHub へ git push を行う設定 ｜ Tips Note by TAM">Travis CI から GitHub へ git push を行う設定 ｜ Tips Note by TAM</a></li>
</ul>

<h2 id="フローチャート">フローチャート</h2>

<ol>
<li>Travis CIからGitHubへpushしたい

<ul>
<li>=&gt; リポジトリ用のsshキーを作ってdeploy keyに登録して使う</li>
</ul></li>
<li>Travis CIでGitHubのtokenが必要(APIを使う処理)

<ul>
<li>=&gt; Personal access tokensをリポジトリ用に新規作成して使う</li>
<li>Tokenが漏れると影響範囲が広いので、使い回しはしない</li>
</ul></li>
</ol>

<h2 id="その他">その他</h2>

<p>今回の話はまた違いますが、npmへpublishされたパッケージから秘密の情報が混じっていたり、awsのcredentialsがリポジトリに漏れているのは稀によく見るので、そういうのが起こりにくいような仕組みを保つ必要がありそうです。</p>

<ul>
<li><a href="https://github.com/ChALkeR/notes/blob/master/Do-not-underestimate-credentials-leaks.md" title="notes/Do-not-underestimate-credentials-leaks.md at master · ChALkeR/notes">notes/Do-not-underestimate-credentials-leaks.md at master · ChALkeR/notes</a></li>
<li><a href="https://github.com/blog/1390-secrets-in-the-code" title="Secrets in the code">Secrets in the code</a></li>
</ul>

<p>npmへpublishするのに<a href="http://t-wada.hatenablog.jp/entry/nodejs-package-json-tips" title="package.json の files フィールドでホワイトリスト">package.json の files フィールドでホワイトリスト</a>を使うとか、<a href="https://github.com/awslabs/git-secrets" title="awslabs/git-secrets: Prevents you from committing secrets and credentials into git repositories">awslabs/git-secrets</a>などでpush前にチェックするなど</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>コード中にあるprototype.jsの拡張メソッドを使ってる部分を検索するツール</title>
   <link href="http://efcl.info/2017/04/26/search-prototype.js/"/>
   <updated>2017-04-26T10:18:00+09:00</updated>
   <id>http://efcl.info/2017/04/26/search-prototype.js</id>
   <content type="html"><![CDATA[ <p><a href="http://prototypejs.org/" title="Prototype">Prototype.js</a>のコードを見つけるgrep的な検索ツールを書きました。</p>

<ul>
<li><a href="https://github.com/azu/search-prototype.js" title="azu/search-prototype.js: Search usage of prototype.js in your codes.">azu/search-prototype.js: Search usage of prototype.js in your codes.</a></li>
</ul>

<p><a href="https://github.com/azu/search-prototype.js"><img src="https://media.giphy.com/media/l4FGDki3jhUbhGVSE/giphy.gif" alt="gif"></a></p>

<p>redmind 2.0のコードからprototype.jsを利用してる箇所を検索してる様子</p>

<h2 id="使い方">使い方</h2>

<p>使い方はものすごい単純で、インストールして、検索したいファイルパスを渡すだけです。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install search-prototype.js -g
search-prototype.js ./public/javascripts/application.js
</code></pre></div>
<p>標準出力に検索結果が流れてきます。</p>

<p>検出するAPIの定義はAPIリファレンスのサジェストファイルから取ってきています。</p>

<ul>
<li><a href="http://api.prototypejs.org/javascripts/pdoc/item_index.js">http://api.prototypejs.org/javascripts/pdoc/item_index.js</a></li>
</ul>

<h2 id="制限">制限</h2>

<p><a href="http://prototypejs.org/" title="Prototype">Prototype.js</a>は名前が表すようにprototypeを拡張するライブラリです。</p>

<p>そのため、<code>Array.prototype.every</code>がprototype.jsで拡張されたものか、ネイティブものかを見極める方法はありません。
この検索ツールでは、そういった曖昧なものもデフォルトではアグレッシブに検出します。</p>

<p><a href="http://www.graspjs.com/" title="grasp">grasp</a>をベースにしたASTをベースにして検索を行うため、文字列検索よりは誤爆は少ないですがそれでも誤爆は避けられません。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&quot;[].every()は文字列&quot; // 文字列
// これは検出されないけど
[].every(function(element){})
// これは検出する
</code></pre></div>
<p>さらにいえば、JavaScriptの関数はファーストクラスなので、次のような書き方も正常系です。なので、このツールではこの書き方も検出します。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">cc</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">create</span>
<span class="nx">cc</span><span class="p">({});</span>
</code></pre></div>
<p><img src="http://efcl.info/wp-content/uploads/2017/04/26-1493170126.png" alt="image"></p>

<ul>
<li><a href="https://github.com/azu/search-prototype.js/blob/master/src/create-search-index.js">https://github.com/azu/search-prototype.js/blob/master/src/create-search-index.js</a></li>
<li>このファイルをみるとどのような検索パターンなのか分かります。</li>
</ul>

<p>検索クエリは基本的にはequeryですが、utilだけsqueryで書いてます(graspには<code>$</code>をエスケープできないバグがある)</p>

<ul>
<li><a href="http://www.graspjs.com/docs/equery/">equery | Grasp - JavaScript structural search, replace, and refactor</a></li>
<li><a href="http://www.graspjs.com/docs/squery/">squery | Grasp - JavaScript structural search, replace, and refactor</a></li>
</ul>

<h2 id="おわり">おわり</h2>

<p><a href="https://en.wikipedia.org/wiki/Prototype_JavaScript_Framework" title="Prototype JavaScript Framework - Wikipedia">Prototype JavaScript Framework - Wikipedia</a>によると<a href="http://prototypejs.org/" title="Prototype">Prototype.js</a>のは12年前にリリースされたライブラリです。</p>

<p><a href="https://mootools.net/" title="MooTools">MooTools</a>もそうですが、まだECMAScriptにはArray#mapなどもなかった時代に色々拡張したprototypeメソッドを定義しています。
そのため、jQueryなどと比べてもコードとライブラリが融合しやすく後からリファクタリングするのはとても大変です。(どこでメソッドを参照されているのか分からない)</p>

<p>prototype.js自体を書き換えて実行時にprototype.jsの利用箇所を検出する方法もありますが、特定のタイミングでしか呼ばれない箇所にprototype.jsの依存がある場合は見つけることができません。
そういったものも静的に解析できるようにするため<a href="https://github.com/azu/search-prototype.js" title="search-prototype.js">search-prototype.js</a>を作ってみました。</p>

<ul>
<li><a href="https://github.com/sstephenson/prototype/blob/master/ext/update_helper/update_helper.js" title="prototype/update_helper.js at master · sstephenson/prototype">prototype/update_helper.js at master · sstephenson/prototype</a></li>
</ul>

<p>検索だけでなく置換も含めたリファクタリングを行いたい場合は<a href="https://github.com/facebook/jscodeshift" title="jscodeshift">jscodeshift</a>などもおすすめです。</p>

<ul>
<li><a href="https://github.com/facebook/jscodeshift" title="jscodeshift">jscodeshift</a></li>
<li><a href="http://www.graspjs.com/" title="Grasp - JavaScript structural search, replace, and refactor">Grasp - JavaScript structural search, replace, and refactor</a>

<ul>
<li><a href="http://www.graspjs.com/docs/replace/" title="Replacement | Grasp - JavaScript structural search, replace, and refactor">Replacement | Grasp - JavaScript structural search, replace, and refactor</a></li>
</ul></li>
</ul>

<hr>

<p>prototype.jsは今月になってなぜかコミットがあったのが面白かったです。</p>

<ul>
<li><a href="https://github.com/sstephenson/prototype/commits/master" title="Commits · sstephenson/prototype">Commits · sstephenson/prototype</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Node学園 25時限目でECMAScriptの国際標準化の話をした</title>
   <link href="http://efcl.info/2017/04/24/node-25/"/>
   <updated>2017-04-24T23:51:00+09:00</updated>
   <id>http://efcl.info/2017/04/24/node-25</id>
   <content type="html"><![CDATA[ <p><a href="https://nodejs.connpass.com/event/54749/" title="Node学園 25時限目 - connpass">Node学園 25時限目 - connpass</a>に受付として参加してきて、ついでにECMAScript Specification SuiteについてのLTをしました。</p>

<blockquote>
<p>ECMAScript Specification Suite<br>
スライド-- <a href="http://azu.github.io/slide/2017/node/ecmascript-specification-suite.html">http://azu.github.io/slide/2017/node/ecmascript-specification-suite.html</a></p>
</blockquote>

<p><a href="http://azu.github.io/slide/2017/node/ecmascript-specification-suite.html" title="ECMAScript Specification Suite">ECMAScript Specification Suite</a>は現在議論中のECMAScriptの新しい国際標準候補です。</p>

<p>どういうものかは次の記事でも書いています。</p>

<ul>
<li><a href="http://efcl.info/2017/02/27/ecma-414/" title="ECMA-414 ECMAScript Specification Suiteについて | Web Scratch">ECMA-414 ECMAScript Specification Suiteについて | Web Scratch</a></li>
</ul>

<p>以下はメモです。</p>

<p>受付をやっていたのでかなり断片的です。</p>

<h2 id="node-8-0-0"><a href="mailto:node@8.0.0">node@8.0.0</a></h2>

<blockquote>
<p><a href="http://abouthiroppy.github.io/slides/node8/" title="abouthiroppy/node8">abouthiroppy/node8</a></p>
</blockquote>

<h2 id="introduction-to-rust-by-akito0107">Introduction to Rust by Akito0107</h2>

<ul>
<li>Rustとは</li>
<li>Rustが新しいところ = メモリ管理</li>
<li>所有権の概念</li>
<li>メモリ領域の種類

<ul>
<li>Stack</li>
<li>1つの関数とかサブルーチンとか1つのブロックの中のメモリ</li>
<li>ブロックから抜けるとポップする</li>
<li>基本的に高速</li>
<li>Heap</li>
<li>複数のサブルーチンとか、関数で使いまわしたりする</li>
<li>明示的な管理が必要</li>
<li>Stackに比べるメモリ管理のコストが高い</li>
<li>メモリ管理</li>
<li>手動でmalloc/free</li>
</ul></li>
<li>GC

<ul>
<li>自動でメモリ管理 確保と解放を行う</li>
<li>生きてるオブジェクト死んでるオブジェクトを判別して処理する</li>
<li>参照してるかどうか</li>
<li>GC中は他の処理ができなくなることがある</li>
</ul></li>
<li>Rustのアプローチ

<ul>
<li>手動/GCでもなく所有権でメモリ管理を解決</li>
<li>RustのデフォルトはStackでallocate</li>
<li>Heap Allocation</li>
<li>Box::newするとHeapへ確保</li>
<li><code>let foo = boxed_foo()</code> fooはheap領域を参照</li>
<li>Stackから抜けるときにheap領域のものも消す</li>
</ul></li>
<li>Rustのコンパイルエラー

<ul>
<li>所有権 =　オブジェクトを開放する権利</li>
<li>Rustはオブジェクトの所有権は基本的に1つオブジェクトがもつ</li>
<li>既に所有権をもってないものが触ろうとしたらコンパイルエラー</li>
<li>Rust における <code>=</code> は「代入」じゃなくて「移譲」となる</li>
<li>所有権を「移譲」してる</li>
<li>参照と借用 = read onlyの参照は許可する概念がある</li>
</ul></li>
<li>寿命

<ul>
<li>借用先の寿命 &gt; 借用元の寿命</li>
<li>デフォルトはスタックであることを思い出す</li>
</ul></li>
<li>メモリ安全、データ競合安全

<ul>
<li>コンパイラがチェックしてくれる</li>
</ul></li>
<li>言語機能

<ul>
<li>パターンマッチ、エラー処理などがある</li>
</ul></li>
<li>Rustのユースケースについて</li>
<li><a href="https://tokio.rs/" title="Tokio">Tokio</a></li>
<li><a href="https://github.com/hyperium/hyper" title="hyperium/hyper: An HTTP library for Rust">hyperium/hyper: An HTTP library for Rust</a></li>
</ul>

<hr>

<h2 id="cycle-js">Cycle.js</h2>

<ul>
<li><a href="https://cycle.js.org/" title="Cycle.js">Cycle.js</a></li>
<li>Rx的なものをラップしたフレームワーク</li>
<li><a href="https://github.com/staltz/xstream" title="staltz/xstream: An extremely intuitive, small, and fast functional reactive stream library for JavaScript">staltz/xstream: An extremely intuitive, small, and fast functional reactive stream library for JavaScript</a>

<ul>
<li>RxJSのoperatorを減らしたり、変更したもの</li>
</ul></li>
<li>Cycle.jsの設計

<ul>
<li>Applicationを<code>main()</code> と <code>driver()</code> に分割</li>
<li><code>driver()</code> DOM、APIを叩いたりする</li>
<li><code>main()</code> 副作用のないRxの世界</li>
</ul></li>
</ul>

<hr>

<h2 id="初めてのoss初めてのnode-contribute-chiiia12">初めてのOSS初めてのnode contribute - chiiia12</h2>

<blockquote>
<p><a href="https://speakerdeck.com/chiiia12/chu-metefalseosschu-metefalsenode-dot-js-contribute-number-tng25" title="初めてのOSS初めてのNode.js Contribute#tng25 // Speaker Deck">初めてのOSS初めてのNode.js Contribute#tng25 // Speaker Deck</a></p>
</blockquote>

<ul>
<li>OSS勉強会</li>
<li>Node.jsへのPRする</li>
<li>3回目でやっとマージされた</li>
<li>大きい所にPRすることで自信を持てた</li>
<li>レビューしてもらえる</li>
<li>運用方法が参考になる</li>
</ul>

<hr>

<h2 id="v8-interpreter-ignitionについて-by-brn0227">V8 Interpreter Ignitionについて by brn0227</h2>

<blockquote>
<p><a href="https://www.slideshare.net/ssuser6f246f/v8-iginition-interpreter" title="V8 Iginition Interpreter">V8 Iginition Interpreter</a></p>
</blockquote>

<ul>
<li>V8のインタープリタ</li>
<li>昔は常にfull codegenだった

<ul>
<li>ファイルがサイズがでかい、時間がかかる</li>
</ul></li>
<li>関数を実行するときにコンパイルようにした

<ul>
<li>Facebookでなんか遅い</li>
</ul></li>
<li>Ignition

<ul>
<li>ピーク時はfull codegenよりは遅い</li>
<li>平常時はまあまあな速度がある</li>
</ul></li>
</ul>

<p>今までのビルドパス</p>

<ul>
<li>JavaScript -&gt; AST -&gt; アーキテクチャ毎のバイトコード</li>
</ul>

<p>Ignition</p>

<ul>
<li>JavaScript -&gt; AST -&gt; Ignition -&gt; 中間コード -&gt; アーキテクチャ毎のバイトコード</li>
</ul>

<p>TurboFun</p>

<ul>
<li>Ignitionの中間コードを最適化するオプティマイズコンパイラ</li>
<li>Ignitionで実行中のプロファイルを取って、最適化する</li>
<li>最適化パスが間違っていた場合は、de-optsして戻す</li>
<li>小さな単位でやるので、de-opt時に戻りやすい(中間コードに戻す)</li>
</ul>

<p>IC(Inlining Cache)</p>

<ul>
<li>キャッシュミス時の劣化があった</li>
<li>missとfound の2種類のみあった</li>
<li>fast path/no inlined/miss の3パターンになった</li>
<li>キャッシュミスを減らすことでICの効率を下げないような工夫が入った</li>
</ul>

<h2 id="hello-mobx-by-leader22">Hello, MobX! by leader22</h2>

<blockquote>
<p><a href="http://leader22.github.io/slides/node_gakuen-25/" title="Hello, MobX!">Hello, MobX!</a></p>
</blockquote>

<ul>
<li><a href="https://github.com/mobxjs/mobx" title="MobX">MobX</a></li>
<li>state管理ライブラリ</li>
<li>どういうものなのか?</li>
<li>autorun -&gt; stateをなんとかする</li>
<li>state管理に絞ってる</li>
<li>アーキテクチャ自体は自分で決める</li>
</ul>

<h2 id="slack-codegolf-by-darai0512">Slack CodeGolf by darai0512</h2>

<hr>

<p>お疲れ様でした。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>箇条書きにおける文末の句点（。）を統一するtextlintルール</title>
   <link href="http://efcl.info/2017/04/11/textlint-rule-period-in-list-item/"/>
   <updated>2017-04-11T08:41:00+09:00</updated>
   <id>http://efcl.info/2017/04/11/textlint-rule-period-in-list-item</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/azu/textlint-rule-period-in-list-item" title="textlint-rule-period-in-list-item">textlint-rule-period-in-list-item</a>という<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールを書きました。</p>

<p>箇条書きの文末に。がついてたりついてなかったりするのを統一するためのルールです。
本文中の句点（。）の統一するルールは別途あります。</p>

<ul>
<li><a href="https://github.com/textlint-ja/textlint-rule-ja-no-mixed-period/" title="textlint-ja/textlint-rule-ja-no-mixed-period: 文末の句点(。)の統一 と 抜けをチェックするtextlintルール">textlint-ja/textlint-rule-ja-no-mixed-period: 文末の句点(。)の統一 と 抜けをチェックするtextlintルール</a></li>
</ul>

<p><strong>デフォルトの挙動</strong> </p>

<p>デフォルトは句点を付けないように統一します。
以前アンケートを取ってみたところ、箇条書きの文末に句点はつけない人のほうが多そうではありました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">[Poll] 箇条書きの文末に。をつける付けない</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/844535223278694404">March 22, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>(もちろんオプションで変更できます)</p>

<p><strong>OK</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- 項目1
- 項目2
- [textlint](https://github.com/textlint/textlint &quot;textlint&quot;)
</code></pre></div>
<p><strong>NG</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- 項目1。
- 項目2.
</code></pre></div>
<p>という感じになります。</p>

<h2 id="install">Install</h2>

<p><a href="https://www.npmjs.com/">npm</a>を使ってインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install textlint-rule-period-in-list-item
</code></pre></div>
<h2 id="usage">Usage</h2>

<p><a href="https://www.google.com/search?q=textlint+%E4%BD%BF%E3%81%84%E6%96%B9">textlint 使い方</a>などで検索してください。</p>

<p>Via <code>.textlintrc</code>(Recommended)</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;period-in-list-item&quot;</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="オプション">オプション</h2>

<p>オプションは色々ありますが、句点をつけないひとはあんまり変更する必要がないはずです。
句点を付ける人は、<code>periodMark</code>に利用する記号を指定してください。</p>

<p>例えば、<code>periodMark: &quot;。&quot;</code>とすれば、箇条書きの文末に<code>。</code>を付けることをチェックします。</p>

<p>文末に<code>。</code>を必須にした場合でも <code>- 「OK」</code> は許可したいという場合は、<code>allowPeriodMarks</code>で設定できます。(<code>!</code>や<code>?</code>といった文末に来る可能性が高いものはデフォルトで入っていますが)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">{</span>
    <span class="c1">// prefer to use period mark.</span>
    <span class="c1">// &quot;&quot; (default is no period)</span>
    <span class="c1">// You can select period mark like &quot;.&quot; from &quot;periodMarks&quot;.</span>
    <span class="s2">&quot;periodMark&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="c1">// Built-in recognized period mark list</span>
    <span class="c1">// if the period of the text is not `periodMark` and it is a string in the `periodMarks`,</span>
    <span class="s2">&quot;periodMarks&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;。&quot;</span><span class="p">,</span> <span class="s2">&quot;．&quot;</span><span class="p">],</span>
    <span class="c1">// Ignore only link tag</span>
    <span class="c1">// - [text](link)</span>
    <span class="c1">// It is not needed period mark</span>
    <span class="s2">&quot;ignoreLinkEnd&quot;</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="c1">// allow exception period mark list at end of the list item</span>
    <span class="c1">// Ignore this period mark</span>
    <span class="s2">&quot;allowPeriodMarks&quot;</span><span class="o">:</span> <span class="p">[],</span>
    <span class="c1">// Allow emoji at end of the list item</span>
    <span class="s2">&quot;allowEmoji&quot;</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="c1">// If not exist `periodMark` at end of the list item</span>
    <span class="c1">// Automatically, append `periodMark` when does textlint --fix</span>
    <span class="s2">&quot;forceAppendPeriod&quot;</span><span class="o">:</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="句点をつけるように自動修正">句点をつけるように自動修正</h2>

<p>このルールは<code>textlint --fix</code>の自動修正にも対応しています。
句点を取り除く方は常に<code>--fix</code>で修正されますが、句点を付ける方は<code>forceAppendPeriod:true</code>の時のみ有効です。
(エディタなどで保存ごとに<code>--fix</code>したいという場合に問題になるため)</p>

<p>次の設定では、<code>.</code>が<code>--fix</code>をした時に自動で追加されます。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;period-in-list-item&quot;</span><span class="p">:</span> <span class="p">{</span>
           <span class="nt">&quot;periodMark&quot;</span><span class="p">:</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
           <span class="nt">&quot;forceAppendPeriod&quot;</span><span class="p">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Before</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- item
</code></pre></div>
<p><strong>After</strong></p>

<p><code>textlint --fix</code>した結果</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- item.
</code></pre></div>
<h2 id="おわりに">おわりに</h2>

<p>箇条書きにおける句点の表記を統一するtextlintルールでした。
何か問題を見つけた場合次のリポジトリのIssueへ報告してください。</p>

<ul>
<li><a href="https://github.com/azu/textlint-rule-period-in-list-item" title="textlint-rule-period-in-list-item">textlint-rule-period-in-list-item</a></li>
</ul>

<p>また<a href="https://gitter.im/textlint-ja/textlint-ja">Gitterのtextlint-ja</a>のチャットでも問題ないです。</p>

<p><a href="https://gitter.im/textlint-ja/textlint-ja?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/textlint-ja/textlint-ja.svg" alt="Gitter"></a></p>

<p>箇条書きに句点を付けるか付けないかの明確な根拠は探した感じよく分かりませんでした。
日本語だけじゃなくて英語でも人によっても違う感じだったので、何か興味深い資料があればおしらせください。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>不自然なアルファベットを見つけるtextlintルール</title>
   <link href="http://efcl.info/2017/03/27/unnatural-alphabet/"/>
   <updated>2017-03-27T20:14:00+09:00</updated>
   <id>http://efcl.info/2017/03/27/unnatural-alphabet</id>
   <content type="html"><![CDATA[ <p>不自然なアルファベットを検知する<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールを書きました。</p>

<ul>
<li><a href="https://github.com/textlint-ja/textlint-rule-ja-unnatural-alphabet" title="textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール">textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール</a></li>
</ul>

<p>IMEの入力ミスによるtypoを見つける目的です</p>

<h2 id="example">Example</h2>

<p><strong>OK</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">リリース
aiueo
This is pen.
</code></pre></div>
<p><strong>NG</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">リイr−ス
対応でｋない
こrはおかしい。
検索してくd際
</code></pre></div>
<p>上記のようなIME特有の日本語の間に不自然に挟まった1文字のアルファベットを見つけるルールです。</p>

<h2 id="install">Install</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install textlint-rule-ja-unnatural-alphabet
</code></pre></div>
<p>でインストールできます。
使い方はいろんな記事があるので、&quot;textlint 導入&quot;とかで検索してください。</p>

<ul>
<li><a href="http://qiita.com/azu/items/e36501d25593d008f6ac" title="textlintをTravis CIで動かして継続的に文章をチェックする - Qiita">textlintをTravis CIで動かして継続的に文章をチェックする - Qiita</a></li>
<li><a href="http://qiita.com/azu/items/2c565a38df5ed4c9f4e1" title="VS Codeでtextlintを使って文章をチェックする - Qiita">VS Codeでtextlintを使って文章をチェックする - Qiita</a></li>
</ul>

<h2 id="オプション">オプション</h2>

<p><code>X</code>軸などアルファベット一文字を使うことはあるので、そういうものはオプションで回避できるようになっています。
C言語のようなよくあるアルファベット一文字 + 日本語からなる単語は<code>allowCommonCase</code>で無視されています。</p>

<ul>
<li><code>allow</code>: <code>string[]</code>

<ul>
<li>無視するアルファベットや単語の配列</li>
<li>デフォルト: <code>[&quot;a&quot;, &quot;i&quot;, &quot;u&quot;, &quot;e&quot;, &quot;o&quot;, &quot;n&quot;, 典型例 ]</code></li>
<li>デフォルトでは母音とnを除外している</li>
<li><code>&quot;/正規表現/&quot;</code> のような文字列もサポート</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">{</span>
    <span class="c1">// 無視するアルファベット</span>
    <span class="c1">// 例) [&quot;X&quot;]</span>
    <span class="c1">// デフォルトでは母音とnを除外</span>
    <span class="s2">&quot;allow&quot;</span><span class="o">:</span> <span class="p">[</span>
        <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span>
    <span class="p">],</span>
    <span class="c1">// ビルトインの典型例を除外するかどうか</span>
    <span class="c1">// 例) C言語</span>
    <span class="s2">&quot;allowCommonCase&quot;</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="元ネタ">元ネタ</h2>

<p>この<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>ルールは元ネタがあって、<a href="http://ci.nii.ac.jp/naid/110002893543">CiNii 論文 -  日本語文章校正ツール&quot;Chanterelle&quot; : 入力ミス及び表記揺らぎについて</a>という論文が元ネタです。</p>

<p>不自然なアルファベットを見つけるルールが書かれていて、これを元に実装しました。</p>

<blockquote>
<p>(3) 不自然なアルファベット</p>
</blockquote>

<ul>
<li>1文字のみのアルファベットが日本語中に現れた場合に検出対象とする</li>
<li>大文字は、略記号などを意識して入れている可能性がある</li>
<li>このミスでは母音(<code>aiueo</code>)は発生しないので除く</li>
<li><code>n</code>も多くの場合には、<code>ん</code>となるため除く</li>
</ul>

<p>実装してみて<a href="https://github.com/textlint-ja/technological-book-corpus-ja">色々な再配布可能な技術書を集めた</a>ものに実際に通してみて、典型的な例外を少し加えるなどしています。</p>

<ul>
<li><a href="https://github.com/textlint-ja/technological-book-corpus-ja" title="textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス">textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス</a></li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm i -g technological-book-corpus-ja textlint textlint-rule-ja-unnatural-alphabet
# 技術書のMarkdonファイルパスが出力される
# それをtextlintのルールに通してどんなところでおちるかをチェックする
technological-book-corpus-ja  | xargs textlint --rule textlint-rule-ja-unnatural-alphabet -f pretty-error
</code></pre></div> ]]></content>
 </entry>
 

</feed>
