<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Web Scratch</title>
 <link href="http://efcl.info/feed/atom/" rel="self"/>
 <link href="http://efcl.info"/>
 <updated>2017-11-07T12:02:01+09:00</updated>
 <id>http://efcl.info/</id>
 
 <author>
   <name>azu</name>
   
 </author>
 

 
 <entry>
   <title>textlintのコアをTypeScriptで書き直した、textlintの今後について</title>
   <link href="http://efcl.info/2017/11/06/textlint-core-refactoring/"/>
   <updated>2017-11-06T10:43:00+09:00</updated>
   <id>http://efcl.info/2017/11/06/textlint-core-refactoring</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/textlint/textlint/releases/tag/textlint%409.0.0" title="textlint 9.0.0">textlint 9.0.0</a>をリリースしました。
textlint 9.0.0では<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel" title="@textlint/kernel">@textlint/kernel</a>という内部的に使うコアモジュールをTypeScriptで書き直したバージョンが使われています。</p>

<p>元々textlintはNode.jsで動くように作られたため、<code>fs</code>モジュールなどNode.jsに依存しています。
そのため、ブラウザなどで動かす場合などはビルド時に色々工夫しないと動きません。</p>

<ul>
<li><a href="http://io-monad.hatenablog.com/entry/2016/03/14/225800" title="文書校正ツール textlint の Chrome 拡張を作った - もなでぃっく">文書校正ツール textlint の Chrome 拡張を作った - もなでぃっく</a></li>
<li><a href="https://muunyblue.github.io/823b2d10224a6a29f91fc7c0f46f1b8e.html" title="LocalStorageで誰でも安全にMarkdownでスライドやメモ作れるサービス作ったよ">LocalStorageで誰でも安全にMarkdownでスライドやメモ作れるサービス作ったよ</a></li>
</ul>

<p>この問題をどうにかするためには、<code>textlint</code>というモジュールからロジックやLint処理部分だけをNode.jsなどに依存しない純粋なJavaScriptとして切り出す必要があります。</p>

<p>アドホックに対応するならブラウザ向けのbundleを<a href="https://qiita.com/shinout/items/911e024368e2cb29fd3d" title="browser field">browser field</a>などで提供すれば終わりですが、長期的なことを考えるとモジュールを分けたほうが建設的です。</p>

<p><a href="https://github.com/textlint" title="textlint">textlint organization</a>を見ると分かるように<a href="https://github.com/textlint" title="textlint">textlint</a>はMarkdownパーサやトラバーサ、フォーマッターなどがモジュールとして各リポジトリに分けられていました。部品となるモジュールとリポジトリを1対1で分けると、Aをアップデートすると、Aに依存するBやCを更新するといったアップデートの連鎖反応が起きる問題があります。
また、新しいモジュールを切り出す心理的なコストがありました。</p>

<p>そのため、まずは<code>textlint</code>を構成するモジュールを1つのリポジトリにまとめたmonorepo化をすることにしました。</p>

<h2 id="monorepo">monorepo</h2>

<p><a href="https://github.com/textlint" title="textlint">textlint</a>では<a href="https://github.com/lerna/lerna" title="lerna">lerna</a>を使ってmonorepo化しています。これにより、モジュール間の依存のアップデートが1つのPRにまとめられるなどアップデートの連鎖反応がある程度自動化できるメリットがあります。
また、新しいモジュールを追加するのも単純にディレクトリを切るだけなので心理的なコストは軽減されます。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/255">Setup monorepo · Issue #255 · textlint/textlint</a></li>
<li><a href="https://github.com/textlint/textlint/issues/270">Import * to monorepo · Issue #270 · textlint/textlint</a></li>
</ul>

<p>一方、CIにかかる時間やpublishする際のコストは増加する傾向があります。
また、まだmonorepoにおけるリリースノートの戦略がイマイチ決まっていないという問題もあります。
これは<a href="https://github.com/almin/almin" title="almin">almin</a>とか<a href="https://github.com/textlint-rule/textlint-rule-preset-google" title="textlint-rule-preset-google">textlint-rule-preset-google</a>など、他にもmonorepoをやっているのでいい方法を見出したいです。</p>

<ul>
<li><a href="https://qiita.com/azu/items/4b9fc8d4df78f2216901" title="Lerna(monorepo)とCHANGELOG(リリースノート) - Qiita">Lerna(monorepo)とCHANGELOG(リリースノート) - Qiita</a></li>
</ul>

<h2 id="textlint-kernel"><a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a></h2>

<p>monorepo化がひとまずできたので、<a href="https://github.com/textlint/textlint/releases/tag/textlint%408.1.0" title="textlint@8.1.0">textlint 8.1.0</a>で<code>textlint</code>モジュールから<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>というコアモジュールを切り出しました。(Coreという名前じゃないのは既にCoreという名前を使ったものがあったため)
<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>は<code>fs</code>などNode.js特有のものに依存してないような作りになっているので普通にwebpackやbrowserifyなどでビルドすれば動作します。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/pull/292" title="Carve out textlint core logic into @textlint/kernel by azu · Pull Request #292 · textlint/textlint">Carve out textlint core logic into @textlint/kernel by azu · Pull Request #292 · textlint/textlint</a></li>
</ul>

<p>今回の<a href="https://github.com/textlint/textlint/releases/tag/textlint%409.0.0" title="textlint 9.0.0">textlint 9.0.0</a>ではさらにこの<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel" title="@textlint/kernel">@textlint/kernel</a>をTypeScriptに書き換えました。理由としては<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>はロジックの塊であることと今後のリファクタリングのしやすさを考えたためです。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/pull/301" title="refactor(textlint-kernel): Convert JavaScript to TypeScript by azu · Pull Request #301 · textlint/textlint">refactor(textlint-kernel): Convert JavaScript to TypeScript by azu · Pull Request #301 · textlint/textlint</a></li>
</ul>

<blockquote>
<p>TL;DR: both Flow and TypeScript are pretty good, and conservatively either of them can prevent about 15% of the bugs that end up in committed code.<br>
<a href="https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/">https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/</a></p>
</blockquote>

<p>JavaScriptに型注釈を加えることで15%程度バグを減らすことができるという話もありますが、IDEなどでリファクタリングがしやすくなるメリットは大きいです。(名前に依存した壊れたリファクタリングが発生しにくい)</p>

<p>JavaScriptからTypeScriptへの移行方法は次の記事で書いてるような手法を取っています。</p>

<ul>
<li><a href="http://efcl.info/2017/07/17/JavaScript-to-TypeScript/" title="JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch">JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch</a></li>
</ul>

<p>まだ単に型を付けただけであったり、テストはTypeScriptになってなかったりします。
本体の<code>textlint</code>の方もTypeScript化したいので興味がある人は次のIssueを参照してください。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/248" title="Use with TypeScript · Issue #248 · textlint/textlint">Use with TypeScript · Issue #248 · textlint/textlint</a></li>
</ul>

<p>また、まだルール側をTypeScriptで書きやすくなってはいないのでその辺もどうにかしたいですね。</p>

<h2 id="今後">今後</h2>

<p>textlintはルールを気軽に作れるようにする土台を作ることが目的です。</p>

<ul>
<li><a href="http://efcl.info/2014/12/30/textlint/" title="JavaScriptでルールを書けるテキスト/Markdownの校正ツール textlint を作った | Web Scratch">JavaScriptでルールを書けるテキスト/Markdownの校正ツール textlint を作った | Web Scratch</a></li>
</ul>

<p>今回色々リファクタリングして、<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>の分離でLint以外への発展も少し見えてきています。Lintは入力に対して解答(正否)を出さないと行けないですが、<a href="https://github.com/azu/textstat" title="textstat">textstat</a>のように統計データを出したり、<a href="http://www.academia.edu/154001/Glosser_Enhanced_Feedback_for_Student_Writing_Tasks" title="Glosser">Glosser</a>のようなフィードバックエンジンを作ってみたいです。</p>

<p>また、現在textlintに関係する<a href="https://github.com/search?utf8=%E2%9C%93&amp;q=textlint">リポジトリは200以上</a>、textlint<a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule">ルールは100以上</a>あります。
ただ、半分以上は自分が関連しているものなので、もっと属人性を解消して安定させたいです。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr">textlint 200 repositories. <a href="https://t.co/ZpF7DeuSLr">pic.twitter.com/ZpF7DeuSLr</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/924671458898358272?ref_src=twsrc%5Etfw">October 29, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>もっと安定して良くしていくために、textlint organizationのコラボレーターを募集しています。最初からコラボレーター(リリース権限とかもてる人)というのも互いに変ではあるので、まずはコントビューションしてくれる人を募集しています。</p>

<p>textlintではどういうところが足りてない、直せるのかなどについて簡単にまとめてみます。</p>

<h2 id="textlintへのコントビューション"><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>へのコントビューション</h2>

<p>相談したいことがある場合はGitterに日本語のchatがあるのでそちらを使ってみてください。
(これどうやって直せばいいのとか？)</p>

<p><a href="https://gitter.im/textlint-ja/textlint-ja?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/textlint-ja/textlint-ja.svg" alt="Gitter"></a></p>

<h2 id="textlintを直す">textlintを直す</h2>

<p><a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>にコミット方法やテスト方法など一通りのやり方は書いてあります。</p>

<h3 id="ドキュメントを直す">ドキュメントを直す</h3>

<ul>
<li>適当な英語が多いので修正歓迎</li>
</ul>

<h3 id="ドキュメントを追加する">ドキュメントを追加する</h3>

<ul>
<li>ルールの作り方とかもっと具体例のドキュメント増やしたい</li>
<li>こういうのがわからないというIssueを立てるでもよさそう</li>
</ul>

<h3 id="コアを直す">コアを直す</h3>

<ul>
<li>textlintはmonorepoになっているので<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>に色々なパッケージが入っています。

<ul>
<li>monorepoへの移行が完璧ではないのでそれをなおすのも歓迎です</li>
<li><a href="https://github.com/textlint/textlint/issues/270" title="Import * to monorepo #270">Import * to monorepo #270</a></li>
</ul></li>
</ul>

<p><a href="https://github.com/textlint/textlint/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+for+beginner%22" title="Issues · textlint/textlint"><code>label:&quot;good for beginner&quot;</code></a>というラベルが付いてるものは、比較的やることがはっきりしています。
そのため最初のコントビューションとして手が出しやすいかもしれません。</p>

<p>また、textlintはあまりパフォーマンスの最適化がまだ行われていません。<a href="https://github.com/textlint/textlint/blob/master/packages/markdown-to-ast/src/markdown-parser.js" title="markdown-parser">markdown-parser</a>など明らかに無駄な処理をしている部分があります。
一方、500以上のユニットテストや典型的なユースケースの<a href="http://efcl.info/2015/07/29/example-test-on-npm/" title="Exampleテスト">Exampleテスト</a>、実際の文章を使った<a href="https://github.com/textlint/textlint/tree/master/test/integration-test" title="Integration test">Integration test</a>などが書かれています。
そのため、壊れるとテストが落ちるはずなのでパフォーマンスの改善やリファクタリングなどはある程度し易いかもしれません。</p>

<p>TypeScriptで書きたいという人は、textlint本体もTypeScript化したり、型定義を整理したりすると良いかもしれません。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/248" title="Use with TypeScript #248">Use with TypeScript #248</a></li>
</ul>

<p>また、textlintをブラウザでもっと簡単に上手く動かしたいという人は次のIssueにどういうものがあると便利なのかやPOCを作ってみると良いかもしれません。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/299" title="@textlint/browser · Issue #299 · textlint/textlint">@textlint/browser · Issue #299 · textlint/textlint</a></li>
</ul>

<h2 id="ルールを直す">ルールを直す</h2>

<ul>
<li>textlintはデフォルトでルールをもっていません</li>
<li>そのためすべてのルールはプラグイン扱いです</li>
<li>ルール一覧は<a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule" title="Collection of textlint rule · textlint/textlint Wiki">Collection of textlint rule · textlint/textlint Wiki</a>にあります</li>
<li>各ルールにPull RequestやIssueを立てるのがよさそうです</li>
<li><a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a>で管理している日本語専用のルールは、日本語が分かる人じゃないと使わないので、Issueなどは日本語で問題ないです</li>
</ul>

<h2 id="ルールを追加する">ルールを追加する</h2>

<p>textlintのルールを置く場所には特に制限はありません。また自由にルールを書けます。</p>

<ul>
<li>ルールの作り方: <a href="https://github.com/textlint/textlint/blob/master/docs/rule.md" title="Creating Rules">Creating Rules</a></li>
</ul>

<p>ただ一度作ったルールがメンテナンスされなくなってしまうのはもったないので、<a href="https://github.com/textlint-rule/" title="textlint-rule">textlint-rule</a>と<a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a>は<a href="https://maintenance-guidelines-for-organization.github.io/" title="Maintenance Guidelines for Organization">Maintenance Guidelines for Organization</a>というガイドラインの元にしています。</p>

<p>人がボトルネックになることを避けるため、人が正しいことをできるように信用することという原則を元にしてリポジトリやnpmパッケージの権限を共有できるようにするという方針です。
そのため、textlintルールを作ったはいいけど置き場所や管理が不安というは、Organizationに参加してみるといいかもしれません。</p>

<p>それぞれoranizationも用意してあるので興味がある人は、<a href="https://twitter.com/azu_re">@azu_re</a>か<a href="https://gitter.im/textlint-ja/textlint-ja">Gitter</a>で言ってもらえれば inviteします。</p>

<ul>
<li>日本語専用のルール: <a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a></li>
<li>その他のルール: <a href="https://github.com/textlint-rule/" title="textlint-rule">textlint-rule</a></li>
</ul>

<p><a href="https://github.com/textlint/textlint/releases/tag/textlint%409.1.1" title="textlint@9.1.1">textlint@9.1.1</a>でscoped moduleのサポートを拡張したのもこういったOrganizationでのルール管理のしやすさを改善するためでもあります。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;@textlint-rule/preset-google&quot;</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="ルールを紹介する">ルールを紹介する</h2>

<p>自分が使っているルールや設定をブログなどで紹介するのも貢献です。</p>

<h2 id="ツールを良くする">ツールを良くする</h2>

<p>textlintのElectronアプリがありますがそこまで作り込まれてません。</p>

<ul>
<li><a href="http://efcl.info/2017/05/12/textlint-app/">textlintのElectronアプリを作った | Web Scratch</a></li>
<li><a href="https://github.com/textlint/textlint-app">textlint/textlint-app: textlint standalone application top on Electron.</a></li>
</ul>

<p>textlintのルールをコマンド一発で作り始めることができるツールがあります。
コーパスを使ってルールをチェックしやすくするなどもっと色々な工夫をして、ルールづくりを簡単にできると嬉しいです。</p>

<ul>
<li><a href="http://efcl.info/2016/12/14/create-textlint-rule/">textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch</a></li>
<li><a href="https://github.com/textlint/create-textlint-rule">textlint/create-textlint-rule: Create textlint rule project with no configuration.</a></li>
<li><a href="https://github.com/textlint-ja/technological-book-corpus-ja" title="textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス">textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス</a></li>
</ul>

<h2 id="ウェブサイト">ウェブサイト</h2>

<p>textlintのウェブサイト兼オンラインデモとして<a href="https://textlint.github.io/" title="textlint - pluggable linting tool for text and markdown">textlint - pluggable linting tool for text and markdown</a>があります。</p>

<p>こちらも<a href="https://github.com/textlint/textlint.github.io/labels/good%20first%20issue" title="Issues · textlint/textlint.github.io"><code>label:&quot;good for beginner&quot;</code></a>のラベルがついたIssueがあります。</p>

<h2 id="その他">その他</h2>

<p><a href="https://gist.github.com/azu/2b482e8e2aa636970f5f6110f6488719" title="textlintの直し方">textlintの直し方</a>に簡単にコントビューション方法についてまとめています。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>自然言語にマッチする正規表現を書いて、形態素解析結果でテストして、置換するライブラリを書いた</title>
   <link href="http://efcl.info/2017/10/31/nlp-pattern-match/"/>
   <updated>2017-10-31T11:23:00+09:00</updated>
   <id>http://efcl.info/2017/10/31/nlp-pattern-match</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールを色々書いていて自然言語のマッチの問題がいくつかありました。</p>

<p><a href="https://github.com/textlint-ja/textlint-rule-preset-JTF-style" title="textlint-ja/textlint-rule-preset-JTF-style: JTF日本語標準スタイルガイド for textlint.">textlint-ja/textlint-rule-preset-JTF-style: JTF日本語標準スタイルガイド for textlint.</a>は基本的に正規表現をベースに実装していました。
正規表現で自然言語に対してマッチするのは簡単でいいのですが、意図しない範囲にマッチすることもあるためfalse-positiveになりやすい問題がありました。</p>

<p>一方、ですます or である調の混在をチェックする<a href="https://github.com/textlint-ja/textlint-rule-no-mix-dearu-desumasu" title="textlint-rule-no-mix-dearu-desumasu">textlint-rule-no-mix-dearu-desumasu</a>では、<a href="https://github.com/takuyaa/kuromoji.js#api" title="kuromoji.js">kuromoji.js</a>などで形態素解析した結果を使っています。
形態素解析をすることで(正しい日本語なら)より正確にマッチできます。</p>

<p>しかし、形態素解析のトークンに対してマッチする処理やその情報を元に置換するのは結構面倒です。
kuromojiが出力するトークンにマッチするライブラリなどを書いて使っていますが、それでもそこそこ面倒です。</p>

<ul>
<li><a href="https://github.com/azu/morpheme-match">azu/morpheme-match: match function that match token(形態素解析) with sentence.</a></li>
<li><a href="https://github.com/azu/morpheme-match-all">azu/morpheme-match-all: A wrapper of morpheme-match API. Match all kuromoji&#39;s tokens.</a></li>
</ul>

<p>また、<a href="https://github.com/textlint-ja/textlint-rule-ja-no-abusage" title="textlint-ja/textlint-rule-ja-no-abusage: よくある日本語の誤用をチェックするtextlintルール">textlint-ja/textlint-rule-ja-no-abusage: よくある日本語の誤用をチェックするtextlintルール</a>などはマッチする範囲もトークンで指定するため、コードとしてもあまり読みやすくありません(単語が分解された大きなJSONを持つ形)</p>

<p>この簡単にマッチできるが誤判定し易い正規表現と正確にマッチできるが面倒臭いトークンベースの中間なライブラリをつくりました。</p>

<h2 id="nlp-pattern-match"><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">nlp-pattern-match</a></h2>

<p><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.</a>というリポジトリはmonorepoなのでいろんなライブラリが入っていますが、大きく分けて二種類のライブラリがあります。</p>

<h3 id="パーサ">パーサ</h3>

<p>一つは正確にマッチするのに必要な自然言語を分解するパーサ(形態素解析レベル)です。</p>

<ul>
<li><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-english" title="nlcst-parse-english">nlcst-parse-english</a>

<ul>
<li>英語のテキストを単語に分解してPart-of-speech(POS)情報を付加したNLCST</li>
</ul></li>
<li><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-japanese" title="nlcst-parse-japanese">nlcst-parse-japanese</a>

<ul>
<li>日本語のテキストを形態素解析したNLCST</li>
</ul></li>
</ul>

<p><a href="https://github.com/syntax-tree/nlcst">NLCST</a>はNatural Language Concrete Syntax Treeのことで、自然言語のCST(スペースなどの位置情報も扱うASTみたいなもの)フォーマットです。
NLCSTは<a href="https://github.com/wooorm/retext">retext</a>などが使っている形式で、ParagraphやSentence、WordなどのNodeから構成されます。</p>

<p>たとえば、<code>&quot;ようこそ、日本へ。&quot;</code>のようなテキストをNLCSTにすると次のような巨大なNodeになります。(長いの省略)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span><span class="nx">JapaneseParser</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-japanese&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">japaneseParse</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JapaneseParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;ようこそ、日本へ。&quot;</span><span class="p">;</span>
<span class="nx">japaneseParse</span><span class="p">.</span><span class="nx">ready</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">CST</span> <span class="o">=</span> <span class="nx">japaneseParse</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">CST</span><span class="p">)</span>
<span class="p">});</span>
<span class="cm">/*</span>
<span class="cm">{</span>
<span class="cm">  &quot;type&quot;: &quot;RootNode&quot;,</span>
<span class="cm">  &quot;children&quot;: [</span>
<span class="cm">    {</span>
<span class="cm">      &quot;type&quot;: &quot;ParagraphNode&quot;,</span>
<span class="cm">      &quot;children&quot;: [</span>
<span class="cm">        {</span>
<span class="cm">          &quot;type&quot;: &quot;SentenceNode&quot;,</span>
<span class="cm">          &quot;children&quot;: [</span>
<span class="cm">            {</span>
<span class="cm">              &quot;type&quot;: &quot;WordNode&quot;,</span>
<span class="cm">              &quot;children&quot;: [</span>
<span class="cm">                {</span>
<span class="cm">                  &quot;type&quot;: &quot;TextNode&quot;,</span>
<span class="cm">                  &quot;value&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                  &quot;position&quot;: {</span>
<span class="cm">                    &quot;start&quot;: {</span>
<span class="cm">                      &quot;line&quot;: 1,</span>
<span class="cm">                      &quot;column&quot;: 1,</span>
<span class="cm">                      &quot;offset&quot;: 0</span>
<span class="cm">                    },</span>
<span class="cm">                    &quot;end&quot;: {</span>
<span class="cm">                      &quot;line&quot;: 1,</span>
<span class="cm">                      &quot;column&quot;: 5,</span>
<span class="cm">                      &quot;offset&quot;: 4</span>
<span class="cm">                    }</span>
<span class="cm">                  },</span>
<span class="cm">                  &quot;data&quot;: {</span>
<span class="cm">                    &quot;word_id&quot;: 34120,</span>
<span class="cm">                    &quot;word_type&quot;: &quot;KNOWN&quot;,</span>
<span class="cm">                    &quot;word_position&quot;: 1,</span>
<span class="cm">                    &quot;surface_form&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                    &quot;pos&quot;: &quot;感動詞&quot;,</span>
<span class="cm">                    &quot;pos_detail_1&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;pos_detail_2&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;pos_detail_3&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;conjugated_type&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;conjugated_form&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;basic_form&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                    &quot;reading&quot;: &quot;ヨウコソ&quot;,</span>
<span class="cm">                    &quot;pronunciation&quot;: &quot;ヨーコソ&quot;</span>
<span class="cm">                  }</span>
<span class="cm">                }</span>
<span class="cm">              ],</span>
<span class="cm">     ...</span>
<span class="cm">}</span>
<span class="cm">*/</span>
</code></pre></div>
<p>これらのパーサは、あるセンテンスの長さが100文字以下といった単語だけではわからない情報などを扱うのに利用できます。また単語の品詞などの情報もあります。</p>

<h3 id="matcher">Matcher</h3>

<p><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">nlp-pattern-match</a>に含んでいるもう一方はマッチングライブラリです。</p>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>というmatcherは先ほどのパース結果のNodeを使った厳密なマッチをするライブラリです。</p>

<p>タグ関数を使って、厳密にマッチしたい部分だけをNodeとして表現できます。 
次の例では英語の<code>Bob &lt;動詞&gt; it.</code>にマッチする結果を取得できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">PatternMatcher</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-pattern-match&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">EnglishParser</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-english&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">englishParser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EnglishParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">patternMatcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PatternMatcher</span><span class="p">({</span>
    <span class="nx">parser</span><span class="o">:</span> <span class="nx">englishParser</span>
<span class="p">});</span>
<span class="kr">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="nx">patternMatcher</span><span class="p">.</span><span class="nx">tag</span><span class="err">`</span><span class="nx">Bob</span> <span class="nx">$</span><span class="p">{</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
    <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">pos</span><span class="o">:</span> <span class="sr">/^VB/</span> <span class="c1">// verb</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">}</span> <span class="nx">it</span><span class="p">.</span><span class="err">`</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;Bob does it.&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">patternMatcher</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">);</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">result</span><span class="p">]</span> <span class="o">=</span> <span class="nx">results</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">deepEqual</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">index</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">end</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">column</span><span class="o">:</span> <span class="mi">13</span><span class="p">,</span>
        <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">offset</span><span class="o">:</span> <span class="mi">12</span>
    <span class="p">},</span>
    <span class="nx">start</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">column</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">offset</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>はより厳密なマッチをDSL的に書けるようにする趣旨のライブラリでしたが、もっと必要に応じて簡単に書けるライブラリとして<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>があります。</p>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は名前の通り、とりまえず<code>match</code>して、実際にそれが対象なのかを<code>test</code>し、最後に<code>replace</code>するという三段階のライブラリです。
正規表現で処理を書く場合に何でも一発の正規表現でやると難しくなるので、段階に分けてしまえばもっと簡単に書けるのではというコンセプトのライブラリです。</p>

<p>最小のコードは、ほぼ<code>String#replace</code>と同じです。</p>

<blockquote>
<p>Match -&gt; Replace</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/hello/i</span><span class="p">,</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&quot;Hello&quot;</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">,</span> <span class="s2">&quot;should be ok: true&quot;</span><span class="p">);</span>
<span class="c1">// 返り値はコマンドオブジェクト</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;1 replace&quot;</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm">[ { index: 0, match: &#39;Hello&#39;, replace: &#39;Hello&#39;, message: undefined } ]</span>
<span class="cm">*/</span>
</code></pre></div>
<p>少し複雑にして<code>/webkit/i</code>という文字列を<code>WebKit</code>に統一したいという例です。
単純に<code>/webkit/i</code>でマッチすると<code>node-webkit</code>も含まれてしまうため、<code>node-</code>から始まる<code>webkit</code>は除外するというルールを<code>test</code>に追加しています。</p>

<blockquote>
<p>Match -&gt; Test -&gt; Replace</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;webkit is matched,but node-webkit is not match&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/(\S*?)webkit/g</span><span class="p">,</span>
    <span class="nx">test</span><span class="o">:</span> <span class="p">({</span> <span class="nx">captures</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">captures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="s2">&quot;node-&quot;</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&quot;WebKit&quot;</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span> <span class="o">===</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&quot;should be ok: false&quot;</span><span class="p">);</span>
<span class="c1">// 返り値はコマンドオブジェクト</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;no replace&quot;</span><span class="p">);</span>
<span class="c1">// 実際に置換を適応する</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">replaceAll</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">).</span><span class="nx">output</span><span class="p">,</span> <span class="s2">&quot;WebKit is matched,but node-webkit is not match&quot;</span><span class="p">);</span>
</code></pre></div>
<p>先ほどの<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>を組み合わせると、適当にマッチした文字列の品詞をチェックしてから、それが意図した品詞なら置換するという処理が書けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">assert</span> <span class="nx">from</span> <span class="s2">&quot;assert&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">PatternMatcher</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-pattern-match&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">EnglishParser</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-english&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">englishParser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EnglishParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">matcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PatternMatcher</span><span class="p">({</span> <span class="nx">parser</span><span class="o">:</span> <span class="nx">englishParser</span> <span class="p">});</span>
<span class="c1">// https://developers.google.com/style/clause-order</span>
<span class="c1">// NG: Click Delete if you want to delete the entire document.</span>
<span class="c1">// OK: To delete the entire document, click Delete.</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;Click Delete if you want to delete the entire document.&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/Click (\w+) if you want to (.+)./</span><span class="p">,</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">({</span> <span class="nx">captures</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">captures</span><span class="p">);</span>
        <span class="k">return</span> <span class="err">`</span><span class="nx">To</span> <span class="nx">$</span><span class="p">{</span><span class="nx">captures</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span> <span class="nx">click</span> <span class="nx">$</span><span class="p">{</span><span class="nx">captures</span><span class="p">[</span><span class="mi">0</span><span class="p">]}.</span><span class="err">`</span>
    <span class="p">},</span>
    <span class="nx">test</span><span class="o">:</span> <span class="p">({</span> <span class="nx">all</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">tag</span><span class="err">`</span><span class="nx">Click</span> <span class="nx">$</span><span class="p">{</span> <span class="p">{</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;WordNode&quot;</span><span class="p">,</span>
            <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
                <span class="c1">// Verb</span>
                <span class="nx">pos</span><span class="o">:</span> <span class="sr">/^VB/</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="p">}</span><span class="err">`</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">all</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span> <span class="o">===</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&quot;should be ok: true&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">replaceAll</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">).</span><span class="nx">output</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="s2">&quot;To delete the entire document, click Delete.&quot;</span><span class="p">);</span>
</code></pre></div>
<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は大雑把に正規表現でマッチして、testで本当に意図したものかをチェックしてから置換するという工程を書くためのものです。</p>

<p>このアプローチだと結構正規表現の気軽さを持ちつつ必要な部分で詳細な指定ができるため便利です。
一方、今わかってる問題として大雑把に一度マッチするため、後からマッチする範囲を狭めることができない(無駄な範囲をReplaceしてしまう)という問題があります。</p>

<p>いい案がある方はIssueとかPRを待ってます。</p>

<h2 id="ユースケース">ユースケース</h2>

<p>今このライブラリなどを使ってGoogleの<a href="https://developers.google.com/style/" title="About this guide  |  Google Developer Documentation Style Guide  |  Google Developers">Google Developer Documentation Style Guide</a>という開発者向けのドキュメントスタイルガイドを<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールとして実装しています。</p>

<ul>
<li><a href="https://github.com/textlint-rule/textlint-rule-preset-google%22textlint-rule/textlint-rule-preset-google:%20%5BWIP%5D%20Google%20Developer%20Documentation%20Style%20Guide%20for%20textlint.%22">textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.</a></li>
</ul>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>や<a href="https://github.com/finnlp/en-pos" title="en-pos">en-pos</a>を中心に使って実装しています。
感触としては30分~1時間ぐらいで1つのルール(1つのページ)を実装できているので、まあまあ効率的に実装できているかなーと思います。</p>

<p>自分が英文法がよく分かってなかったり、係り受け解析ができない問題、そもそも主観的なルールなどもあるのですべてが実装できるわけではないですが、大雑把にマッチして意図して結果へ置換する処理を書けている感じがします。</p>

<p>興味がある人は<a href="https://github.com/textlint-rule/textlint-rule-preset-google#rules" title="textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.">textlint-rule/textlint-rule-preset-google</a>にPull Request待っています。</p>

<h2 id="おわりに">おわりに</h2>

<p>textlintのルールなどを書くときに使える<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>というライブラリ群について紹介しました。</p>

<p>文字列処理は色々文脈に依存したり、そもそも自然言語は壊れた文字列がエラーにならないなどの問題があるため難しいです。完璧な方法はないため目的にあった方法を使う必要があります。
たとえば、今回作った<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は平面的に文字列マッチするだけなので、文字列を構造として捉えるならば色々不足している感じがします。</p>

<p>これ以外にもセンテンス分解やピリオドの位置チェック、ですます・である調の分析などいろんなライブラリを書いています。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule#global" title="Collection of textlint rule · textlint/textlint Wiki">Collection of textlint rule · textlint/textlint Wiki</a></li>
</ul>

<p>textlintをコマンド一発で作り始めることができる<code>create-textlint-rule</code>というコマンドもあるので、色々作って見ると面白いかもしれません。</p>

<ul>
<li><a href="http://efcl.info/2016/12/14/create-textlint-rule/" title="textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch">textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Alfred上で自分のはてなブックマークを検索できるWorkflow</title>
   <link href="http://efcl.info/2017/10/20/alfred-hatenabookmark/"/>
   <updated>2017-10-20T19:48:00+09:00</updated>
   <id>http://efcl.info/2017/10/20/alfred-hatenabookmark</id>
   <content type="html"><![CDATA[ <p>Alfredで自分のはてブデータを取得して絞り込んで検索できるWorkflowを書きました。</p>

<ul>
<li><a href="https://github.com/azu/alfred-hantebookmark-mydata" title="azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred">azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred</a></li>
</ul>

<p><img src="https://media.giphy.com/media/3ov9k8YySjxOsxvNHW/giphy.gif" alt="screenshot"></p>

<p>このWorkflowはNode.jsでAlfred Workflowを書ける<a href="https://github.com/sindresorhus/alfy" title="alfy">alfy</a>というフレームワークを使っています。
そのため、npmでWorkflowをインストール、更新できます。
(必然的にNode.js環境が必要です)</p>

<h2 id="インストール">インストール</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install --global alfred-hantebookmark-mydata
</code></pre></div>
<h2 id="設定">設定</h2>

<p>どのはてなアカウントのブックマークを検索するかの設定が必要なので、Workflowの設定から<code>HATENA_ACCOUNT_NAME</code>という変数に自分のアカウント名を入れる必要があります。</p>

<ol>
<li>Open workflow settings</li>
<li>Set Your hatena account name to <code>HATENA_ACCOUNT_NAME</code></li>
</ol>

<p><img src="https://monosnap.com/file/cTzt4ieHD2wGDYb2ANoUh5IXeS6SQA.png" alt="setting"></p>

<h2 id="制限">制限</h2>

<p><a href="https://github.com/sindresorhus/alfy" title="alfy">alfy</a>は基本的に一度きりの実行を想定した作りになっているようです。
なので、入力 -&gt; Nodeでスクリプトを実行 -&gt; 結果を表示の一回だけで終わってる感じです。</p>

<p>ほしかったのは、スクリプトを実行 -&gt; 結果をAlfredで絞り込み という感じのものでした。</p>

<p><code>Script Filter</code>の<a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/#alfred-filters-results" title="Match Mode">Match Mode</a>を使うとそれが実現できる(このWorkflowもこれ)のですが、このMatch Modeのフィルタリングは日本語に対応してない感じがします。</p>

<p>境界となる文字列が記号やスペースのみとなっていて、その結果に対して先頭からのマッチのみなので、必然的に日本語だと上手くマッチしない問題があります。形態素解析とかして分解すればいいのですが、処理時間的に現実的じゃない感じがしました。(差分更新、キャッシュを上手く使えばできそうな気がするけど、PR歓迎)</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">自分のはてなブックマークをAlfredから検索してして絞り込むやつ書いた。<br>もっと早く動くようにできないかな?(後マッチングが日本語不安定な気はする)<a href="https://t.co/8z3GzWGzwW">https://t.co/8z3GzWGzwW</a> <a href="https://t.co/DmhYJ8Dh6v">pic.twitter.com/DmhYJ8Dh6v</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/921017924898275328?ref_src=twsrc%5Etfw">October 19, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
 ]]></content>
 </entry>
 
 <entry>
   <title>kuromoji.jsで形態素解析した結果とテキストの関係をビジュアライズする</title>
   <link href="http://efcl.info/2017/10/19/text-map-kuromoji/"/>
   <updated>2017-10-19T09:45:00+09:00</updated>
   <id>http://efcl.info/2017/10/19/text-map-kuromoji</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/azu/text-map-kuromoji">azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ</a>というツールを作った話。</p>

<p><a href="https://ipsj.ixsq.nii.ac.jp/ej/?action=pages_view_main&amp;active_action=repository_view_main_item_detail&amp;item_id=70540&amp;item_no=1&amp;page_id=13&amp;block_id=8" title="くだけた表現を高精度に解析するための正規化ルール自動生成手法">くだけた表現を高精度に解析するための正規化ルール自動生成手法</a>という論文誌では、「ヵゎぃぃ」，「ゎた Uゎ」みたいな普通の形態素解析では未知語として検出されるものをどうやって正規化していくかという話が書かれていました。</p>

<p>これを読んでいて面白かったのは形態素解析をした結果の未知語となった部分と穴埋め的にパターンを作って、そのパターンにマッチする同じようなテキストを探すというアプローチでした。</p>

<p>プログラミング言語と違って、大抵の自然言語パーサはパース失敗ではなく、単なる未知な言葉として検出されます。
また、その未知な言葉は常に増えていて、さきほどの<a href="https://ipsj.ixsq.nii.ac.jp/ej/?action=pages_view_main&amp;active_action=repository_view_main_item_detail&amp;item_id=70540&amp;item_no=1&amp;page_id=13&amp;block_id=8" title="くだけた表現を高精度に解析するための正規化ルール自動生成手法">くだけた表現を高精度に解析するための正規化ルール自動生成手法</a>によると手動では登録できない増加量らしいです。</p>

<blockquote>
<p>著者らの経験では，1 人月あたり約 3 万種類の未知語登録が可 能であるのに対し，ブログ 600 万文を著名な形態素解析器 MeCab 3) を用いて解析したと ころ，約 65 万種類の未知語が検出されたことから，ブログ文書のくだけた表現を正しく解 析することは困難といえる.</p>
</blockquote>

<p>この辺のスラング的な単語もクローリングしたデータから辞書を作ることで扱える量が多い辞書として<a href="https://github.com/neologd/mecab-ipadic-neologd" title="mecab-ipadic-NEologd">mecab-ipadic-NEologd</a>が有名です。</p>

<p>で、話を戻して形態素解析をした結果の未知語となるパターンってどれぐらいあるのかなーと思いました。
普通に形態素解析した結果を見ればいいのですが、それは品詞付きの情報が並ぶだけだったり、JSONだったりして、テキストのこの部分が未知語というのがあまり見やすくはありませんでした。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">今日もしないとね。
今日    名詞,副詞可能,*,*,*,*,今日,キョウ,キョー
も      助詞,係助詞,*,*,*,*,も,モ,モ
し      動詞,自立,*,*,サ変・スル,未然形,する,シ,シ
ない    助動詞,*,*,*,特殊・ナイ,基本形,ない,ナイ,ナイ
と      助詞,接続助詞,*,*,*,*,と,ト,ト
ね      助詞,終助詞,*,*,*,*,ね,ネ,ネ
。      記号,句点,*,*,*,*,。,。,。
</code></pre></div>
<p>入力されたテキストと特定の位置に関する情報をビジュアライズするパターンについてはSourceMapを調べていたときに<a href="http://sokra.github.io/source-map-visualization/" title="source-map-visualization">source-map-visualization</a>というサイトがあるのを思い出しました。</p>

<p><a href="http://sokra.github.io/source-map-visualization/"><img src="http://efcl.info/wp-content/uploads/2017/10/19-1508374636.png" alt="sourcemap"></a></p>

<ul>
<li><a href="http://efcl.info/2014/0622/res3933/" title="Source Mapを扱う関連ライブラリのまとめ | Web Scratch">Source Mapを扱う関連ライブラリのまとめ | Web Scratch</a></li>
</ul>

<p>これの形態素解析版があると良さそうと思いました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これの形態素解析版ほしいな  &quot;source-map-visualization&quot;  <a href="https://t.co/PZuGwXdYIQ">https://t.co/PZuGwXdYIQ</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920646507254050822?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>ここで、既にJavaScriptとそのパース結果からECMAScriptのバージョンをToken毎に割り出すツールを作ってたのを思い出しました。</p>

<p><a href="https://azu.github.io/ecmascript-version-detector/"><img src="http://efcl.info/wp-content/uploads/2016/08/04-1470309082.png" alt="image"></a></p>

<ul>
<li><a href="http://efcl.info/2016/08/04/ecmascript-version-detector/" title="そのコードが標準化されてるJavaScriptなのかを判定する方法 | Web Scratch">そのコードが標準化されてるJavaScriptなのかを判定する方法 | Web Scratch</a></li>
</ul>

<p>これをforkして<a href="https://github.com/takuyaa/kuromoji.js#api" title="kuromoji.js">kuromoji.js</a>で形態素解析してその結果をビジュアライズするものを作りました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://t.co/zypZDjn20j">https://t.co/zypZDjn20j</a><a href="https://t.co/UOhjzSxMhI">https://t.co/UOhjzSxMhI</a><br><br>kuromojiで形態素解析した結果をビジュアライズするやつできた。<br>テキストをクリックすると対応した位置のトークン情報が表示される。 <a href="https://t.co/AqrbhMJFBm">pic.twitter.com/AqrbhMJFBm</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920676180797173762?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li>サイト: <a href="https://azu.github.io/text-map-kuromoji/">text-map-kuromoji</a></li>
<li>ソースコード:<a href="https://github.com/azu/text-map-kuromoji">azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ</a></li>
</ul>

<p>それで目的だった壊れた日本語は未知語として検出されるのかを確かめてみましたが、てにをはを間違えただけとかその程度だとやっぱり未知語として検出されないということがわかりました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">日本語の文章ってやっぱり普通に書くと未知語が結構出にくいっぽい気がする。<br><br>変換ミスだとアルファベットが混ざってくるので未知語 = 壊れた文章の検出ができる可能性はありそう。<br>壊れた日本語は検出するの難しいかもなー。パースが失敗しない問題 <a href="https://t.co/EhpmHv34LD">pic.twitter.com/EhpmHv34LD</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920678011141201920?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>一方、ローマ字入力のIME特有のtypoはアルファベットが不自然に混ざるからか未知な言葉として検出されやすくかったです(論文誌の形状が似てる言葉もこういうタイプ)</p>

<ul>
<li><a href="https://github.com/textlint-ja/textlint-rule-ja-unnatural-alphabet" title="textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール">textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール</a></li>
</ul>

<p>やっぱり形態素解析に失敗するパーサの必要性を感じました。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>Clean ArchitectureとBuilding Evolutionary Architecturesを読んだ</title>
   <link href="http://efcl.info/2017/10/09/clean-architecture-and-building-evolutionary-architectures/"/>
   <updated>2017-10-09T23:27:00+09:00</updated>
   <id>http://efcl.info/2017/10/09/clean-architecture-and-building-evolutionary-architectures</id>
   <content type="html"><![CDATA[ <p><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture</a>という本と<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>という本を最近読んだのでざっくりとしたメモ。（両方共2-3時間ぐらいでざっくりとしか読んでないので、解釈間違いは普通にありそうです）</p>

<p>両方共アーキテクチャに対するメタ的な視点な部分があるので、合わせて読むと面白いかも。</p>

<h2 id="clean-architecture">Clean Architecture</h2>

<p>Clean Architecture(Clean Codeの人のシリーズ)という本を読んだ。</p>

<ul>
<li><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture: A Craftsman&#39;s Guide to Software Structure and Design | InformIT</a>

<ul>
<li>PDFとかEpubとかMobiが買える</li>
</ul></li>
</ul>

<p><a href="https://www.amazon.com/Robert-C.-Martin/e/B000APG87E/ref=dp_byline_cont_book_1" title="Robert C. Martin">Robert C. Martin</a>の<code>Clean *</code>シリーズでいわゆる<a href="http://blog.tai2.net/the_clean_architecture.html" title="クリーンアーキテクチャ">クリーンアーキテクチャ</a>そのものだけを扱ったという内容ではない。</p>

<p>でもクリーンアーキテクチャについて紹介してる章もある。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a> Clean ArchitectureがClean Architectureについて書いてる章があった… <a href="https://t.co/75EB3FW4U3">pic.twitter.com/75EB3FW4U3</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912128410343768064?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アーキテクチャのルール自体はシステム/アプリケーションのサイズにかかわらずいつも同じという話。
これはアーキテクチャのメタ的な感じっぽい。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a> シングルスレッドのアプリ、マルチスレッドのアプリ、重量プロセスのアプリ、軽量プロセスのアプリ色々作ってきたけどアーキテクチャのルールはいつも同じ<br><br>&gt; The architecture rules are the same!</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912117809714307072?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>そもそもの話としてアーキテクチャを決めるのはプログラマ（アーキテクト）で、その人のスキルとかチームによって異なる選択をしてる。なので、暗黙的に、異なるチームでは異なるアーキテクチャの決定をする。</p>

<p>アーキテクチャの目的は開発、デプロイ、運用、メンテをやりやすくするため。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a>  良いアーキテクチャがサポートすべきもの <a href="https://t.co/xp1upNzbO5">pic.twitter.com/xp1upNzbO5</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912124439344562176?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アーキテクトは境界を見つけることが仕事で、そのboundariesの線を引くこと。
境界はDBとかテストとかアプリケーションとかcontextとか色々なところにある。
それを気をつけて認識しないといけない。また同時に認識した境界を無視しなければならない。
なぜなら、すべてを実装するのはコストが高いため。</p>

<p>後は境界を引いた上でそれぞれのコンポーネントを結合するプラグインの仕組みなどについて。
フレームワークをコードに入れるのではなく、コードに対してフレームワークというコンポーネントをプラグインとして入れるようにするとか。</p>

<blockquote>
<p>Don’t marry the framework!</p>
</blockquote>

<p>境界をちゃんとして、依存関係をちゃんとしよう的な話が多かった。</p>

<h2 id="building-evolutionary-architectures">Building Evolutionary Architectures</h2>

<p>Building Evolutionary ArchitecturesというEvolutionary Architectures(進化的アーキテクチャ)についての本を読んだ。</p>

<ul>
<li><a href="https://www.thoughtworks.com/books/building-evolutionary-architectures" title="Building Evolutionary Architectures | ThoughtWorks">Building Evolutionary Architectures | ThoughtWorks</a></li>
<li><a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books</a></li>
</ul>

<p>ThoughtWorksの人達が書いた本なので、アーキテクチャに対するメタ的な目線が多かった。</p>

<p>そもそも、Evolutionary Architectures(進化的アーキテクチャ)とは何かという話や進化的アーキテクチャというのは何を目的にしているか。(adaptable Architectureと言わなかったのはなぜかなど?)</p>

<blockquote class="twitter-tweet" data-partner="tweetdeck"><p lang="en" dir="ltr">Why Evolutionary? <a href="https://t.co/dhWQIhUg4k">pic.twitter.com/dhWQIhUg4k</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917406155374157824?ref_src=twsrc%5Etfw">October 9, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>進化的アーキテクチャは次の3つのポイントが主になってる的な話。</p>

<ul>
<li>Incremental change</li>
<li>Guided change with fitness functions</li>
<li>Appropriate coupling</li>
</ul>

<p>継続的に変更すること(Incremental change)ができ、その変更/進化が目的の方向なのかをチェックできる指標をちゃんと持つこと(Guided change with fitness functions)。
つまりアーキテクチャを選ぶことが目的でなく、Fitness functionとなる指標がありそれに対するアーキテクチャを選べているかを確認できるようにすることが目的。</p>

<p>ある変化に対してその変化が目的に沿ったものだったかを計測できる指標のことをfitness functionと言っているという理解。</p>

<blockquote>
<p>A fitness function is a particular type of objective function that is used to summarise, as a single figure of merit, how close a given design solution is to achieving the set aims.</p>
</blockquote>

<p>元ネタは<a href="https://en.wikipedia.org/wiki/Fitness_function" title="Fitness function - Wikipedia">Fitness function - Wikipedia</a>とのこと。</p>

<p>でてくる用語が抽象的なので次の動画も見たほうが分かりやすいかも。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/SzSZpZI02Jg" frameborder="0" allowfullscreen></iframe>

<p>そのため、何がFitness functionなのかは、作るシステム/アプリケーションによって異なる。
あるシステムではパフォーマンスやセキュリティが大事だったり、作るものによって異なる = 進化の方向はアプリケーションで異なる。</p>

<p>テストとかパフォーマンスとかそれぞれコンポーネント毎にfitness functionがあり、システム全体でのバランスを検証する。
スケーラビリティとか、パフォーマンス、セキュリティとかデータスキーマとかプロジェクトにおける指標となるものをちゃんと決めてないと、都度の変化はただの反応的な変化(reactionary architecture)となるので、最初にシステム全体として進化の指標を決めることは大事という話。
つまり、正しい方向を向いてるかどうかという指標はちゃんと決めないと、正しさが分からずに問題となるよという話だと思う。</p>

<p>その指標が決まっているだけでは継続的な進化はできないので、Incremental changeをするためには継続的インテグレーション(CI)と継続的デリバリー(CD)といったリリースサイクルに関わるもの大事という話が結構でてきた。(また、このデプロイの頻度とかは物理的なものとデジタル的なもので異なるという話とか。)</p>

<p>リリースサイクルの例としてGitHubとかの例がでてきた。</p>

<ul>
<li><a href="https://githubengineering.com/move-fast/" title="Move Fast and Fix Things | GitHub Engineering">Move Fast and Fix Things | GitHub Engineering</a></li>
</ul>

<p>なんでリリースサイクルが大事かというとリリース速度と進化的アーキテクチャに相関が存在する。
つまりプロジェクトのサイクルタイムによってアーキテクチャの進化速度が決まり、より早いサイクルはより早い進化を促すことができるため。</p>

<p>継続的にデプロイするには、そのシステムがモジュール化されていることが大事。
そのモジュール化を行う方法?としていろんなアーキテクチャがあるよという、既存のいろんなアーキテクチャ紹介(モノリシック、レイヤードアーキテクチャ、<a href="https://en.wikipedia.org/wiki/Event-driven_architecture" title="Event-driven architecture">Event-driven architecture</a>、serverlessとか)</p>

<p>けど</p>

<blockquote>
<p>Don’t build an architecture just because it will be fun meta-work.</p>
</blockquote>

<p>だよという話。</p>

<hr>

<p>アーキテクチャの対義語(アンチパターン)として泥団子(<a href="https://ja.wikipedia.org/wiki/%E5%A4%A7%E3%81%8D%E3%81%AA%E6%B3%A5%E3%81%A0%E3%82%93%E3%81%94" title="Big ball of mud">Big ball of mud</a>)の話。
基本的に泥団子は進化することができないので、新しい変化を取り込むことができない。
いくかの柔軟性を取り込んでいくことでアーキテクチャ全体を変更せずに、取り入れることができる。</p>

<p>柔軟性についてでどういうものがあるかという話。</p>

<ul>
<li>必要ない変数を取り除く

<ul>
<li>Immutabilityを取り入れる</li>
<li>Immutable infrastructureは必要ない変数を取り除く</li>
</ul></li>
<li>決定を可逆にする

<ul>
<li>Make Decisions Reversible</li>
<li>Revertable、 blue/green deployment</li>
</ul></li>
<li>Prefer Evolvable over Predictable</li>
<li>Build Anticorruption Layers

<ul>
<li>腐敗防止を設ける</li>
</ul></li>
<li>Mitigate External Change

<ul>
<li>外部ライブラリの変更の影響を小さく保つ</li>
<li>left-padの教訓</li>
</ul></li>
<li>Updating Libraries Versus Frameworks

<ul>
<li>アーキテクトはライブラリとフレームワークを区別する</li>
<li>開発者のコードがライブラリを呼び出す</li>
<li>フレームワークは開発者のコードを呼び出す</li>
<li>多くの場合はライブラリを選ぶことで影響が軽減される</li>
<li>フレームワークは積極的に依存を更新する(セキュリティアップデート)</li>
<li>ライブラリは必要になったら更新する(update when neededモデル)</li>
</ul></li>
<li>Prefer Continuous Delivery to Snapshots

<ul>
<li>The conflict between Continuous Delivery and traditional Agile - kief.com</li>
<li>-LATESTみたいなスナップショットじゃなくてタグ切って管理</li>
</ul></li>
<li>これはMake Decisions Reversibleとも繋がる(revert可能にする)

<ul>
<li>Prefer Continuous Delivery over snapshots for (external) dependencies.</li>
<li>継続的デプロイができる環境では外部依存についての考えかたも変える</li>
<li>2つの指標を導入する</li>
<li>fluid

<ul>
<li>自動的に依存を更新する</li>
</ul></li>
<li>guarded

<ul>
<li>固定 -&gt; fluidに戻すように修正する</li>
</ul></li>
</ul></li>
<li>Version Services Internally

<ul>
<li>一度に管理するサービスのエンドポイントのバージョンは2つまで</li>
</ul></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">left-padだ <a href="https://t.co/JctKbVAVfH">pic.twitter.com/JctKbVAVfH</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917040368339755008?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>外部モジュールのバージョン管理の話が結構面白かった。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ライブラリとフレームワークの区別について<br>開発者のコードがライブラリを呼び出す。一方、フレームワークは開発者のコードを呼び出す。<br>多くの場合はライブラリを選ぶことで影響が軽減される。<br><br>フレームワークのアップデートは積極的に行い、ライブラリのアップデートは必要になったら行う。</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917041667881893889?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>つまり、フレームワークは自分が制御するわけではないので、アップデートは積極的に行わないと進化できなくなる可能性がある。一方ライブラリは必要になったタイミングで更新すればいいという話。</p>

<p>またフレームワークに関するアンチパターンとしてLast 10%という話があった。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">Antipattern: Last 10% Trap<br>- あるフレームワークで要求の80%が実現できることが確認できていた<br>- ハックをつかって10%+できた<br>- しかし最後の10%が無理で要求を満たせなかったので、フレームワークを使うのをやめる</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917045990917468161?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<hr>

<p>泥団子から進化することはできないのでどうやって分解するかという話。</p>

<p>泥団子を進化させることはできない。(本で ball of mud は結構出てくる)
泥団子を再加工するコストが莫大なものとなる。これを変質させる方法の第一歩はモジュール化。
最初に行うべき作業は現在のシステムからモジュールの発見すること。</p>

<p>ここでも境界を見つける話や泥団子からのマイグレーション方法についてなど。
モジュールへ分解していくのだけど、安易に分解するとパフォーマンスが問題になることがあるよとか、分解した結果複数のモジュールが共有してる共有モジュールはどうするの?とか。</p>

<p>どうにかして境界を見つけて分解することができたら、取捨選択のステップへ。ここでも指標となるFitness functionがでてくる。</p>

<blockquote>
<p>Next, developers choose and detach the chosen service from the monolith, fixingany calling points. Fitness functions play a critical role here — developersshould build fitness functions to make sure the newly introduced integrationpoints don’t change, and add consumer-driven contracts.</p>
</blockquote>

<hr>

<p>またIncremental changeの話に戻って</p>

<p>サイクルタイムはビジネスメトリクスであるという話。ならなぜ、短い時間で繰り返せるということはコストが小さくなるということ。最小のコストで試すことができる。
このサイクルタイムを短くするにはいろいろ自動化が必要になるという話。</p>

<p>変化のリスクを小さくするのが進化的アーキテクチャの考え方。
その変化において大きなBreaking Changeを減らす/なくしIncremental changeできるようにする。
それによって、新しいものを取り入れる余地を作る。</p>

<p>雑に進化的アーキテクチャとは何かというと</p>

<ul>
<li>予測可能性より進化性</li>
<li>進化のリスクを小さくする(痛みを伴うBreaking Changeなしに進化)</li>
<li>依存するライブラリとフレームワークの管理とリスクを考えて意思決定をする</li>
<li>可逆性を持つ決定を取り入れる</li>
<li>腐敗防止層を設ける</li>
<li>進化の速度とリリースサイクルには相関がある

<ul>
<li>短い時間で繰り返せるということは、試すコストが小さい</li>
<li>プロジェクトのサイクルタイムによってアーキテクチャの進化速度が決まる</li>
</ul></li>
<li>泥団子は進化することができないので、柔軟性のポイントを取り入れる</li>
<li>目的に対する成長なのかを計測する(そのため実装の詳細を無視してはいけない)</li>
</ul>

<p>アーキテクチャは方程式ではなく、進行中のプロセスのスナップショットにすぎないという話。</p>

<hr>

<p>読み終わってそういえば<a href="http://bliki-ja.github.io/SacrificialArchitecture/" title="犠牲的アーキテクチャ">犠牲的アーキテクチャ</a>というものが同じくThoughtWorksのMartin Fowlerさんが言っていたのを思い出した。
進化的アーキテクチャはより緩やか/より前進的な犠牲的アーキテクチャと言えるのかもしれないなーとか思った。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">最近聞かなくなった気もするけど犠牲的アーキテクチャの話も少しでてきてた気がする。<br>進化的アーキテクチャは緩やかな犠牲的アーキテクチャと言えるのかもしれない<a href="https://t.co/FckZSanZai">https://t.co/FckZSanZai</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917070245768028161?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="おわり">おわり</h2>

<p><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture</a>と<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>を読んでの雑なメモ書き。</p>

<p>両方共、アーキテクチャとは境界を見つけることという話や異なるチーム異なるシステムでは異なるアーキテクチャがあるよという話をしてたのが良かった。</p>

<p>あとはアーキテクチャ選び遊びは楽しいけど、目的にあってないアーキテクチャを選ぶアーキテクチャシンドロームにかかってはいけないという話も共通してた気がする。</p>

<blockquote>
<p>Don’t build an architecture just because it will be fun meta-work.</p>
</blockquote>

<p>どちらの本も読んで何か実践的な何かを学べるタイプのものではないので、その辺を見たい場合は別の本を見たほうが良さそう。</p>

<ul>
<li><a href="https://www.gitbook.com/book/delftswa/desosa-2017/details" title="Delft Students on Software Architecture: DESOSA 2017 · GitBook">Delft Students on Software Architecture: DESOSA 2017 · GitBook</a></li>
<li><a href="http://ec.nikkeibp.co.jp/item/books/P98480.html" title=".NETのエンタープライズアプリケーションアーキテクチャ">.NETのエンタープライズアプリケーションアーキテクチャ</a></li>
<li><a href="https://www.amazon.com/dp/1118714709/" title="Patterns, Principles, and Practices of Domain-Driven Design: Scott Millett, Nick Tune: 0787721845461: Amazon.com: Books">Patterns, Principles, and Practices of Domain-Driven Design: Scott Millett, Nick Tune: 0787721845461: Amazon.com: Books</a>

<ul>
<li><a href="http://efcl.info/2016/09/30/architecture-refs/" title="アーキテクチャをめぐるたび | Web Scratch">アーキテクチャをめぐるたび | Web Scratch</a></li>
</ul></li>
</ul>

<p>どちらかというと次のものに近い方向だけど、もう少し技術よりなので短い時間で読みやすい。</p>

<ul>
<li><a href="https://www.amazon.co.jp/dp/B00ZF44J0I/" title="ソフトウェアシステムアーキテクチャ構築の原理">ソフトウェアシステムアーキテクチャ構築の原理</a></li>
<li><a href="https://leanpub.com/livingdocumentation" title="Living Documentation by design, with Domain-Driven Design">Living Documentation by design, with Domain-Driven Design</a>

<ul>
<li><a href="http://efcl.info/2017/05/12/Living-Documentation-DDD/" title="Living Documentation by design, with Domain-Driven Designを読んだ | Web Scratch">Living Documentation by design, with Domain-Driven Designを読んだ | Web Scratch</a></li>
</ul></li>
</ul>

<p>感想の量からもわかるように<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>は結構面白かった。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように</title>
   <link href="http://efcl.info/2017/09/20/almin-performance-profile-0.14.0/"/>
   <updated>2017-09-20T10:07:00+09:00</updated>
   <id>http://efcl.info/2017/09/20/almin-performance-profile-0.14.0</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/almin/almin"><img src="https://almin.github.io/media/logo/logo.png" alt="Almin.js"></a></p>

<p><a href="https://github.com/almin/almin" title="Almin">Almin</a>はClient-side DDD/CQRSをしやすい構造を作ることを目的にした – いわゆるステート管理ライブラリです。</p>

<p><a href="https://github.com/almin/almin/releases/tag/almin%400.14.0" title="almin@0.14.0">Almin 0.14.0</a>で<code>performance.mark</code>ベースのプロファイルを取れるようになりました。
これにより、AlminのUseCaseやStoreといったそれぞれの処理にどれぐらいかかっているかを開発者ツールのタイムラインで見ることができます。</p>

<p><a href="https://github.com/almin/almin/releases/tag/almin%400.14.0"><img src="http://efcl.info/wp-content/uploads/2017/09/20-1505888631.png" alt="DevTool timeline"></a></p>

<p><code>performance.mark</code>は<a href="https://w3c.github.io/user-timing/" title="User Timing Level 2">User Timing Level 2</a>で標準化されている方法なので、後述するようにReactやVueなどのライブラリと組み合わせた状態も見ることができます。
<code>performance.mark</code>については次の記事でも書いています。</p>

<ul>
<li><a href="http://efcl.info/2016/08/15/performance.mark/" title="performance.markでパフォーマンス計測する | Web Scratch">performance.markでパフォーマンス計測する | Web Scratch</a></li>
</ul>

<h2 id="使い方">使い方</h2>

<p>Contextを作成する際に<code>performanceProfile</code>オプションを有効にするだけです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">appContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Context</span><span class="p">({</span>
    <span class="nx">dispatcher</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Dispatcher</span><span class="p">(),</span>
    <span class="nx">store</span><span class="o">:</span> <span class="nx">yourStoreGroup</span><span class="p">,</span>
    <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">strict</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">performanceProfile</span><span class="o">:</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>このオプションを有効にした状態で実際のウェブサイトにアクセスして、次のステップでみることができます。</p>

<ol>
<li><code>performanceProfile</code>オプションを有効化</li>
<li>ウェブサイトを開く</li>
<li>開発者ツールの&quot;Performance&quot;タブを開き<strong>Record</strong>を押す

<ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool">Chrome&#39;s Timeline Tool document</a>や<a href="https://docs.microsoft.com/en-us/microsoft-edge/f12-devtools-guide/performance" title="F12 devtools guide - Performance - Microsoft Edge Development | Microsoft Docs">MSEdge&#39;s F12 devtools guide</a>を参考に</li>
</ul></li>
<li><strong>Record</strong>を停止する</li>
<li><strong>User Timing</strong>というラベルにAlminのイベントが表示される</li>
</ol>

<p>実際にパフォーマンスプロファイルをタイムラインで見ている様子です。</p>

<blockquote class="twitter-video" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/almin?src=hash">#almin</a> + <a href="https://twitter.com/hashtag/react?src=hash">#react</a> easy to profile web app with devTool&#39;s timeline.<a href="https://t.co/HLndVyS4hI">https://t.co/HLndVyS4hI</a> <a href="https://t.co/d7l2c2pP1K">pic.twitter.com/d7l2c2pP1K</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/909418278153478144">September 17, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>この動画ではReactの<a href="https://facebook.github.io/react/docs/optimizing-performance.html" title="?react_perf">?react_perf</a>と組み合わせたものをタイムライン表示しています。</p>

<p>動かしているサンプルはショッピングカートのコードです。</p>

<ul>
<li><a href="https://github.com/almin/almin/tree/master/examples/shopping-cart" title="almin/examples/shopping-cart at master · almin/almin">almin/examples/shopping-cart at master · almin/almin</a></li>
</ul>

<h2 id="vue-almin">Vue + Almin</h2>

<p>ReactだけではなくVueも<code>performance.mark</code>ベースの<a href="https://vuejs.org/v2/api/#performance">パフォーマンスオプション</a>をサポートしています。</p>

<p>Vue + Alminで書いたサンプルを作ったので、次のリポジトリで試すことができます。</p>

<ul>
<li><a href="https://github.com/azu/vue-almin-counter-example" title="azu/vue-almin-counter-example: Vue + Almin counter example">azu/vue-almin-counter-example: Vue + Almin counter example</a></li>
</ul>

<p><img src="https://cdn.rawgit.com/azu/vue-almin-counter-example/master/img/performance-timeline.gif" alt="Vue + Almin"></p>

<p>VueのパフォーマンスプロファイルはVueによるViewの更新(<code>render</code>や<code>patch</code>)に関する情報がタイムラインにでます。
Alminのパフォーマンスプロファイルは、UseCaseの実行、StoreGroup/Storeの更新、StoreからのState取得に関する情報がタイムラインにでます。</p>

<p>Alminが現在サポートしているメトリクスについては次のドキュメントで公開しています。</p>

<p><a href="https://almin.js.org/docs/tips/performance-profile.html"><img src="http://efcl.info/wp-content/uploads/2017/09/20-1505887064.png" alt="Metrics"></a></p>

<ul>
<li><a href="https://almin.js.org/docs/tips/performance-profile.html" title="Performance profile · Almin.js">Performance profile · Almin.js</a></li>
</ul>

<p>このVue + Alminのサンプルプロジェクトは、Vue + Vuexで書いたものをAlminに変換して作ったので、そのときはDiffは次のPull Requestで見ることができます。</p>

<ul>
<li><a href="https://github.com/azu/vue-almin-counter-example/pull/1" title="Almin + Vue performance profile by azu · Pull Request #1 · azu/vue-almin-counter-example">Almin + Vue performance profile by azu · Pull Request #1 · azu/vue-almin-counter-example</a></li>
</ul>

<h2 id="おわりに">おわりに</h2>

<p>Reactの<a href="https://facebook.github.io/react/docs/optimizing-performance.html" title="?react_perf">?react_perf</a>のように、<code>?almin_perf</code>をクエリに付けた時だけプロファイルを取りたい場合は次のように設定すればできます。</p>

<p>またパフォーマンスプロファイルのコードは、オプション値関係なくproductionビルドすると消えるようになっています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// ?almin_perf をつけるとプロファイルが取れる</span>
<span class="kr">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Context</span><span class="p">({</span>
    <span class="nx">dispatcher</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Dispatcher</span><span class="p">(),</span>
    <span class="nx">store</span><span class="o">:</span> <span class="k">new</span> <span class="nx">StoreGroup</span><span class="p">({</span>
        <span class="nx">counter</span><span class="o">:</span> <span class="k">new</span> <span class="nx">CounterStore</span><span class="p">()</span>
    <span class="p">}),</span>
    <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">strict</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">performanceProfile</span><span class="o">:</span> <span class="sr">/[?&amp;]almin_perf\b/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Alminはロガーなどを外部実装するための<a href="https://almin.js.org/docs/tips/usecase-lifecycle.html" title="life-cycle events">ライフサイクルイベント</a>のAPIも公開しています。
<a href="https://www.npmjs.com/package/almin-logger" title="almin-logger">almin-logger</a>や<a href="https://github.com/almin/almin-devtools" title="almin-devtools">almin-devtools</a>はこちらを使っていますが、それとは別にオプションを追加したのはパフォーマンスプロファイルはAlmin内部的な状態を出す可能性があるからです。
そのため、Publicなものはライフサイクルイベントとして、内部的な状態のダンプデータは<code>performanceProfile</code>のみで出すようにしています。</p>

<p>Alminのパフォーマンスプロファイルについて詳しくは次のドキュメントに書いています。</p>

<ul>
<li><a href="https://almin.js.org/docs/tips/performance-profile.html" title="Performance profile · Almin.js">Performance profile · Almin.js</a></li>
<li><a href="https://almin.js.org/docs/tips/usecase-lifecycle.html" title="LifeCycle of UseCase · Almin.js">LifeCycle of UseCase · Almin.js</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>pwa_study アウトラインメモ</title>
   <link href="http://efcl.info/2017/09/14/pwa_study/"/>
   <updated>2017-09-14T21:27:00+09:00</updated>
   <id>http://efcl.info/2017/09/14/pwa_study</id>
   <content type="html"><![CDATA[ <p><a href="https://web-study.connpass.com/event/65267/" title="pwa_study - connpass">pwa_study - connpass</a>に参加してきたのでメモ。</p>

<h2 id="用語">用語</h2>

<ul>
<li>SW = Service Worker</li>
<li>XSS = cross site scripting</li>
<li>Fetch = Fetch API</li>
</ul>

<h2 id="ウェルカムlt">ウェルカムLT</h2>

<ul>
<li>クライアントサイドDDDが行われるようになってきた</li>
<li>クライアントサイドにロジックが寄ってきてる

<ul>
<li>難しい</li>
</ul></li>
<li>Service Workerもクライアントサイドにそういうロジックや仕組みがよってきたという現象の一つなのでは</li>
</ul>

<h2 id="service-worker-lifecycle-laco">Service Worker Lifecycle  - laco</h2>

<blockquote>
<p>スライド: <a href="http://slides.com/laco/2017-09-14_sw-lifecycle#/" title="Service Worker Lifecycle by Suguru Inatomi">Service Worker Lifecycle by Suguru Inatomi</a></p>
</blockquote>

<ul>
<li>SWのライフサイクル</li>
<li><a href="https://developers.google.com/web/fundamentals/instant-and-offline/service-worker/lifecycle?hl=ja" title="Service Worker のライフサイクル  |  Web  |  Google Developers">Service Worker のライフサイクル  |  Web  |  Google Developers</a> これよめば大体分かる</li>
<li>スライド -&gt; 記事読むと良い</li>
<li>register -&gt; redundantで死ぬ

<ul>
<li>ライフサイクルであるけど一方向</li>
</ul></li>
<li>SWの目的

<ul>
<li>オフラインファースト</li>
<li>セーフマイグレーション</li>
<li>consitency(SWないとタブごとに異なる感じになってしまう。SWは1つのアプリケーションに対して1つ)</li>
</ul></li>
<li>Window-side API

<ul>
<li>Workerを使う側</li>
<li>SWを登録する <code>register</code></li>
<li>SWを更新する <code>update</code> </li>
<li>SWを停止する <code>unregister</code></li>
</ul></li>
<li>Install SW

<ul>
<li><code>register</code>が終わった段階ではSWはまだコントールできない

<ul>
<li><code>active</code> ではある</li>
</ul></li>
<li>リロードした後 コントロール できる状態になる</li>
<li><code>register</code>した段階ではfetchなどをhookすることができない</li>
</ul></li>
<li>なぜこのような仕様になっているか

<ul>
<li>SWのconsitency</li>
<li>タブ間での一貫性を保証する</li>
<li>あるタブだけSWがコントロールできてない状態を作らない</li>
</ul></li>
<li>抜け道がある

<ul>
<li><code>clients.claim()</code> </li>
<li>すぐにコントール状態にできる</li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Clients/claim" title="Clients.claim() - Web API インターフェイス | MDN">Clients.claim() - Web API インターフェイス | MDN</a></li>
<li>claim*<em>s</em>*もある</li>
<li>一貫性を求めるので 

<ul>
<li>やらない or すべてやる(すべてのタブに対してやる)</li>
</ul></li>
</ul></li>
<li>Update SW

<ul>
<li>取ってきたsw.jsとdiffをとって、hash値が異なるなら新しいworkerとして作られる</li>
<li>ハッシュが異なるときは、waitingになる = コントールはできない状態</li>
<li>全部のタブのSWが新しくなったらコントール状態になる = waiting解除</li>
</ul></li>
<li>これも抜け道がある

<ul>
<li><code>skipWaiting()</code></li>
<li>waiting時に<code>skipWaiting()</code>するとすぐにactivateになる</li>
<li>Warning: 裏で動いているWorkerがリロードなしにすり替わる</li>
</ul></li>
<li>ユースケース

<ul>
<li><code>clients.claim()</code>

<ul>
<li>最初からSWを有効化できる</li>
</ul></li>
<li><code>clients.skipWaiting()</code>

<ul>
<li>壊れたsw.jsをデプロイしてしまって、そのバグを修正したバージョンを出す時</li>
<li><code>postMessage</code>とかを使ってwindowからHot Updateみたいなことをやるとき</li>
</ul></li>
</ul></li>
<li>active vs. controller

<ul>
<li>window-side

<ul>
<li>controllerがあるかどうか</li>
</ul></li>
<li>worker

<ul>
<li>worker stateだけを見てる</li>
</ul></li>
<li>controllerであるworker === activeであるworker</li>
</ul></li>
<li>まとめ

<ul>
<li><code>register</code>だけではSWはcontrollにならない</li>
<li>すべてのタブが閉じないとSWはcontrollにならない</li>
<li>claimですぐに取ることはできるけど</li>
<li>skipWaitingは気をつけて使いましょう</li>
</ul></li>
<li>FAQ

<ul>
<li>redundantしたときすぐregisterすると死んだと思ったworkerが復活する</li>
<li>active かつ un-controllerの場合でもmessageは受け取る

<ul>
<li>fetchなどはhandkingできない</li>
</ul></li>
<li><code>clients.skipWaiting()</code>

<ul>
<li>ページがコントールしてるSW、activeなSWが切り替わる</li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2 id="攻撃者視点で見る-service-worker-kinugawamasato">攻撃者視点で見る Service Worker - kinugawamasato</h2>

<blockquote>
<p>スライド: <a href="https://speakerdeck.com/masatokinugawa/pwa-study-sw" title="攻撃者視点で見るService Worker / PWA Study SW // Speaker Deck">攻撃者視点で見るService Worker / PWA Study SW // Speaker Deck</a></p>
</blockquote>

<ul>
<li>SWを使うと攻撃者は何ができるのか

<ul>
<li>SWを登録して攻撃</li>
<li>アプリが使ってるSWを攻撃</li>
</ul></li>
<li>アプリ開発者の防御方法</li>
<li>SWのスクリプトを次の条件を満たす必要がある

<ul>
<li>same origin</li>
<li>secure context</li>
<li>context-typeがJavaScript</li>
</ul></li>
<li>Secure Context

<ul>
<li>HTTPSとかlocalhostなどのコンテキストが限定される</li>
<li>Geo</li>
<li>WebUSB</li>
<li>カメラとか</li>
</ul></li>
<li>Application Cacheは

<ul>
<li>SWの前身のキャッシュ</li>
<li>Secure Contextの実行制限がない</li>
<li><a href="https://html5experts.jp/kyo_ago/5153/" title="攻撃シナリオを使って解説するApplicationCacheのキャッシュポイズニング | HTML5Experts.jp">攻撃シナリオを使って解説するApplicationCacheのキャッシュポイズニング | HTML5Experts.jp</a></li>
<li>Dropboxで公開ページの問題

<ul>
<li>Same origin</li>
<li>クッキーを大量に埋め込むとApp CacheのFallbackが発動して全滅</li>
</ul></li>
</ul></li>
<li>攻撃SWをつかうには

<ul>
<li>HTTPSなページでXSSをみつける</li>
<li>SWのスクリプトになりうる場所をみつける

<ul>
<li>content-type: text/javascript</li>
</ul></li>
</ul></li>
<li>都合のいい場所1: JSONP

<ul>
<li>JSONのsw.jsの内容を書いて</li>
<li>それをregisterで登録する</li>
</ul></li>
<li>登録できるとどうなるか

<ul>
<li>XSSの永続化

<ul>
<li>XSSが修正されても継続する</li>
</ul></li>
<li>リクエスト/レスポンス内容の盗聴・変更</li>
</ul></li>
<li>XSSの永続化</li>
<li>SWのスコープ

<ul>
<li>SWは<code>scope</code>がディレクトリ以下のcontrollできるかを設定できる</li>
<li>Service-Worker-Allowedで設定もできる</li>
<li>サーバの設定によっては <code>%2F</code> のようにエンコードしたパスを登録できないようになってる(仕様で<code>%2f</code>などは禁止されている)</li>
<li><a href="https://www.w3.org/TR/service-workers-1/#navigator-service-worker-register" title="Service Workers 1">Service Workers 1</a></li>
</ul></li>
<li>登録後のスコープ

<ul>
<li><code>/..%2fout%2f</code>と<code>/out/</code>は同一されて、SWは禁止されてない</li>
<li>登録時はかなり厳しくなってる</li>
</ul></li>
<li>SWは前回取得してから24時以上経ってると、SW起動時にHTTPキャッシュを無視して再取得する仕様がある</li>
<li>検証

<ul>
<li>Firefox/Chromeは24時間以上で再取得が起きる</li>
<li>404などで取得できなければ元のSWを使い付ける</li>
<li>不正なSWを登録されることを防ぐ目的であって、永続化を防ぐものにはなってなかった</li>
</ul></li>
<li>XSS x SW x Flash

<ul>
<li>swfのページに直接アクセス + SWで不正なSWFを返す</li>
<li>Flashは crossdomain.xml でクロスドメイン管理されてる</li>
<li>SWで作ったFlashからもcrossdomain.xmlにリストされたサイトの読み取りができる</li>
<li>=&gt; embed仕様では制限すぐべきと書いてあってある

<ul>
<li>embedとかobjectは制限されてる</li>
<li>URLに <a href="http://example.com/attack.swf">http://example.com/attack.swf</a></li>
</ul></li>
</ul></li>
<li>Foreign Fetch

<ul>
<li>外部サイトでXSSができる</li>
<li>夢が広がる危ない仕様だった

<ul>
<li>SWの登録しやすさいに比べて危険</li>
</ul></li>
<li>しかし、Foreign Fetchは廃止予定</li>
<li><a href="https://github.com/w3c/ServiceWorker/issues/1188" title="Remove foreign fetch · Issue #1188 · w3c/ServiceWorker">Remove foreign fetch · Issue #1188 · w3c/ServiceWorker</a></li>
</ul></li>
<li>SWのキャッシュ

<ul>
<li>SWのキャッシュ != HTTPキャッシュ</li>
<li>正規に登録されていたSWを悪用する</li>
<li>fetchされたURLのキャッシュがあれば、キャッシュを常に返すSWがある時</li>
<li>XSSがあれば、キャッシュを汚染して攻撃コードのキャッシュを返すことができる</li>
<li>localStorageのXSSに似てる</li>
</ul></li>
<li>SWを削除する

<ul>
<li>unregister</li>
<li>Clear-Site-Dataで消せる

<ul>
<li><a href="https://github.com/w3c/webappsec-clear-site-data" title="w3c/webappsec-clear-site-data: WebAppSec Clear Site Data">w3c/webappsec-clear-site-data: WebAppSec Clear Site Data</a></li>
</ul></li>
<li>けど、これも一度登録されたそこまで届かない</li>
</ul></li>
<li>SWは登録された負け

<ul>
<li>SWは前回取得してから24時以上経ったときに、404であるならunregisterする仕様になっていれば永続化は避けられて良さそうな気がする</li>
</ul></li>
</ul>

<hr>

<h2 id="foreign-fetch-jxck">Foreign Fetch - jxck</h2>

<ul>
<li>Foreign Fetch

<ul>
<li>オフライン対応をサイト全体をやろうという話なったらサードパーティも全部オフライン対応しないといけない</li>
<li>それはつらい</li>
<li>なので、各サービスがそれぞれオフライン対応のSWを公開してくれて</li>
<li>ファーストパーティは自分のサイトだけ、サードパーティはサードパーティの対応するだけで良くなるという仕様</li>
<li>=&gt; 駄目だった</li>
<li><a href="https://github.com/w3c/ServiceWorker/issues/1188" title="Remove foreign fetch · Issue #1188 · w3c/ServiceWorker">Remove foreign fetch · Issue #1188 · w3c/ServiceWorker</a></li>
</ul></li>
<li>理由: Safariの<a href="https://webkit.org/blog/7675/intelligent-tracking-prevention/" title="Intelligent Tracking Prevention | WebKit">Intelligent Tracking Prevention | WebKit</a>

<ul>
<li>今までクッキー

<ul>
<li>ドメインに紐付いている</li>
</ul></li>
<li>この変更

<ul>
<li>今見てるページとサードパーティのドメインの2つをキーにする</li>
<li>host+3rdparty</li>
<li>つまり見てるページが異なれば、サードパーティが同じでも異なるキーとなる</li>
</ul></li>
</ul></li>
<li>SWの責務分離

<ul>
<li>パスでしか責務を分けれない</li>
</ul></li>
<li>Foreign Fetchは代案がないと死ぬ</li>
</ul>

<hr>

<h2 id="asking-for-sw-motivation-constellation"><a href="https://web-study.connpass.com/event/65267/" title="Asking for SW Motivation: @constellation">Asking for SW Motivation</a> - @constellation</h2>

<ul>
<li>Service Workerに懐疑的

<ul>
<li>ウェブページのライフサイクルを壊す可能性がある</li>
<li>バッテリーを食う可能性がある</li>
</ul></li>
<li>モチベーション

<ul>
<li>ネイティブアプリでは駄目なの?

<ul>
<li>App Storeのディストリビューションの問題?</li>
</ul></li>
<li>Electronみたいなアプリを作る方向ではないの?</li>
<li>アプリケーションでできないことブラウザでできるようになるの?</li>
</ul></li>
<li>議論 色々

<ul>
<li>「ウェブは二回目のエンゲージメントを得るのが難しい。」</li>
<li>「だからPush通知が欲しい」</li>
<li>続きは <a href="https://twitter.com/search?q=%23pwa_study&amp;src=typd" title="#pwa_study - Twitter Search">#pwa_study - Twitter Search</a> で</li>
</ul></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Frontrend Vol.10 アウトラインメモ</title>
   <link href="http://efcl.info/2017/09/08/frontrend-v10/"/>
   <updated>2017-09-08T20:52:00+09:00</updated>
   <id>http://efcl.info/2017/09/08/frontrend-v10</id>
   <content type="html"><![CDATA[ <h1 id="frontrend-vol-10">Frontrend Vol.10</h1>

<p><a href="https://frontrend.connpass.com/event/63971/" title="Frontrend Vol.10 - 夏の終わりに納涼パフォーマンス話 - connpass">Frontrend Vol.10 - 夏の終わりに納涼パフォーマンス話 - connpass</a>に参加してきたのでメモ。</p>

<hr>

<h2 id="fresh-クライアントサイドパフォーマンス改善-by-sutiwo_">FRESH!: クライアントサイドパフォーマンス改善 by @sutiwo_</h2>

<ul>
<li><a href="https://developers.cyberagent.co.jp/blog/archives/6057/" title="FRESH! Web パフォーマンス改善 〜クライアントサイド編〜">FRESH! Web パフォーマンス改善 〜クライアントサイド編〜</a>の話</li>
<li>FRESHはPCとSPの視聴/配信のブラウザ対応</li>
<li>生放送のタイムラグを10秒 -&gt; 5秒

<ul>
<li><a href="https://www.cyberagent.co.jp/newsinfo/info/print/id=14062" title="映像配信プラットフォーム「FRESH!」が映像配信のタイムラグを大幅に短縮 業界最速水準で高画質映像の配信が可能に | 株式会社サイバーエージェント">映像配信プラットフォーム「FRESH!」が映像配信のタイムラグを大幅に短縮 業界最速水準で高画質映像の配信が可能に | 株式会社サイバーエージェント</a></li>
</ul></li>
<li>Freshのウェブプッシュ通知機能</li>
<li>Freshアクセシビリティガイドライン

<ul>
<li><a href="https://openfresh.github.io/a11y-guidelines/" title="FRESH! Accessibility Guidelines">FRESH! Accessibility Guidelines</a></li>
</ul></li>
<li>Service Worker

<ul>
<li>バックグラインドで実行するWorker</li>
<li>postMessageでのやり取り</li>
<li>ネットワークのハンドリング</li>
<li>PUsh通知</li>
<li>httpsが必須

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/Security/Secure_Contexts" title="Secure Contexts - Web セキュリティ | MDN">Secure Contexts - Web セキュリティ | MDN</a></li>
</ul></li>
<li>ブラウザ &lt;-&gt; SW &lt;-&gt; ネットワーク</li>
</ul></li>
<li>FRESHではFirefox + Chrome = 50%ぐらいの利用者にある

<ul>
<li>SWが50%のユーザーに適応できる</li>
</ul></li>
<li>設計と実装</li>
<li>キャッシュがあれば、キャッシュを使いない場合はFetchする

<ul>
<li>リリース単位でキャッシュさせる(CircleCIでビルド時にIDを含める)</li>
<li>意図的に更新させないとキャッシュされ続けるもの

<ul>
<li><code>version.json</code>で任意の日付をマニュアル更新</li>
</ul></li>
</ul></li>
<li>ディレクトリ構成

<ul>
<li>service-worker

<ul>
<li>asserts.js - キャッシュのホワイトリスト</li>
<li>index.js - イベントハンドラ登録</li>
<li>register.js SWのインストール判定</li>
</ul></li>
</ul></li>
<li>デバッグ方法

<ul>
<li>Chrome DevToolsを使ってる</li>
<li>assetsのパスに日付が入ってる</li>
</ul></li>
<li>ローカルで確認する時

<ul>
<li>環境変数でフラグを用意 = <code>DISABLED_SW_CACHE</code></li>
<li>ブラウザでスーパーリロードする</li>
</ul></li>
<li>Intersection Observerでの遅延ロード

<ul>
<li>ランキングの表示</li>
<li>50件でているが見えるのは最初の6-7件</li>
</ul></li>
<li>Intersection Observerを使って遅延ロード

<ul>
<li><a href="https://blog.jxck.io/entries/2016-06-25/intersection-observer.html">Intersection Observer を用いた要素出現検出の最適化 | blog.jxck.io</a></li>
<li><a href="https://1000ch.net/posts/2016/intersection-observer-lazyload.html">IntersectionObserverを使ってlazyload-imageを書き直した - EagleLand</a></li>
</ul></li>
<li><a href="https://github.com/openfresh/viewport-observer" title="openfresh/viewport-observer: A React Component that observe changes in the intersection of a target element with viewport using IntersectionObserver">openfresh/viewport-observer: A React Component that observe changes in the intersection of a target element with viewport using IntersectionObserver</a>

<ul>
<li>Reactラッパー</li>
</ul></li>
<li>SVGスプライトとHTTP/2

<ul>
<li>SVGファイル毎にリクエストするHTTP/1だと問題がある</li>
<li>SVGスプライトにまとめた

<ul>
<li>すべてのSVGが読み終わるまで、どのSVGもでない</li>
</ul></li>
<li>ただHTTP/2なら特に問題にならないので個別で読み込んだ

<ul>
<li>個別のSVGで読み込むようにした</li>
</ul></li>
</ul></li>
<li>SpeedCurveで計測してる</li>
</ul>

<hr>

<h2 id="パフォーマンスを改善して本を売る！「読書のお時間です」の取り組みについて">パフォーマンスを改善して本を売る！「読書のお時間です」の取り組みについて</h2>

<ul>
<li>5年続いたSPAのウェブサービスをSSRにした話</li>
<li>問題分析

<ul>
<li>ボトルネック調査</li>
</ul></li>
<li>設計

<ul>
<li>Before

<ul>
<li>jQuery</li>
<li>handlebars</li>
<li>Grunt</li>
</ul></li>
<li>After

<ul>
<li>React/webpack色々</li>
</ul></li>
</ul></li>
<li>開発

<ul>
<li>プロイピング</li>
<li>主要ページからリニューアルする</li>
<li>旧仕様のページと行き来できる作り(共存する)</li>
<li><code>#!</code> から <code>/</code> に変更</li>
</ul></li>
<li>リリース

<ul>
<li>ページロード 30% down</li>
<li>コンテンツサイズ 50% down</li>
</ul></li>
<li>展開

<ul>
<li>対象ページが100ページ以上あった</li>
<li>既存のものを運用しないといけない</li>
</ul></li>
<li>画像との戦い

<ul>
<li>本の表紙 = 書影</li>
<li>画像の提供元によってサイズなどがバラバラ</li>
</ul></li>
<li>パフォーマンス計測とKPIの紐付け

<ul>
<li>RUM-speedIndex

<ul>
<li><a href="https://github.com/WPO-Foundation/RUM-SpeedIndex" title="WPO-Foundation/RUM-SpeedIndex: Calculate SpeedIndex measurements from the field">WPO-Foundation/RUM-SpeedIndex: Calculate SpeedIndex measurements from the field</a></li>
</ul></li>
<li>SpeedIndexとKPIを紐付けてビジュアライズ

<ul>
<li><a href="https://developers.cyberagent.co.jp/blog/archives/9540/" title="WebパフォーマンスとプロダクトKPIの相関を可視化する話">WebパフォーマンスとプロダクトKPIの相関を可視化する話</a></li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2 id="アメブロ-isomprhicアプリケーションのパフォーマンス・チューニング">アメブロ: Isomprhicアプリケーションのパフォーマンス・チューニング</h2>

<blockquote>
<p>スライド: <a href="https://speakerdeck.com/kouhin/ameburo-isomprhicapurikesiyonfalsepahuomansutiyuningu" title="アメブロ: Isomprhicアプリケーションのパフォーマンス・チューニング // Speaker Deck">アメブロ: Isomprhicアプリケーションのパフォーマンス・チューニング // Speaker Deck</a></p>
</blockquote>

<ul>
<li><a href="https://developers.cyberagent.co.jp/blog/archives/636/" title="アメブロ2016 ~ React/ReduxでつくるIsomorphic web app ~">アメブロ2016 ~ React/ReduxでつくるIsomorphic web app ~</a>の話</li>
<li>Javaベース -&gt; Node.jsベースに変更</li>
<li>SSR: Isomorphic App(SPA + SSR) + React+ Redux + React Router</li>
<li>バックエンドキャッシュは大分

<ul>
<li>React SSRはパフォーマンスが悪い</li>
</ul></li>
<li>クライントは特定のユーザー、サーバサイドはすべてのユーザにサービスを提供

<ul>
<li>なのでサーバサイドはキャッシュとかしないと</li>
</ul></li>
<li>バックエンドのキャッシュの設計</li>
<li>問題点を洗い出す

<ul>
<li>何をキャッシュするか

<ul>
<li>Router -&gt; Redux Store準備(API Object) -&gt; Render -&gt; HTML</li>
<li>RenderToStringはとても重たい

<ul>
<li>同期的な処理</li>
<li>Note: React 16では30%程度改善</li>
<li><a href="https://twitter.com/herablog/status/893421865670017024">https://twitter.com/herablog/status/893421865670017024</a></li>
</ul></li>
<li>RenderToStringはキャッシュしたい</li>
<li>ただしユーザーによって違うのでそのままキャッシュできない</li>
<li>RenderToStringはテンプレートを吐き出して、クライアントサイドでそれをレンダリングする</li>
<li>API Objectもキャッシュすることでより改善された</li>
</ul></li>
<li>キャッシュするタイミング

<ul>
<li>アクセスされたとき</li>
</ul></li>
<li>キャッシュを削除するタイミング

<ul>
<li>記事を更新したら、記事IDから記事のキャッシュを消すのはNG</li>
<li>実際は記事を更新したら、記事本体、記事一覧、記事の前後などいろんなところを影響する</li>
<li>実装はかなり複雑になるので、キャッシュの削除は難しい</li>
<li>AmebaブログはユーザIDに紐付いているので、更新したらユーザIDに紐づくページをすべて削除する</li>
<li>FallbackとしてキャッシュのTTLで失効させる</li>
</ul></li>
<li>キッシュのトランザクション

<ul>
<li>キャッシュの更新とアクセスでキャッシュ作られたときに衝突してしまう問題</li>
<li>キャッシュのkeyは namespace(user-id)+version をつかうようにした</li>
<li>なので削除ではなくバージョンの更新 = キャッシュの削除</li>
</ul></li>
<li>Local Cache VS Cache Server

<ul>
<li>Node.jsのインスタンス数が多い(オンメモリだけではばらけてしまう)</li>
<li>オンメモリのキャッシュ + キャッシュサーバを併用</li>
</ul></li>
</ul></li>
<li>遅延ロード

<ul>
<li>SSR -&gt; SPA

<ul>
<li><a href="https://github.com/kouhin/rrr-lazy" title="kouhin/rrr-lazy: A fork of react-lazy-load and add support for react-router, react-router-hook.">kouhin/rrr-lazy: A fork of react-lazy-load and add support for react-router, react-router-hook.</a></li>
<li>サーバサイドではレンダリングしないコンポーネントを指定できる</li>
</ul></li>
<li>ページの表示範囲

<ul>
<li>クライントサイドの処理</li>
<li>Intersection Observer的な遅延ロード</li>
</ul></li>
<li>コードの分割

<ul>
<li>JavaScriptのパース時間が短くなる</li>
<li>main.jsの肥大化を防ぐ</li>
<li>webpack</li>
<li>分割粒度: AtomicデザインのOrganisms毎

<ul>
<li>Dynamic Importで遅延ロード</li>
</ul></li>
<li>分割するとビルドが遅い

<ul>
<li>ローカルではコード分割しない</li>
<li><a href="https://github.com/knpwrs/babel-plugin-remove-webpack" title="knpwrs/babel-plugin-remove-webpack: Removes webpack-specific functions from JavaScript code.">knpwrs/babel-plugin-remove-webpack: Removes webpack-specific functions from JavaScript code.</a>などで無効化してる</li>
</ul></li>
<li>chunkのサイズは結構でかい</li>
</ul></li>
</ul></li>
<li>Service Worker

<ul>
<li>AMPなので専用のタグを使う</li>
<li><a href="https://github.com/GoogleChrome/workbox" title="GoogleChrome/workbox: 📦 Workbox: JavaScript libraries for Offline Caching">GoogleChrome/workbox: 📦 Workbox: JavaScript libraries for Offline Caching</a></li>
</ul></li>
<li>HTTP/2 &amp;&amp; コード分割

<ul>
<li>Chromeは一度にリクエストできるの6つまで</li>
<li>一括で読み込むと詰まることがある</li>
<li>この辺は改善していきたい</li>
</ul></li>
</ul>

<hr>

<h1 id="q-amp-a">Q&amp;A</h1>

<ul>
<li>Q. パフォーマンス計測ツールはアメーバ社内で共通化されてるの?</li>
<li>A. アメブロはSpeedCurveとか</li>
<li>1000chに聞いて</li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>LDRがサービス終了のため、Inoreader/Feedlyをバックエンドに動くRSSリーダを書いている</title>
   <link href="http://efcl.info/2017/08/31/ldr-to-irodr/"/>
   <updated>2017-08-31T10:03:00+09:00</updated>
   <id>http://efcl.info/2017/08/31/ldr-to-irodr</id>
   <content type="html"><![CDATA[ <p>2017年8月31日をもってLDRはサービス終了です。乗り換え先となるRSSリーダを探したりしましたが、求めるものを見つけることができなかったので作ることにしました。</p>

<ul>
<li><a href="http://blog.livedoor.jp/staff_reader/archives/52278396.html" title="【重要】Live Dwango Reader/LDR Pocketサービス終了のお知らせ｜LDR / LDRポケット 開発日誌">【重要】Live Dwango Reader/LDR Pocketサービス終了のお知らせ｜LDR / LDRポケット 開発日誌</a></li>
</ul>

<p>次の記事でも書いていましたが、RSSリーダのバックエンドを自前で管理するのはコスト的に難しそうでした。そのため、バックエンドとして<a href="http://www.inoreader.com/developers/">Inoreader</a>や<a href="https://developer.feedly.com/v3/auth/">Feedly</a>のAPI使ったRSSリーダのウェブクライアントを書くことにしました。</p>

<ul>
<li><a href="http://efcl.info/2017/07/29/ldr-rate-export/" title="LDRのフィードをレート情報付きでエクスポートする | Web Scratch">LDRのフィードをレート情報付きでエクスポートする | Web Scratch</a></li>
</ul>

<h2 id="irodr">irodr</h2>

<p><a href="https://github.com/azu/irodr" title="Irodr">Irodr</a>は<a href="http://www.inoreader.com/developers/">Inoreader</a>や<a href="https://developer.feedly.com/v3/auth/">Feedly</a>(こっちはまだ対応してない)のAPIを使ったRSSリーダです。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://t.co/xKJF7YUu5D">https://t.co/xKJF7YUu5D</a> の様子 <a href="https://t.co/ERUTFtaP0b">pic.twitter.com/ERUTFtaP0b</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/903085352448962560">August 31, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>どちらのRSSリーダサービスもフロントを持っていますが、LDRのような感覚で見ることが難しそうだったので、APIを使ったフロントだけを作っている感じです。</p>

<p>LDRのような感覚というのは個人的な感覚に過ぎなので普遍的なものではないですが、次のようなイメージです。</p>

<ul>
<li>UI: レート読みができる

<ul>
<li>★の多い順にフィードを読んでいくスタイル</li>
<li>多くのRSSリーダではカテゴリで代用できる</li>
</ul></li>
<li>UI: 左にフィード一覧、右にコンテンツ</li>
<li>UI: コンテンツ送りの視線が固定できる

<ul>
<li>ショートカットで移動した時はタイトルが常に同じに位置に来る</li>
</ul></li>
<li>速度: <code>j</code>をおした時にアニメーションなしで次の記事を見れる

<ul>
<li>Inoreaderは設定はアニメーションをoffできる</li>
</ul></li>
<li>速度: <code>s</code>をおした時に300ms以内に次のフィードに切り替わる

<ul>
<li>LDRはこれを実現するためにprefetchをしている</li>
</ul></li>
<li>ショートカットを変更/カスタマイズできる

<ul>
<li>UserScriptでどうにかするやつ</li>
<li>Inoreaderは<a href="https://greasyfork.org/ja/scripts/898-inoreader-key-customize">https://greasyfork.org/ja/scripts/898-inoreader-key-customize</a>がよくできている</li>
</ul></li>
</ul>

<p>というのが自分的な感覚でのLDRらしい動きを実現するのに必要なものです。</p>

<p><a href="http://www.inoreader.com/" title="Inoreader">Inoreader</a>は大体満たしているのですが、速度だけが問題になっていました。</p>

<ul>
<li>未読数を表示すると、フィード数に応じて処理が重くなる

<ul>
<li>フィードを一度すべて表示してからフィルターしている</li>
<li>DOMの処理が重すぎてハングしてしまう(フィード数は3000弱)</li>
<li>問い合わせたら、未読数の処理が一番のボトルネックらしく未読数をOFFにすると改善すると解答を貰った</li>
<li>また、マスターDBはブルガリアのDCにあるらしいとのこと</li>
<li>via <a href="https://twitter.com/azu_re/status/902083679551348736">https://twitter.com/azu_re/status/902083679551348736</a></li>
</ul></li>
<li>フィードから次のフィードに移動するときにリクエストのブロックが起きている

<ul>
<li>Inoreaderでは&quot;Mark as Read&quot;のAPIを叩いて完了したら、次のフィードのコンテンツを取得している</li>
<li>つまり次のフィードに移動するときにはAPIを2つ叩いて完了するまで待っている

<ul>
<li>既読 -&gt; 次のコンテンツ取得</li>
</ul></li>
<li>大体300~800msぐらい一度のリクエストにかかっているので、移動に1秒以上かかる</li>
</ul></li>
</ul>

<p><a href="https://github.com/azu/irodr" title="Irodr">Irodr</a>ではこの問題を次のようにして回避しています。 </p>

<ul>
<li>未読数を表示すると、フィード数に応じて処理が重くなる

<ul>
<li>すべてのフィードは1画面に入ることはないので遅延表示のリストで表示する</li>
<li><a href="https://dev.office.com/fabric#/components/groupedlist">GroupList</a>を使ってる</li>
</ul></li>
<li>フィードから次のフィードに移動するときにリクエストのブロックが起きている

<ul>
<li>&quot;Mark as Read&quot;のAPIとコンテンツ取得のAPIを独立したタイミングで叩くようにする

<ul>
<li>次のフィードのコンテンツ取得 -&gt; さっきまでいたフィードを既読する イメージ</li>
<li>UI上はドメインモデルの未読カウントをすぐ0にするので、すぐ既読になっているように見えるので同じ</li>
</ul></li>
<li>prefetch処理を追加

<ul>
<li>今表示しているフィードから好きな数だけ先読みで取得できるようにしている</li>
<li>これにより次のフィードへの移動は300ms以内には完了する(リクエスト待たないので)</li>
</ul></li>
</ul></li>
</ul>

<h2 id="既知の問題">既知の問題</h2>

<p><a href="http://www.inoreader.com/" title="Inoreader">Inoreader</a>のAPIはCORSに対応していません！
つまりブラウザで直接APIを叩けないという問題があります。</p>

<p>これについても<a href="http://disq.us/p/1lpznh0">問い合わせている</a>のですが、今のところサポートされていないだけなのか、今後もサポートする気はないのかについてはまだ返事を貰ってないですが。（誰かつついてくれると助かります）</p>

<ul>
<li><a href="http://disq.us/p/1lpznh0">http://disq.us/p/1lpznh0</a><br></li>
</ul>

<p>今のところ、CORSを回避するProxyサーバを組み合わせるか、ブラウザ拡張で特定のAPIだけCORSを無視するワークアラウンドが必要です。</p>

<ul>
<li><a href="https://github.com/azu/irodr/issues/11" title="Docs: Add workaround for CORS · Issue #11 · azu/irodr">Docs: Add workaround for CORS · Issue #11 · azu/irodr</a></li>
</ul>

<p>まだ開発中なので、<code>npm start</code>すると自動でCORSを無視できるProxyサーバが立つ仕組みしか用意していません。ブラウザ拡張でCORSを無視させる方法には<a href="https://github.com/azu/irodr/issues/11">まだ問題があるので興味がある人はIssue</a>に日本語でもいいから書き込んでください。</p>

<p><strong>開発用のサーバ</strong>: <code>npm start</code>するとwebpack-dev-serverが立ち上がります。
<a href="http://localhost:3000">http://localhost:3000</a> は自動的にCORSを無視するProxyも兼ねているので、<a href="http://localhost:3000">http://localhost:3000</a> にアクセスすれば利用できます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm start
</code></pre></div>
<p>Electronアプリにすれば簡単に無視できますが、RSSリーダはブラウザで開けるウェブアプリのほうが都合がいいのでそこまでやる気はないです（タブを開きまくるのでアプリよりブラウザの方がいい。PRは歓迎しています）</p>

<p>後gh-pagesに公開したいのですが、 %PUBLIC_URL%が置換されないというcreate-react-app-typescriptの謎っぽい挙動を踏んでいるので、わかる方は次のIssueをみてください。</p>

<ul>
<li><a href="https://github.com/azu/irodr/issues/16" title="Not working on gh-pages · Issue #16 · azu/irodr">Not working on gh-pages · Issue #16 · azu/irodr</a></li>
</ul>

<p>他の既知の問題は <a href="https://github.com/azu/irodr/issues">https://github.com/azu/irodr/issues</a> にIssueを立てているので、気になる人は見てみてください。</p>

<h3 id="feedly">Feedly</h3>

<p>DDD的な感じで作っていて、ドメインモデルはInoreaderというサービスには依存しないように書いています。そのため、ちょっとUseCaseの変更は必要ですが、<a href="https://developer.feedly.com/v3/auth/">Feedly</a>など他のRSSリーダサービスにも対応できると思っています。</p>

<p>しかし、<a href="https://developer.feedly.com/v3/auth/">Feedly</a>のAPIの使い方がさっぱり分からなくて手を付けられていません。</p>

<p>どなたか、FeedlyのOAuthクライアントIDを永続的に取得する方法が分かる人は教えてください。
（TwitterやInoreader、GitHubなどは普通のアプリ登録でClient IDを取得できるので、これのやり方Feedlyだとよくわからない。Sandbox以外の方法はどこにあるのかな?）</p>

<h2 id="使い方">使い方</h2>

<p>2017-08-31現在は開発サーバを建てないと使えないです。
次の手順で多分<a href="https://github.com/azu/irodr" title="Irodr">Irodr</a>を手元で動かせるようになると思います。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git clone https://github.com/azu/irodr
cd irodr
npm install
# yarn installの方がlockを使うので推奨
npm start
open http://localhost:3000
</code></pre></div>
<p>ページを開くと多分TokenがないからInoreaderにログインして認証しろというエラーがでて、認証して戻ってくるとAPIを叩けるようになります。
（おそらくめちゃくちゃわかりにくいし、CORSの問題とかもあるので、開発者ツールを開いて見れる人じゃないと難しい気はします）</p>

<p>使ってみておかしなところは<a href="https://github.com/azu/irodr/issues">Issue</a>を立ててください。3日前に作り始めたばかりなので、まだちゃんと実装してない部分もありますがとりあえずIssueを立てておけば修正される気がします。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://t.co/xKJF7YUu5D">https://t.co/xKJF7YUu5D</a><br>面倒なのでInoreaderをバックエンドにLDRみたいなRSSリーダ書き始めた。<br>Inoreader CORS対応してないのがネック… FeedlyはOAuthのクライアントIDのとり方がよくわからない… <a href="https://t.co/cdbT55cC6x">pic.twitter.com/cdbT55cC6x</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/901991926676692992">August 28, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="おわりに">おわりに</h2>

<p>LDRは2017-08-31でサービス終了なので、次の記事で紹介してるフィード一覧の詳細データが入った <code>ldr.json</code> と呼んでいるものをまだ取得してない人は一応バックアップしておくといいと思います。
(opmlと違ってレートなど細かいデータも含まれている）</p>

<ul>
<li><a href="http://efcl.info/2017/07/29/ldr-rate-export/" title="LDRのフィードをレート情報付きでエクスポートする | Web Scratch">LDRのフィードをレート情報付きでエクスポートする | Web Scratch</a></li>
</ul>

<p>LDRは長いこと使いましたが、livedoor Readerを作った<a href="http://youkoseki.tumblr.com/post/22588852397/mala">方</a>々、LDRを<a href="https://www.youtube.com/watch?v=596ymsCCxbw">AWS</a>に<a href="http://media.amazonwebservices.com/jp/summit2015/docs/ME-02-Tokyo-Summit-2015.pdf">移して</a>運用されたLive Dwango Readerの方々ありがとうございました。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>略語は括弧の中 or 前? Open Source Software(OSS) or OSS(Open Source Software)</title>
   <link href="http://efcl.info/2017/08/15/textlint-rule-abbr-within-parentheses/"/>
   <updated>2017-08-15T19:25:00+09:00</updated>
   <id>http://efcl.info/2017/08/15/textlint-rule-abbr-within-parentheses</id>
   <content type="html"><![CDATA[ <p>タイトルにあるような正式名称に対する略語(主に頭文字を取るタイプ)を括弧の中に書いているかをチェックする<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>ルールを書きました。</p>

<ul>
<li><a href="https://github.com/azu/textlint-rule-abbr-within-parentheses" title="textlint-rule-abbr-within-parentheses">textlint-rule-abbr-within-parentheses</a></li>
</ul>

<h2 id="例">例</h2>

<p>例えば、Open Source Softwareの略語はOSSですということを表現したい場合に次のように書くというルールです。</p>

<p><strong>OK</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">This is Open Source Software(OSS)
これはOpen Source Software（OSS）なルールです
JavaScript(JS)
</code></pre></div>
<p><strong>NG</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">LTS（Long-Term Support）
JS(JavaScript)
This rule is OSS(Open Source Software)
これはOSS（Open Source Software）なルールです
</code></pre></div>
<h2 id="使い方">使い方</h2>

<p>npmでインストールして</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install textlint-rule-abbr-within-parentheses
</code></pre></div>
<p><code>.textlintrc</code>(Recommended)を設定すれば動きます。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;abbr-within-parentheses&quot;</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="略語は括弧の中-or-前">略語は括弧の中 or 前?</h2>

<p>統一という観点から見ると次のような文章は略語の書き方が混ざっていてよくありません。</p>

<blockquote>
<p>混ざっていて良くない例<br>
Ths Object Management Group(OMG) maintains specifications for the UML(Unified Modeling Language).</p>
</blockquote>

<p>そのため統一する書き方を探していたのですが、括弧の中に略語を書くというルールを採用してるケースが色々ありました。APA StyleやIBM Style Guideなどはそのような書き方を推奨しているようです。</p>

<p>逆(略語を先に書く)を推奨してるルールは見つけることができませんでしたが、括弧ではなく言葉で略語を解説するスタイルも見られました。しかしながら略語は括弧の中に書くという根拠については見つけられませんでした。</p>

<p>一つまだ疑問があって、括弧の中に書くとどうも補足的な印象が出てきてしまいます。
たとえば、URLのような略語自体が言葉として一般的に成立してるパターンは、Uniform Resource Locatorという正式名称はもはやURLの補足情報になっているように思えます。
他にもAP Styleの正式名称はAssociated Press Styleですが、AP(Associated Press) Styleのように紹介してる文章も見受けられます。(ここでの正式名称はわかりにくいしあまり重要ではないから括弧の中に書かれているのかも?)</p>

<h3 id="english">English</h3>

<ul>
<li><a href="https://english.stackexchange.com/questions/84958/which-would-you-place-in-parentheses-the-expansion-or-the-abbreviation" title="Which would you place in parentheses: the expansion or the abbreviation? - English Language &amp;amp; Usage Stack Exchange">Which would you place in parentheses: the expansion or the abbreviation? - English Language &amp; Usage Stack Exchange</a></li>
<li><a href="http://blog.apastyle.org/apastyle/2015/10/an-abbreviations-faq.html">APA Style Blog: An Abbreviations FAQ</a></li>
<li><a href="http://www.kuediting.com/style/qa-why-you-shouldnt-put-acronyms-in-parentheses/" title="Q&amp;amp;A: Why you shouldn&amp;#39;t put acronyms in parentheses">Q&amp;A: Why you shouldn&#39;t put acronyms in parentheses</a></li>
<li><a href="https://books.google.co.jp/books?id=77WoO_P8yA4C&amp;pg=PA57&amp;lpg=PA57" title="The IBM Style Guide: Conventions for Writers and Editors - Francis DeRespinis, Peter Hayward, Jana Jenkins, Amy Laird, Leslie McDonald, Eric Radzinski">The IBM Style Guide: Conventions for Writers and Editors - Francis DeRespinis, Peter Hayward, Jana Jenkins, Amy Laird, Leslie McDonald, Eric Radzinski - Google ブックス</a></li>
</ul>

<h3 id="japanese">Japanese</h3>

<ul>
<li><a href="http://www.jsphcs.jp/gakkaishi/denshi-m2.pdf" title="Microsoft Word - 執筆ガイドライン20151109訂正.docx - denshi-m2.pdf">Microsoft Word - 執筆ガイドライン20151109訂正.docx - denshi-m2.pdf</a></li>
<li><a href="http://logicalskill.blog.fc2.com/blog-entry-79.html">Logical Skill の深い話 略語の表記</a></li>
<li><a href="http://tmotooka.hatenablog.jp/entry/2013/05/18/212538">略語 : abbreviation と acronym - 職業プログラマの休日出勤</a></li>
</ul>

<p>ウェブに文書を書くと基本的にはHTMLなので、HTMLではどうなっているかが気になりました。
HTMLの世界では<a href="https://developer.mozilla.org/ja/docs/Web/HTML/Element/dfn" title="dfn">dfn</a>と<a href="https://developer.mozilla.org/ja/docs/Web/HTML/Element/abbr" title="abbr">abbr</a>がそれぞれ関係します。</p>

<blockquote>
<p>We use <dfn><abbr title="Hypertext Markup Language">HTML</abbr></dfn> to structure our web documents.</p>
</blockquote>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;p&gt;</span>We use <span class="nt">&lt;dfn&gt;&lt;abbr</span> <span class="na">title=</span><span class="s">&quot;Hypertext Markup Language&quot;</span><span class="nt">&gt;</span>HTML<span class="nt">&lt;/abbr&gt;&lt;/dfn&gt;</span> to structure our web documents.<span class="nt">&lt;/p&gt;</span>
</code></pre></div>
<p>この場合も正式名称が属性値にあるので、正式名称の方が補足情報にも見えます。</p>

<p>これは感覚的なものですが、略語をそもそも使うのは正式名称が毎回書くには長いためです。
なので、最初にこの正式名称の略語はこう定義しますという意味で <code>正式名称(略語)</code>と書くスタイルがあるのだと思います。またこの時に2回目以降は正式名称は補足的な情報に逆転する感じがします。(<code>abbr</code>要素の例)
一方、そもそも一度しか出てこない単語はどちらでもいいという理由で表記が安定しないような気がします。(このルールで縛りたい部分)</p>

<p>この辺の書き方や読んだときにどのような印象を受けるかについて調査レポートや論文とか知ってる人いたら教えてください。</p>

<hr>

<p>作ったtextlintルール</p>

<ul>
<li><a href="https://github.com/azu/textlint-rule-abbr-within-parentheses" title="textlint-rule-abbr-within-parentheses">textlint-rule-abbr-within-parentheses</a></li>
</ul>
 ]]></content>
 </entry>
 

</feed>
