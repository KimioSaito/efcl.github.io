<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Web Scratch</title>
 <link href="http://efcl.info/feed/" rel="self"/>
 <link href="http://efcl.info"/>
 <updated>2016-10-19T00:34:34+09:00</updated>
 <id>http://efcl.info/</id>
 
 <author>
   <name>azu</name>
   
 </author>
 

 
 <entry>
   <title>#jxck_sushi でserverlessの話をしてきた</title>
   <link href="http://efcl.info/2016/10/18/jxck_sushi/"/>
   <updated>2016-10-18T23:08:00+09:00</updated>
   <id>http://efcl.info/2016/10/18/jxck_sushi</id>
   <content type="html"><![CDATA[ <p><a href="http://togetter.com/li/1038372" title="#jxck_sushi - Togetterまとめ">#jxck_sushi</a>に参加してきた。</p>

<ul>
<li><a href="https://github.com/meta-sushi/guideline" title="meta-sushi/guideline: Sushiイベントのガイドライン">meta-sushi/guideline: Sushiイベントのガイドライン</a></li>
<li><a href="http://togetter.com/li/1038372" title="#jxck_sushi - Togetterまとめ">#jxck_sushi - Togetterまとめ</a></li>
</ul>

<p>2回目の<code>#jxck_sushi</code>だった。</p>

<ul>
<li><a href="http://efcl.info/2015/01/30/cross-2015/" title="CROSS 2015 アウトラインメモ | Web Scratch">CROSS 2015 アウトラインメモ | Web Scratch</a></li>
</ul>

<p>今回は<a href="http://azu.github.io/slide/2016/jxck_sushi/serverless.html" title="Serverlessを使った匿名でGitHub Issueを立てるAPIを作った">Serverlessを使った匿名でGitHub Issueを立てるAPIを作った</a>という話をしてきた。</p>

<p><a href="https://github.com/jser/ping" title="jser/ping: ping! your issus">jser/ping: ping! your issus</a>を作ったときに必要だったのAPI Gatewayとlambdaを使ってAPIとして作った話。</p>

<hr>

<h2 id="walter">Walter</h2>

<blockquote>
<p>TODO: スライドはここに</p>
</blockquote>

<ul>
<li>FirebaseとIndexedDBの話</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr"><a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> 🍣 <a href="https://t.co/YcLaJR6dK2">pic.twitter.com/YcLaJR6dK2</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788335553611640832">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">CQRS寿司 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> <a href="https://t.co/K9tWo8xGl6">pic.twitter.com/K9tWo8xGl6</a></p>&mdash; Yosuke FURUKAWA (@yosuke_furukawa) <a href="https://twitter.com/yosuke_furukawa/status/788335724680523777">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これからの Web について真剣に議論している <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> <a href="https://t.co/WQxTaieQng">pic.twitter.com/WQxTaieQng</a></p>&mdash; Jxck (@Jxck_) <a href="https://twitter.com/Jxck_/status/788336179221401600">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> による🍣 <a href="https://t.co/PMNoJa8gRn">pic.twitter.com/PMNoJa8gRn</a></p>&mdash; Laco (@laco0416) <a href="https://twitter.com/laco0416/status/788336275472265216">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">次世代のアーキテクチャについて真剣に議論している <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> <a href="https://t.co/GPuAQFX2u1">pic.twitter.com/GPuAQFX2u1</a></p>&mdash; 83 (@armorik83) <a href="https://twitter.com/armorik83/status/788336294304768000">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>内容は :sushi: </p>

<h2 id="serverless-frameworkでのapi作成">Serverless FrameworkでのAPI作成</h2>

<blockquote>
<p>スライド: <a href="http://azu.github.io/slide/2016/jxck_sushi/serverless.html" title="Serverlessを使った匿名でGitHub Issueを立てるAPIを作った">Serverlessを使った匿名でGitHub Issueを立てるAPIを作った</a></p>
</blockquote>

<ul>
<li><a href="https://github.com/jser/ping" title="jser/ping: ping! your issus">jser/ping: ping! your issus</a></li>
<li>API Gatewayとlambdaを使ってブラウザから叩けるAPIを作る話</li>
<li>CORSの設定とかも<a href="https://github.com/serverless/serverless" title="Serverless Framework">Serverless Framework</a>から設定ファイルだけで簡潔して便利だった</li>
<li>lambdaのテストについて</li>
<li>handlerのスクリプトをローカルで実行できるようにするしか…</li>
<li>ApexやServerlessは実際にlambdaを叩くCLIがある</li>
<li><code>console.log</code>を細かく仕込んでCloudWatchで見るとか</li>
<li>AWSのサービスと連携した場合が結構たいへん</li>
</ul>

<h2 id="web-component-v1">Web Component v1</h2>

<blockquote>
<p>スライド: <a href="http://slides.com/laco/webcomponents-v1-libs#/" title="webcomponents v1 libraries by laco">webcomponents v1 libraries by laco</a></p>
</blockquote>

<ul>
<li>Custom Element v1などがでた</li>
<li>ライブラリ</li>
<li><a href="https://www.polymer-project.org/2.0/docs/about_20" title="Polymer 2.0">Polymer 2.0</a></li>
<li><a href="http://skate.js.org/" title="SkateJS">SkateJS</a></li>
<li>が対応してる</li>
<li>Custom Element v1はクラス継承に対応してる</li>
<li>Polymer 2.0は継承路線</li>
<li>SkateJSはWebComponentとJSXとincrementJSに対応してたり、タグ定義は独自関数

<ul>
<li>自前でpolyfillを持っている</li>
</ul></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">らこ「Polymerはbower」<br>一同「bowerか〜〜」 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; 83 (@armorik83) <a href="https://twitter.com/armorik83/status/788341086901022720">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li>HTML Imports</li>
<li>PolymerはHTML Import頑張りたい姿勢</li>
<li>SkateJSはHTML Importを捨てている。モジュールの仕組み</li>
<li>Firefox: <a href="https://hacks.mozilla.org/2014/12/mozilla-and-web-components/" title="Mozilla and Web Components: Update ★ Mozilla Hacks – the Web developer blog">Mozilla and Web Components: Update ★ Mozilla Hacks – the Web developer blog</a>

<ul>
<li>Loaderで似たようなことができるかもしれないのに、別途HTML Importやるのが微妙という姿勢</li>
</ul></li>
</ul>

<h3 id="amp">AMP</h3>

<ul>
<li>社内フレームワークとしてのAMP</li>
<li>社内フレームワークとしてのWeb Components</li>
<li>よくJavaScriptとかしらない人が <code>&lt;TPLogin /&gt;</code> とかでログイン画面を作れるとか</li>
<li>AMPのいいところは imageのwidthを指定しないとバリデーションで落ちる</li>
<li>バリデーション通らないとSEO不利なのに皆対応するという強制力</li>
<li>そういった強制力をWeb Componentsで出せる?

<ul>
<li>JSXのpropTypesみたいな?</li>
<li>今のところ仕組みはなさそう</li>
</ul></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">「俺が書いたHTMLのほうがAMPより早い」 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788343509182918657">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h3 id="web-components-銀の弾丸">Web Components 銀の弾丸</h3>

<ul>
<li>CSSにとってはやっぱり銀の(ry</li>
<li>CSSのスコープ</li>
<li>けどCSSはレイアウトをするために外から差し込める口が必要

<ul>
<li>テーマ機能とか</li>
<li>CSSむずかしい</li>
</ul></li>
<li>v1ではopenとclose modeとなった

<ul>
<li>どちらもCSS Custom PropertyをI/F的に使えるのは同じ</li>
<li><a href="http://terkel.github.io/why-im-excited-about-native-css-variables/" title="僕がネイティブな CSS 変数にわくわくする理由">僕がネイティブな CSS 変数にわくわくする理由</a></li>
<li>closeは外からさせない</li>
<li>openは外からさせる</li>
<li>コンポーネントをattachShadowする時に確定する仕組みになった</li>
</ul></li>
</ul>

<h2 id="それcssでできるよ">それCSSでできるよ</h2>

<ul>
<li>可変長のリストの話</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">「Webの技術の中で一番難しいのがCSS」 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; 83 (@armorik83) <a href="https://twitter.com/armorik83/status/788348248188555264">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="セマンティックス">セマンティックス</h2>

<ul>
<li><code>&lt;img src=&quot;jxck.png&quot;&gt;</code> を見てどう思うか

<ul>
<li><code>alt</code></li>
<li><code>title</code></li>
</ul></li>
<li><code>alt</code>を付けるのはスクリーンリーダのためだけではないという話</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">「セマンティックスはPull型であるべきだ」 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788349959179427840">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li><code>title</code>属性の使い道は現在のUAだとツールチップぐらい</li>
<li>セマンティックスが先にあって、それを消費する形が正しい姿</li>
<li>今title属性を消費するクライアントがないからという理由で、titleを省略していくという考えは変なの正しくはないのではという話</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">HTMLとして正しいじゃなくて、ウェブとして正しいかという話になってしまう。<br>なのでやや抽象的で、どこから見た視点なのかという話になる<br> <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788351935640285184">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li>HTMLの仕様ではMUSTが正しいとは言えるけど、それ以外はどう見たら正しいのかという指標が難しい</li>
<li>正しさを正しいと評価するツールが欲しいのは分かる</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">仕様上のMUSTだと結構範囲は狭い、ユースケースまで行くとある程度の正しい形は書かれてる <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788353505144602624">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li>HTTP</li>
<li>getでdeleteするな話</li>
<li>Google Botsがクロールして全部getして消える話</li>
<li>Google Botsのために&quot;getでdelete&quot;を避けるじゃない</li>
</ul>

<h2 id="node-interactive-europe">Node Interactive Europe</h2>

<ul>
<li><a href="http://yosuke-furukawa.hatenablog.com/entry/2016/09/30/123942" title="Node Interactive Europe 2016 に参加しました。 - from scratch">Node Interactive Europe 2016 に参加しました。 - from scratch</a></li>
<li>Node.js 今互換性を気にしすぎで少し停滞してる</li>
<li>またio.js?</li>
<li>Node.jsの競合がでるのが正しい競争の形</li>
<li>Web標準も色々やっていきたい in Node.js</li>
</ul>

<h2 id="prh">prh</h2>

<ul>
<li><a href="http://qiita.com/vvakame/private/5cbb2bf9b6de5899006b" title="prhのWEB+DB PRESS校正ルール最新版を作成した話 - Qiita">prhのWEB+DB PRESS校正ルール最新版を作成した話 - Qiita</a></li>
<li>WEB+DBの<code>prh.yml</code>最新版情報</li>
<li>別でprh.ymlをまとめたリポジトリ</li>
<li><a href="https://github.com/azu/prh.yml" title="azu/prh.yml: A collection of prh.yml">azu/prh.yml: A collection of prh.yml</a></li>
</ul>

<h2 id="preflight">preflight</h2>

<ul>
<li>WHATWG module loaderでCORS強制する?</li>
<li>TODO: この辺に議論されてるURLが入る</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">「タイミングのpreflightが届いてなかった」 <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/788361447558426625">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="angular1と2">Angular1と2</h2>

<ul>
<li>Angular2は半年に1度メジャーを上げる予定?</li>
<li>Angular1と2で落差がある</li>
<li>信頼を取り戻すのに Angular 4ぐらいまでかかりそう</li>
<li>1を管理画面などの業務系に使っていた人たちが多い</li>
<li>Truly覚悟が必要</li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">Angular 2は別のネームスペースの1.0にしなかったから今後一生「Angular 2」って呼ばれそう <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a></p>&mdash; 83 (@armorik83) <a href="https://twitter.com/armorik83/status/788367243264471042">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="おわり">おわり</h2>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ありがとうございました！ <a href="https://twitter.com/hashtag/jxck_sushi?src=hash">#jxck_sushi</a> <a href="https://t.co/qf3Durm9wa">pic.twitter.com/qf3Durm9wa</a></p>&mdash; Jxck (@Jxck_) <a href="https://twitter.com/Jxck_/status/788372247043899392">October 18, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
 ]]></content>
 </entry>
 
 <entry>
   <title>AbemaTV Developer Conference 2016のアウトラインメモ</title>
   <link href="http://efcl.info/2016/10/15/abematv-2016/"/>
   <updated>2016-10-15T20:46:00+09:00</updated>
   <id>http://efcl.info/2016/10/15/abematv-2016</id>
   <content type="html"><![CDATA[ <p><a href="http://developer.abema.io/" title="AbemaTV Developer Conference 2016">AbemaTV Developer Conference 2016</a>に参加してきたメモ。
途中でメモが吹っ飛んだので最初のほうがありません。</p>

<h2 id="イマドキの-web-サービス運営で突き当たるフロントエンド課題とつらみ"><a href="http://developer.abema.io/#session_2_b" title="イマドキの Web サービス運営で突き当たるフロントエンド課題とつらみ">イマドキの Web サービス運営で突き当たるフロントエンド課題とつらみ</a></h2>

<blockquote>
<p><a href="https://speakerdeck.com/ahomu/kai-fa-shang-falseyang-nayi-cun-falseturamito-fresh-by-abematv-falsehua" title="開発上の様々な依存のつらみと FRESH! by AbemaTV の話 // Speaker Deck">開発上の様々な依存のつらみと FRESH! by AbemaTV の話 // Speaker Deck</a></p>
</blockquote>

<ul>
<li>ahomuさんすごい！！！</li>
</ul>

<hr>

<h2 id="リニア放送型動画サービスの-web-フロントエンド"><a href="http://developer.abema.io/#session_3_b" title="リニア放送型動画サービスの Web フロントエンド">リニア放送型動画サービスの Web フロントエンド</a></h2>

<blockquote>
<p><a href="http://www.slideshare.net/ygoto3q/web-67207768" title="リニア放送型動画サービスの  Web フロントエンド">リニア放送型動画サービスの  Web フロントエンド</a></p>
</blockquote>

<ul>
<li>動画のストリーミング配信について</li>
</ul>

<hr>

<h2 id="flux-with-rxswift"><a href="http://developer.abema.io/#session_5_b" title="Flux with RxSwift">Flux with RxSwift</a></h2>

<ul>
<li>FluxをRxSwiftで実装する話</li>
<li><a href="https://github.com/dekatotoro/FluxWithRxSwiftSample" title="dekatotoro/FluxWithRxSwiftSample">dekatotoro/FluxWithRxSwiftSample</a></li>
</ul>

<hr>

<h2 id="デザイナーとエンジニアの境界線"><a href="http://developer.abema.io/#session_7_b" title="デザイナーとエンジニアの境界線">デザイナーとエンジニアの境界線</a></h2>

<ul>
<li>デザイン</li>
<li>人の話</li>
<li>AbemaTC</li>
<li>社長からの要望

<ul>
<li>すぐ再生</li>
<li>ザッピング再生</li>
<li>受身的な再生</li>
</ul></li>
<li>最初のモック

<ul>
<li>縦画面</li>
<li>pixate

<ul>
<li>サービス終了.. <a href="http://www.pixate.com/">http://www.pixate.com/</a></li>
</ul></li>
<li>モックを移して夕会で共有</li>
<li>テレビっぽくない</li>
<li>モックは250個</li>
</ul></li>
<li>結果

<ul>
<li>16:9の横画面</li>
<li>皆の意見が反映させているので納得感がある</li>
</ul></li>
<li>モック見ながらの話

<ul>
<li>ステータスバーはwifi、バッテリーが気になるのであったほうがいい</li>
<li>要素が多くて多くて分かりにくい</li>
</ul></li>
<li>デザイン -&gt; エンジニア

<ul>
<li>Sketchのファイルをエンジニアに渡す</li>
<li>エンジニアがsketchを開いてマージンとかを見る</li>
</ul></li>
<li>アイコンの書き出し

<ul>
<li>Sketchからエクスポート</li>
<li>いい感じに最適化までやってくれるスクリプト</li>
</ul></li>
<li>デザインガイドみたいのは用意しなかった</li>
<li>アニメーションはPixateで

<ul>
<li>アニメーションの種類</li>
<li>秒数とかも共有できる</li>
<li>デザイナーが管理する</li>
</ul></li>
</ul>

<h3 id="デザイナーがコードに触ってみて感じたこと">デザイナーがコードに触ってみて感じたこと</h3>

<ul>
<li>Atomic Design</li>
<li>コンポーネント管理</li>
<li>GitHubを使う</li>
</ul>

<h2 id="gke-at-abematv"><a href="http://developer.abema.io/#session_8_a" title="GKE at AbemaTV">GKE at AbemaTV</a></h2>

<ul>
<li>GKEを選んだ理由</li>
<li>設計</li>
<li>GKE is

<ul>
<li>Google Container Engine</li>
<li>Kubernetesをフルマネージメントサービス</li>
</ul></li>
<li>Kubernetes is

<ul>
<li>Dockerのコンテナマネージメントツール</li>
<li>MasterとMinionのノードに別れる</li>
</ul></li>
<li>AbemaTV on GKE

<ul>
<li>フルフルGoogleプラットフォーム</li>
</ul></li>
<li>GKEを選んだ理由

<ul>
<li>GKEがGAに</li>
<li>活発なアップデートなどが理由</li>
<li>マイクロサービスアーキテクチャとの親和性</li>
</ul></li>
<li>RequestとLimits

<ul>
<li>RequestsはPod起動時に必要なリソース</li>
<li>LimitsはPodsのリソース制限</li>
<li>この2つの開きがあると高負荷時にリソースが枯渇する</li>
<li>Podスケール時にスケジュールしていた場合にLimitを超える場合もある</li>
</ul></li>
<li>1クラスタ × Nサービス AmebaTV

<ul>
<li>メリット

<ul>
<li>追加機能でインフラの準備不要</li>
<li>運用コストを低減

<ul>
<li>ローカルホストのポート指定で繋がる</li>
</ul></li>
</ul></li>
<li>デメリット

<ul>
<li>リソース消費の見極めが複雑化</li>
<li>Podの冗長化に難</li>
</ul></li>
</ul></li>
<li>Docker Image

<ul>
<li>Alpine Linux

<ul>
<li>Docker向きの軽量OS</li>
</ul></li>
<li>デプロイ頻度が少ないとかパッケージが足りないのはUbuntu</li>
</ul></li>
<li>lubectl

<ul>
<li>リソース作成

<ul>
<li><code>kubectrl create</code></li>
</ul></li>
<li>設定内容の更新

<ul>
<li><code>kubectrl apply</code></li>
</ul></li>
<li>Roling-Update

<ul>
<li>各Podをローリングでアップデートする</li>
<li>途中で失敗すると、中途半端な状態なPodが残る</li>
</ul></li>
</ul></li>
<li><code>kubetool</code>

<ul>
<li><code>kubectl</code>をラップした補助ツール</li>
<li><a href="https://github.com/abema/kubetool" title="abema/kubetool: Kubernetes deployment tools">abema/kubetool: Kubernetes deployment tools</a></li>
<li>Podを1台だけ最新へ -&gt; 他のPodへ反映のふろー</li>
</ul></li>
<li>監視/ログ

<ul>
<li>標準で取れるのはリソース状況のみ</li>
<li>Podの標準出力はLoggingに流れる =&gt; フィルターして監視</li>
</ul></li>
<li><code>kube-ui</code>

<ul>
<li>各コンポーネントの情報一覧</li>
<li>最近はリソースの編集とかもできる</li>
</ul></li>
<li>Terraformとの別離

<ul>
<li>編集するとすべて再作成される</li>
<li>無停止でやりにくい</li>
</ul></li>
<li>ServiceのIPに接続できない問題

<ul>
<li>v1.2.0でのバグ</li>
</ul></li>
<li>Nodeアップグレード時に問題

<ul>
<li>1台ずつアップグレードされるが、Podが先に落ちないためNodeに繋がらないとう問題がおきた</li>
</ul></li>
<li>GKEの感想

<ul>
<li>Docker導入の敷居が低い</li>
<li>デプロイ簡単</li>
<li>リソース調整にはコツがある</li>
<li>DevOps</li>
</ul></li>
</ul>

<h2 id="abematvの開発スタイル"><a href="http://developer.abema.io/#session_10_a" title="AbemaTVの開発スタイル">AbemaTVの開発スタイル</a></h2>

<ul>
<li>FRESHの立ち上げ</li>
<li>AbemaTVのリリース後の運用</li>
<li>インセプションデッキ

<ul>
<li>コンセプトイメージをまずつくった</li>
</ul></li>
<li>スプリント

<ul>
<li>2週間ぐらいを区切りにしてタイムボックスにいれてｒ</li>
<li>朝回で確認</li>
<li>スプリントレビューで成果の確認</li>
<li>KPTを振り返り</li>
</ul></li>
<li>チーム人数に適応する

<ul>
<li>そのままベースを使うわけじゃない</li>
<li>FRESH

<ul>
<li>開発20人前後</li>
</ul></li>
<li>AbemaTV

<ul>
<li>開発30人以上</li>
</ul></li>
<li>スクラムチームは15人ぐらいが限界</li>
<li>チームの分解が必要</li>
</ul></li>
<li>チームの分解

<ul>
<li>クライアント、サーバ、iOS、Android、デザイン</li>
<li>規模が大きくなるとヨコの連携が弱くなる</li>
<li>機能毎にプロジェクトを作る人をアサインすることでヨコの連携を補強</li>
</ul></li>
<li>FRESH 縦から横事件

<ul>
<li>リリース予定まで2スプリントだった</li>
<li>残りの機能をリリーススコープから外して横対応にした</li>
<li>デザインスプリント(デザイン合宿)をして認識合わせをした</li>
</ul></li>
<li>人に適応する

<ul>
<li>開発者個人でも課題が異なる</li>
<li>S1-S6の評価制度を意味づけを</li>
<li>評価制度を使って役割を明確化</li>
<li>自走できる人は権限を持つ</li>
</ul></li>
<li>自走

<ul>
<li>自走できる人は勝手に課題を見つけて対応する</li>
<li>計画する前に手を動いて追わせている場合がある</li>
<li>管理しすぎるとパフォーマンスが落ちることがある</li>
</ul></li>
<li>属人化

<ul>
<li>個人に依存するので属人化する</li>
<li>開発速度 &gt; 属人化</li>
</ul></li>
</ul>

<h2 id="炎上プロジェクト立て直しの風景"><a href="http://developer.abema.io/#session_12_a" title="炎上プロジェクト立て直しの風景">炎上プロジェクト立て直しの風景</a></h2>

<ul>
<li>炎上プロジェクトの立て直しの事例</li>
<li>権力者の介入がある風景

<ul>
<li>iOSとAndroidの仕様のズレがある</li>
<li>チーフプロデューサーが修正依頼がiOSのエンジニアのみに来る</li>
<li>=&gt; iOSとAndroidの仕様がずれる</li>
<li>やること

<ul>
<li>仕様はプロヂューサーとチーフプロデューサーで決める</li>
<li>直接エンジニアにはいかないはず</li>
<li>プロヂューサーを対話に同席させる</li>
</ul></li>
<li>学び

<ul>
<li>意思決定と情報の集約は一元化する</li>
<li>権力者とは上手く付きあう</li>
</ul></li>
</ul></li>
<li>要件がいつの間にか進化する風景

<ul>
<li>ヒアリングしてると要件が変わってきてることに気づいた</li>
<li>クライアントのひらめきにより要件が変わった</li>
<li>=&gt; 在庫連動したレコメンドサービスになってしまった</li>
<li>本来の目的に戻した</li>
<li>スコープは明確にすることが大事</li>
</ul></li>
<li>大規模プロモの直前なのにシステムが落ちまくっている風景

<ul>
<li>1.5万キャパを100万同時接続にするという風景</li>
<li>SNS認証のバックアッププランがない</li>
<li>特定機能の障害がひきずられて全体がダウンする</li>
<li>プロモが成功しても100万同時接続は行きそうになり

<ul>
<li>CM計画とアクセス傾向から</li>
</ul></li>
<li>プロジェクトゴールの再設定

<ul>
<li>過剰要件は落とす</li>
</ul></li>
</ul></li>
<li>最悪の問題とは

<ul>
<li>ゴールがブレる、終わりが見えない</li>
<li>チームワークの崩壊</li>
</ul></li>
<li>炎上 = 祭り</li>
<li>Q. AbemaTVは祭りにならなかったとのことですが、どういう工夫が?</li>
<li>A. いややっぱり祭りでした。</li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>pdf.jsなPDFビューアアプリをElectronで作った</title>
   <link href="http://efcl.info/2016/10/12/mu-pdf-viewer/"/>
   <updated>2016-10-12T20:39:00+09:00</updated>
   <id>http://efcl.info/2016/10/12/mu-pdf-viewer</id>
   <content type="html"><![CDATA[ <p>タイトルどおりですが、FirefoxのPDFビューアをスタンドアローン化したようなアプリを作りました。</p>

<ul>
<li><a href="https://github.com/azu/mu-pdf-viewer" title="azu/mu-pdf-viewer: PDF viewer on electron.">azu/mu-pdf-viewer: PDF viewer on electron.</a></li>
</ul>

<p>特徴は次の通りです。</p>

<ul>
<li><a href="https://github.com/mozilla/pdf.js" title="PDF.js">PDF.js</a>ベース</li>
<li>J, Kでスクロールなどいじっています</li>
<li>Drag and Dropをサポートしてます</li>
</ul>

<p><img src="https://monosnap.com/file/BfCnnmtQZhiRNDAfahDjTtzQpy4nss.png" alt="screenshot"></p>

<h2 id="install">Install</h2>

<p>npm でインストールするか</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install mu-pdf-viewer -g
</code></pre></div>
<p>バイナリをダウンロードして使えます(OS Xのみ)</p>

<ul>
<li><a href="https://github.com/azu/mu-pdf-viewer/releases/latest">https://github.com/azu/mu-pdf-viewer/releases/latest</a></li>
</ul>

<p>Travis CIとかでelectronを自動ビルドするのがかなり難しくなったので、自分用にOS X版のみバイナリを作ってます。</p>

<p>READMEにその他の環境のバイナリの作り方を書いてあります。</p>

<h2 id="usage">Usage</h2>

<p>npmでインストールした場合はCLIから起動できます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ mu-pdf-viewer &lt;pdf-file-path&gt;
</code></pre></div>
<p>アプリの場合は普通にPDFファイルを開いたり、D&amp;Dすれば起動します。</p>

<h2 id="目的">目的</h2>

<p>ショートカットが自分好みにカスタマイズできるPDFビューアが少なかったので作りました。
具体的には0.3画面分ぐらいスクロールするショートカットを持っているアプリが殆どなかったというのがメインです。</p>

<p>ショートカットが自由なPDFビューアは他にないのかな?</p>

<p>アプリ自体は、<a href="https://github.com/almin/almin" title="Almin">Almin</a>と<a href="https://facebook.github.io/react/" title="React">React</a>を使ってDDD風味で書いています。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>JavaScriptの配列のパターン</title>
   <link href="http://efcl.info/2016/10/11/array-patterns/"/>
   <updated>2016-10-11T20:44:00+09:00</updated>
   <id>http://efcl.info/2016/10/11/array-patterns</id>
   <content type="html"><![CDATA[ <p>JavaScriptの配列をどう解説するかを考えていて、配列って普段どういう風に使ってるけ?みたいなことを書き出してみました。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer/issues/49" title="Arrayオブジェクト · Issue #49 · asciidwango/js-primer">Arrayオブジェクト · Issue #49 · asciidwango/js-primer</a></li>
</ul>

<p>皆さんは配列をどう使いますか?</p>

<h2 id="配列の作成">配列の作成</h2>

<p>配列の作成には配列リテラル（<code>[]</code>）を使います。
配列リテラルには初期値も指定できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">emptyArray</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 空の配列を作成</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="c1">// 値をもった配列を作成</span>
</code></pre></div>
<p>Arrayオブジェクトを<code>new</code>演算子でインスタンス化する方法は基本的には使いません。
こちらは配列リテラルとは異なり、初期値ではなく配列の長さを指定し、<strong>疎な配列</strong>を作ります。</p>

<p>疎な配列とは、配列の要素が空となっているもので、隙間を持った配列のことを言います。</p>

<p>JavaScriptでは、配列は固定長ではなく可変長のみとなっていることや、
初期値を指定できないため、<code>new Array</code>で疎な配列を作る意味は少ないです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 10個分のlengthを持った疎の配列</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="c1">// 中身が空なので、値を持っていない</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="c1">// =&gt; false</span>
</code></pre></div>
<p>バイナリデータを扱うようなパフォーマンスが求められるケースは、
<code>Array</code>（配列）ではなく<code>TypedArray</code>（型付き配列）を利用します。</p>

<p><code>Array</code>（配列）と<code>TypedArray</code>（型付き配列）は似ていますが、
基本的に異なる目的を持ったものなので、ここでは<code>Array</code>（配列）についてを扱います。</p>

<h2 id="配列の要素を削除する">配列の要素を削除する</h2>

<p>delete演算子で配列の要素を削除することができますが、
注意点としては値を消すだけで、消した値を詰めるような処理は行いません。
つまり、<code>delete</code>した結果として疎な配列ができあがります。</p>

<p>次のように、<code>length</code>が<code>3</code>の配列の1番目の要素を消しても、
<code>length</code>は<code>3</code>のままとなります。
<code>delete</code>演算子では、自動的に削除された配列の要素を詰めません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// =&gt; 3</span>
<span class="k">delete</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// =&gt; [1, , 3]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// =&gt; 3</span>
</code></pre></div>
<p>一方、<code>Array#splice</code>メソッドを利用すると、削除した要素を自動で詰めることができます。
<code>Array#splice</code>メソッドは、<code>index</code>番目から<code>削除する数</code>だけ要素を取り除き、必要ならば要素を同時に追加できます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">array.splice(index, 削除する数, [追加する要素][, ..., 追加する要素]);
</code></pre></div>
<p>つまり、配列の1番目の要素を削除するには、1番目から1つの要素を削除するという指定をする必要があります。
このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// =&gt; 3</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// =&gt; [1, 3]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// =&gt; 2</span>
</code></pre></div>
<p>この<code>Array#splice</code>メソッドをImmutableにする場合は結構小難しい書き方になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">immutableSplice</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">deleteCount</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[...</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">start</span><span class="p">),</span> <span class="p">...</span><span class="nx">items</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">deleteCount</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><a href="http://vincent.billey.me/pure-javascript-immutable-array" title="Pure javascript immutable arrays">Pure javascript immutable arrays</a></li>
</ul>

<h2 id="arrayの要素を全削除">Arrayの要素を全削除</h2>

<p>配列の要素をすべて削除するには <code>length</code> に <code>0</code>を設定する方法があります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>仕様的には代入された<code>length</code>からはみ出ている要素をすべて <code>[[Delete]]</code> とするという処理になります。</p>

<ul>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-arraysetlength" title="ArraySetLength (A, Desc)">ArraySetLength (A, Desc)</a></li>
</ul>

<p><code>Array#splice</code>やそもそもその要素を削除するひつようがないなら、空の配列で変数を上書きするでもよいはずです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// or</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>次の２つは<code>array</code>という変数を参照の値を渡しているものがあるかで意味が異なります。
次のように<code>length</code>を変更した場合は、コールバック関数に渡した配列も影響を受けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">callbck</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
    <span class="c1">// array = [];</span>
    <span class="c1">// or</span>
    <span class="c1">// array.length = 0;</span>
<span class="p">}</span>

<span class="nx">doSomething</span><span class="p">((</span><span class="nx">array</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<h2 id="配列は参照型">配列は参照型</h2>

<p>配列はプリミティブな値ではなくオブジェクトなので、変数に入れると参照型の値になります。
次にように、配列を参照する<code>a</code>という変数の値を<code>b</code>に代入しても、<code>b</code>には配列の参照が入るだけです。
そのため、<code>a</code>に変更を加えると、<code>b</code>も同じ配列を参照しているため影響を受けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3, 4]</span>
</code></pre></div>
<p>一方、プリミティブな値である文字列では、<code>b</code>に<code>a</code>を代入する際に<code>a</code>の値がコピーされます。
つまり、変数<code>a</code>に変更を加えても、コピーされた値をもつ変数<code>b</code>は影響を受けません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// =&gt; &quot;string&quot;</span>
</code></pre></div>
<p>StringやNumberなどのプリミティブな値は、作成後に値そのものの状態は変更できません。
このような特性をもつものをImmutableと呼び、StringなどはImmutableです。</p>

<p>一方、ArrayやObjectなどのプリミティブな値でないものは、作った後も状態を変更できるためMutableと呼ばれます。</p>

<p>詳しくは<a href="https://asciidwango.github.io/js-primer/basic/data-type/" title="データ型とリテラル · JavaScriptの入門書 #jsprimer">データ型とリテラル · JavaScriptの入門書 #jsprimer</a>を参照してください。</p>

<h2 id="arrayのコピー">Arrayのコピー</h2>

<p>配列をshallow copyする流派としてconcatとsliceがあります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">copyC</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">copyS</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span> <span class="o">!==</span> <span class="nx">copyC</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span> <span class="o">!==</span> <span class="nx">copyS</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">copyC</span> <span class="o">!==</span> <span class="nx">copyS</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.concat">http://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.concat</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.slice">http://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.slice</a></li>
</ul>

<p><code>Array#concat</code>メソッドと<code>Array#slice</code>メソッドは意図して配列以外を<code>this</code>として指定できるようになっています。
そのため、Array-likeなオブジェクトを<code>this</code>にして、配列にする方法としても利用されています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">));</span>
</code></pre></div>
<p>しかし、ES2015からは<code>Array.from</code>メソッドという、Array-likeを配列にする適切なメソッドがあります。
あとで詳しく解説しますが、<code>Array.from</code>メソッドのほうが直感的なのでこちらを利用して変換した方がよいです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">));</span>
</code></pre></div>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-array.from">http://www.ecma-international.org/ecma-262/7.0/#sec-array.from</a></li>
</ul>

<h2 id="配列の末尾に要素を追加">配列の末尾に要素を追加</h2>

<p>末尾に要素を追加する場合は <code>Array#push</code> が利用できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3, 4]</span>
</code></pre></div>
<p><code>Array#push</code>はmutableな操作なので、immutableにやりたい場合もあります。
Immutableにやりたい場合は、配列のコピーの最後に要素を追加すればよいはずです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">array</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newArray</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3, 4]</span>
</code></pre></div>
<p>もちろん<code>Array#slice</code>などでコピーした配列にpushするでも問題ありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
<span class="nx">newArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newArray</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3, 4]</span>
</code></pre></div>
<p>先頭に要素を追加する場合も、<code>Array#push</code>が<code>Array#unshift</code>に変わるだけで同じです。</p>

<h2 id="new-array-fill">new Array + fill</h2>

<p><code>new Array(len)</code> で指定した<code>length</code>の<strong>疎な配列</strong>を作ることができます。
しかし、この配列の要素は<code>undefined</code>が値として入っているわけではありません。
単純に <code>array[0]</code> にはキーそのものがないため、 <code>undefined</code>が返ってきています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">10</span><span class="p">);</span><span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="c1">// hasOwnPropertyでプロパティを持っているかで確認できる</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// =&gt; false</span>
</code></pre></div>
<p>配列もオブジェクトであるため、疎な配列は次のようなオブジェクトであるといえます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// new Array(10)</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">length</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="nx">__proto__</span><span class="o">:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span>
<span class="p">};</span>
<span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; undefined</span>
</code></pre></div>
<p>これにより<code>new Array</code>では配列中の値がないので<code>Array#map</code>などが意図した挙動にはなりません
<code>Array#map</code>などは配列中の値がない添字をスキップします。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">index</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span><span class="c1">// =&gt; true</span>
</code></pre></div>
<p>そのため、これを回避する場合は明示的に値を入れた配列を使うか、
<code>Array.from</code>を使うことで<strong>疎な配列</strong>も扱えます。</p>

<p>明示的に値を埋める、いわゆる0埋めのような操作は<code>Array#fill</code>を使うのが簡単です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">index</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">===</span> <span class="mi">9</span><span class="p">);</span><span class="c1">// =&gt; true</span>
</code></pre></div>
<p><code>Array.from</code>メソッドはArray-likeやiterableなオブジェクトから新しく配列を作る静的メソッドです。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/from" title="Array.from() - JavaScript | MDN">Array.from() - JavaScript | MDN</a></li>
</ul>

<p>先ほどの<code>new Array</code>で作った疎な配列もlengthは持っているので、for文などで走査することはできます。
<code>Array.from</code>は、<code>arguments</code>のようなArray-likeや疎な配列も列挙でき かつ <code>Array#map</code>のような仕組みを持っています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">index</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">===</span> <span class="mi">9</span><span class="p">);</span><span class="c1">// =&gt; true</span>
</code></pre></div>
<p>他にも、Iterableを配列にできるので、Mapオブジェクトを配列へ変換するときにも利用できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">map</span><span class="p">));</span><span class="c1">// =&gt; [[1, 2], [2, 4], [4, 8]]</span>
</code></pre></div>
<p>これは、Spread Operator（<code>...</code>）を使うことでも同様のことが行なえます。
<code>Array.from</code>は第二引数でマッピング方法を指定できるのでより柔軟な処理が書けるという違いがあります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">map</span><span class="p">]);</span><span class="c1">// =&gt; [[1, 2], [2, 4], [4, 8]]</span>
</code></pre></div>
<h2 id="flatten">flatten</h2>

<p>配列の入れ子をflattenにしたいというケース。</p>

<p><code>[[1], [2], [3]]</code> =&gt; <code>[1, 2, 3]</code></p>

<p>concatを使った方法が有名です。</p>

<p><code>Array#concat</code>を使った方法ではshallowなflattenを行えます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">concat</span><span class="p">.</span><span class="nx">apply</span><span class="p">([],</span> <span class="nx">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]];</span>
<span class="nx">flatten</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3]</span>
</code></pre></div>
<p>再帰的にやることでdeepなflattenができます。
もう一つのflattenを行う方法として、<code>...</code> spread operatorで配列を展開してしまう方法です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">curr</span><span class="p">)</span> <span class="o">?</span> <span class="p">[...</span><span class="nx">prev</span><span class="p">,</span> <span class="p">...</span><span class="nx">flatten</span><span class="p">(</span><span class="nx">curr</span><span class="p">)]</span> <span class="o">:</span> <span class="p">[...</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">];</span>
    <span class="p">},</span> <span class="p">[]);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]];</span>
<span class="nx">flatten</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// =&gt; [1, 2, 3]</span>
</code></pre></div>
<p><a href="https://bterlson.github.io/proposal-flatMap/" title="Array.prototype.flatMap &amp;amp; Array.prototype.flatten">Array.prototype.flatMap &amp; Array.prototype.flatten</a> ProposalはStage 1なので、将来<code>Array#flatten</code>メソッドが利用できる可能性もあります。</p>

<h2 id="entriesで何か">entriesで何か</h2>

<p>オブジェクをループ時に key と value のどちらも必要な場合は、<code>Object.entries</code>メソッドを利用すると簡単です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">key1</span><span class="o">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
    <span class="nx">key2</span><span class="o">:</span> <span class="s2">&quot;value2&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">keyValues</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">object</span><span class="p">).</span><span class="nx">map</span><span class="p">(([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span><span class="err">`</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">keyValues</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;key1:value1&quot;, &quot;key2:value2&quot;];</span>
</code></pre></div>
<p>keyだけなら<code>Object.keys</code>メソッド、valueだけなら<code>Object.values</code>メソッドが利用できます。</p>

<h2 id="indexof-gt-findindex">indexOf =&gt; findIndex</h2>

<p>配列から指定した要素を見つける場合に <code>indexOf</code> だと<code>===</code>での一致でしか見つけることができません。
そのため、オブジェクトのプロパティを見て探索する場合には利用できません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">}];</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span> <span class="c1">// =&gt; -1</span>
</code></pre></div>
<p>代わりにES2015からは<code>Array#findIndex</code> が利用できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">}];</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span> <span class="c1">// =&gt; 0</span>
</code></pre></div>
<h2 id="find-gt-some">find =&gt; some</h2>

<p>配列の中に、判定に一致するものを含んでいるかという真偽値が欲しいのなら、<code>Array#some</code>が利用できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">}];</span>
<span class="kd">var</span> <span class="nx">isContained</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isContained</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<h2 id="indexof-gt-includes">indexOf =&gt; includes</h2>

<p>配列が指定した要素を含んでいるかに <code>array.indexOf(value) !=== -1</code> を使ったイディオムがあります。
先ほども書いたように<code>indexOf</code>は<code>===</code>による比較なので、<code>Array#some</code>で書くと次のような処理になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">containB</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">target</span> <span class="o">===</span> <span class="nx">item</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">containB</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>これを<code>Array#indexOf</code>を使えば1行で書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">containB</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">containB</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>しかし、ES2016からは<code>Array#includes</code>が利用できるので、このイディオムを使う必要はありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">containB</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">containB</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<h2 id="splice-gt">splice =&gt; ...</h2>

<p><code>Array#splice</code>はmutableな操作になっています。
そのため、配列から n 番目の要素を削除した配列をImmutableに作るのは結構面倒です。</p>

<p>mubtaleでよいなら、次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">deleteItemAtIndex</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="c1">// spliceの返り値は削除した値</span>
    <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">deleteItemAtIndex</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// =&gt; [1, 3]</span>
</code></pre></div>
<p>これをImmutableする場合、Spread Operatorと<code>Array#slice</code>を使うことで次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">deleteItemAtIndex</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 常に新しい配列を返す</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">...</span><span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">index</span><span class="p">),</span>
        <span class="p">...</span><span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">];</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">deleteItemAtIndex</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="c1">// =&gt; [1, 3]</span>
</code></pre></div>
<h2 id="配列から値を取り出す">配列から値を取り出す</h2>

<p>テストなどで、指定して位置の値を取り出したいときがあります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">sortByKey</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>これをテストした時には、返り値の0番目の値を取り出してみたいということが多いです。
この場合に、Destructuringを使い値を取り出すと変数にまとめて取り出せます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">sortByKey</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">().</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[{</span> <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}];</span>
<span class="kd">var</span> <span class="nx">sorted</span> <span class="o">=</span> <span class="nx">sortByKey</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">);</span>
<span class="kd">var</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sorted</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<h2 id="join">join</h2>

<p>配列を文字列にする方法はさまざまな方法があります。
単純な方法としては、<code>Array#join</code>メソッドを利用することです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">array</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="err">区切り文字</span><span class="p">);</span>
</code></pre></div>
<p><code>Array#join</code>メソッドでは配列を指定した<code>区切り文字</code>で結合した文字列を作成してくれます。
<code>区切り文字</code>を指定しなかった場合は、デフォルト値として<code>,</code>が<code>区切り文字</code>として指定されます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">join</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">lg</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span><span class="c1">// =&gt; &quot;1,2,3&quot;</span>
</code></pre></div>
<h2 id="ループと反復処理">ループと反復処理</h2>

<p><code>Array#map</code>メソッドなどのループと反復処理については<a href="https://asciidwango.github.io/js-primer/basic/loop/" title="ループと反復処理 · JavaScriptの入門書 #jsprimer">ループと反復処理 · JavaScriptの入門書 #jsprimer</a>を参照してください。</p>

<h2 id="空の配列を返す">空の配列を返す</h2>

<p>配列を返すAPIは、返す値がないときも空の配列を返すようにします。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">getSomeList</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="err">返すものがないとき</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="c1">// かえすものがあるとき</span>
<span class="p">}</span>
</code></pre></div>
<p>こうすることで、このAPIを利用する側はnullチェックをしなくても良くなります。
<code>null</code>や<code>undefined</code>を返してしまうと、このAPIを使うたびに<code>null</code>チェックが必要となります。
<code>null</code>チェックが不要ならば不要な形にした方が良いはずです。</p>

<h2 id="おまけ">おまけ</h2>

<p>Arrayのメソッドで破壊的なものとそうでないものをまとめたもの</p>

<script src="https://gist.github.com/azu/30b1ff6831c3bbf7fbd5501d6a2bdfb0.js"></script>
 ]]></content>
 </entry>
 
 <entry>
   <title>アーキテクチャをめぐるたび</title>
   <link href="http://efcl.info/2016/09/30/architecture-refs/"/>
   <updated>2016-09-30T20:01:00+09:00</updated>
   <id>http://efcl.info/2016/09/30/architecture-refs</id>
   <content type="html"><![CDATA[ <p>タイトルに特に意味はありませんが、<a href="https://github.com/almin/almin" title="Almin">Almin</a>を作る参考にしたものをまとめた感じの記事です。</p>

<ul>
<li>スライド: <a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a></li>
<li>リポジトリ: <a href="https://github.com/azu/large-scale-javascript" title="azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること">azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること</a></li>
</ul>

<p>主に書籍を並べていますがその他のスライドなどの参考資料は以下にまとめてあります。</p>

<ul>
<li><a href="https://github.com/azu/large-scale-javascript/blob/master/refs.md" title="large-scale-javascript/refs.md at master · azu/large-scale-javascript">large-scale-javascript/refs.md at master · azu/large-scale-javascript</a></li>
</ul>

<p>自分用のメモなので、読んだ順で並べておきます。
右側の年は書籍の出た年です。</p>

<h2 id="実践ドメイン駆動設計-2013"><a href="http://www.shoeisha.co.jp/book/detail/9784798131610" title="実践ドメイン駆動設計">実践ドメイン駆動設計</a> @ 2013</h2>

<p>一番最初に読んだDDD系の本。</p>

<p>この辺ででてくるレイヤーとか用語を把握した感じ。
けど、そこまでよく分かってない感じはする。
カウボーイが出てくるの読みにくい。</p>

<p>この本をベースにしたスライドなどが多かったのでそっちも合わせて見ていた。
また、出てきた用語をぐぐったりしながら読んでた気がする。</p>

<ul>
<li><a href="http://www.slideshare.net/AtsuoAoki/iddd17" title="「実践ドメイン駆動設計」社内読書会まとめ ～IDDD本難民に捧げる1章から7章～">「実践ドメイン駆動設計」社内読書会まとめ ～IDDD本難民に捧げる1章から7章～</a></li>
<li><a href="http://www.slideshare.net/masuda220/part3-ddd-in">ドメイン駆動設計 の 実践 Part3 DDD</a></li>
<li><a href="http://d.hatena.ne.jp/asakichy/20110524/1306190461">ドメイン駆動設計・アプリケーション構築編・エンティティ - Strategic Choice</a></li>
<li><a href="http://qiita.com/haazime/items/6119097071149a362f7f">戦術的DDD基本原則まとめ - Qiita</a></li>
</ul>

<p>基本的に読んだ内容は覚えていないので、この辺からメモを取りながら読むようにした。
Kindleで買ってたので、スクリーンショットをOneNoteに貼るという形でメモした(一応OCRがあるので検索できる)</p>

<p><img src="http://efcl.info/wp-content/uploads/2016/09/30-1475238536.png" alt="memo"></p>

<h2 id="今日からはじめる情報設計-2015"><a href="https://www.amazon.co.jp/dp/4802510012/" title="今日からはじめる情報設計">今日からはじめる情報設計</a> @ 2015</h2>

<p>情報設計(IA)についてかなり分かりやすい本。
フワッとした表現が多いけど、色々考え方の参考になった。</p>

<p>構造化の考え方として分類法は次の2つになるという話。</p>

<ul>
<li>並列的構造</li>
<li>階層的構造</li>
</ul>

<p>この辺の構造はパターン・ランゲージとかいろんな文脈でてくるので、最初に知っといてよかった気がする。
アーキテクチャの話を見ていて、それは何を整理したいのかという視点から見ることが多くなった感じ。</p>

<p><a href="http://azu.github.io/slide/2016/reject-sushi/how-to-work-team.html" title="How to work as a Team">How to work as a Team</a>のスライド書いていたあたりで読んでいたはずなので、スライドにも影響がでてる。</p>

<h2 id="情報アーキテクチャについて-iaaj-information-architecture-association-japan"><a href="http://iaaj.org/about_ia/" title="情報アーキテクチャについて | IAAJ: Information Architecture Association Japan">情報アーキテクチャについて | IAAJ: Information Architecture Association Japan</a></h2>

<p>IAという言葉もやはり変化していると思って探して見つけた記憶。</p>

<h2 id="エンジニアのための図解思考-再入門講座-情報の“本質”を理解するための実践テクニック-2010"><a href="http://www.shoeisha.co.jp/book/detail/9784798122755" title="エンジニアのための図解思考 再入門講座 情報の“本質”を理解するための実践テクニック（開米瑞浩） ｜ 翔泳社の本">エンジニアのための図解思考 再入門講座 情報の“本質”を理解するための実践テクニック</a> @ 2010</h2>

<p>情報の整理の仕方を考えていた。
箇条書きよりテーブルのほうが情報量多いよという話</p>

<h2 id="netのエンタープライズアプリケーションアーキテクチャ　第2版　～-netを例にしたアプリケーション設計原則-2015"><a href="http://ec.nikkeibp.co.jp/item/books/P98480.html" title=".NETのエンタープライズアプリケーションアーキテクチャ　第2版　～.NETを例にしたアプリケーション設計原則">.NETのエンタープライズアプリケーションアーキテクチャ　第2版　～.NETを例にしたアプリケーション設計原則</a> @ 2015</h2>

<p>DDD本の中では一番読みやすい日本語の書籍な気がする。
最初のアーキテクトの話なども面白かった。</p>

<p>またDDDの文脈で出てくるモデルやリポジトリなどは、人によって言ってることが違うという事実をちゃんと注記してくれている。CQRSについてはこの本を読むとよい。</p>

<p>確かこの本を読む<a href="https://github.com/almin/almin/commit/2f8048f7f45497df809e646b6ceb4445c6bbdbe2">1週間ぐらい前</a>に<a href="https://github.com/almin/almin" title="Almin">Almin</a>を作ったので、この本を読むときは考え方の答え合わせみたいな感じで読んでたと思う。
(コードベース自体はもうちょっと前にできてたのライブラリとして切り出したのがこの時)</p>

<p>DDDの文脈で出てくる用語は検索しても、とにかく曖昧な事が多いので、曖昧な用語であるということを明記されていたのが良かった。</p>

<blockquote>
<p>単純さと複雑さは人によって異なる</p>
</blockquote>

<p>とかそういう話はIAのやつでも出てきたので、その辺で話のつながりを感じた。</p>

<h2 id="オブジェクト開発の神髄-2005"><a href="http://bpstore.nikkeibp.co.jp/item/books/P82370.html" title="日経BP書店｜商品詳細　-　オブジェクト開発の神髄">オブジェクト開発の神髄</a> @2005</h2>

<p><a href="https://github.com/almin/almin" title="Almin">Almin</a>でUseCaseという用語を使っていたので、その用語が出てくるものとして見つけて読んだ。</p>

<p>ユースケースモデリングについてはこの本を結構参考にしていたと思う。</p>

<blockquote>
<p>ユースケースはアクターの視点から能動的に書く</p>
</blockquote>

<p>PoEAAと出版時期が近かった気がするけど、こっちの方が興味深い感じだった。</p>

<h2 id="エンタープライズアプリケーションアーキテクチャパターン-2005"><a href="http://www.shoeisha.co.jp/book/detail/9784798105536" title="エンタープライズアプリケーションアーキテクチャパターン（長瀬嘉秀 Martin Fowler 株式会社テクノロジックアート） ｜ 翔泳社の本">エンタープライズアプリケーションアーキテクチャパターン</a> @ 2005</h2>

<p>PoEAA。
読んでいてDDD本とかIDDD本とかでも似たような事を言ってたなー感じた記憶がある。</p>

<p>この辺でアーキテクチャ本みたいな事が言ってることは、本質的にはそんな変化ないのかなーという所に興味が出てきた。</p>

<h2 id="パターン・ランゲージ-創造的な未来をつくるための言語-2013"><a href="https://www.amazon.co.jp/dp/4766419871/" title="パターン・ランゲージ: 創造的な未来をつくるための言語">パターン・ランゲージ: 創造的な未来をつくるための言語</a> @ 2013</h2>

<p>今ある色々なアーキテクチャの源流的なものを巡っていて、<a href="https://www.amazon.co.jp/dp/4306041719/" title="パタン・ランゲージ―環境設計の手引">パタン・ランゲージ―環境設計の手引</a> @ 1984を探しているときに見た。</p>

<p>DDDもパターン集であるため、この源流はやはりこの辺にあるのではと思って調べていた。
IAの話もそうだけど、構造化の考え方などは都市構造の考えの話とも一致している感じがする。</p>

<blockquote>
<p>「何を」作るのかを支援するというもの、抽象的な形で提供される<br>
パターンはデザインを支援する。良いデザインは問題を解決する<br>
パターンランゲージは言葉で形を表すので、それは誰に取っても同じ形にならないとおかしい<br>
真偽値を科学的なものじゃない、コードとかにも「良い悪い」という適用したのがパターンの面白いところ  </p>
</blockquote>

<p>via <a href="http://twilog.org/azu_re/date-160519">http://twilog.org/azu_re/date-160519</a></p>

<p>ソフトウェアのアーキテクチャやパターンはこの辺にやっぱり源流がありそうというのは分かってきた。</p>

<p>パターン・ランゲージとかアレグザンダーについては次の本が詳しそう。</p>

<ul>
<li><a href="http://gihyo.jp/magazine/wdpress/plus/978-4-7741-3897-8" title="パターン、Wiki、XP ―― 時を超えた創造の原則">パターン、Wiki、XP ―― 時を超えた創造の原則</a></li>
<li><a href="https://ipsj.ixsq.nii.ac.jp/ej/index.php?active_action=repository_view_main_item_detail&amp;page_id=13&amp;block_id=8&amp;item_id=75806&amp;item_no=1">情報学会誌</a>も面白い話が載ってる</li>
</ul>

<h2 id="アルゴリズミック・デザインの現在"><a href="http://www.ieice.org/cs/csbn/program/papers/080516_waseda.pdf" title="untitled - 080516_waseda.pdf">アルゴリズミック・デザインの現在</a></h2>

<p>パターン・ランゲージのアレグザンダーは1970年代にはコンピュータによるデザイン設計を試みてたという話があった。
建築的にはアルゴリズミック・デザインの源流となる考え方で、それを調べてた。
また1970年代ではまだコンピュータの性能などの問題があるのでアレだけど。</p>

<blockquote>
<p>著者はこの言葉のように、要求された機能を十分に満たすような優れた「デザイン ･ パターン」と「デザイン ･ アルゴリズム」からは、優れた「デザイン ･ パターン」が自動的に生成されると考えていた。<br>
しかし、人の感性に良いと評価される「デザイン ･ パターン」と機能的に生成された「デザイン ･ パターン」は必ずしも重なるわけでないことが分かった。本事例では、「デザイン ･ パラメータ」に人が感性的に決定した要素を入れたり、ということを実験的に行ってみたが、その結果は感性的な要因を記述することの難しさを確認しただけとなった
-- <a href="http://www.ieice.org/cs/csbn/program/papers/080516_waseda.pdf" title="untitled - 080516_waseda.pdf">アルゴリズミック・デザインの現在</a></p>
</blockquote>

<p><a href="https://www.amazon.co.jp/dp/4306045234/" title="アルゴリズミック・デザイン―建築・都市の新しい設計手法 : 日本建築学会 : 本 : アマゾン">アルゴリズミック・デザイン―建築・都市の新しい設計手法 : 日本建築学会 : 本 : アマゾン</a></p>

<blockquote>
<p>コンピュータ・プログラムをつかって建築設計をするためのさまざまな技法や設計例について書いている．「アルゴリズミック」というと完全に自動的に設計するようにきこえるが，おおくの例では設計の候補を出力して，設計者がそのなかから選択する方法がとられている．その点ではアルゴリズミック・コンポジションつまりコンピュータをつかった作曲と同様であり，まさにクセナキスがとっていた「音楽デザイン」の方法とおなじである．それを「アルゴリズミック」とよぶのが適切であるかどうかはわからない．</p>
</blockquote>

<p>ジェネラティブ・アート的な考え方なのかなとも思えてきた。</p>

<p>パターン・ランゲージでは、「パターン」とは誰にとっても(人種が異なっていても)同じ形になるという話がある。</p>

<blockquote>
<p>パターンランゲージは言葉で形を表すので、それは誰に取っても同じ形にならないとおかしい  </p>
</blockquote>

<p>また、パターンは作り出すものではなく見つけるものと言う話があった気がするので、いったんアルゴリズミック・デザインの話は諦めた。</p>

<blockquote>
<p>デザインパターンとは懸命な人が発明するものではなく、既存のコードの中から発見されるものです。 
-- <a href="http://www.oreilly.co.jp/books/9784873113890/" title="O&amp;#39;Reilly Japan - ThoughtWorksアンソロジー">O&#39;Reilly Japan - ThoughtWorksアンソロジー</a></p>
</blockquote>

<p>この辺で一端折り返した。</p>

<h2 id="a-pattern-language-for-information-architecture"><a href="http://www.ellisonconsulting.com/downloads/Pattern_Language_for_Information_Architecture.pdf" title="Pattern_Language_for_Information_Architecture.pdf">A Pattern Language for Information Architecture</a></h2>

<p>パターン・ランゲージとIAについて書かれたスライド。</p>

<h2 id="企業情報システムアーキテクチャ"><a href="https://www.amazon.co.jp/dp/B00N0SRXBI/" title="企業情報システムアーキテクチャ">企業情報システムアーキテクチャ</a></h2>

<p>企業システムのアーキテクチャの話として見た。</p>

<h2 id="patterns-principles-and-practices-of-domain-driven-design-wrox-2015"><a href="http://www.wrox.com/WileyCDA/WroxTitle/Patterns-Principles-and-Practices-of-Domain-Driven-Design.productCd-1118714709.html" title="Patterns, Principles, and Practices of Domain-Driven Design - Wrox">Patterns, Principles, and Practices of Domain-Driven Design - Wrox</a> @ 2015</h2>

<p>DDDについて分かりやすく書かれてる書籍。
DDD本/IDDD本が分かりにくいところを分かりやすく書こうとした感じのする内容だった。</p>

<p>DDDに興味がある人は読むとよい感じな気がする。(かなり分厚いというか量が多い…)</p>

<h2 id="読みたいけど読めてないもの">読みたいけど読めてないもの</h2>

<h3 id="オブジェクトデザイン-2007"><a href="https://www.amazon.co.jp/dp/4798109037/" title="オブジェクトデザイン">オブジェクトデザイン</a> @ 2007</h3>

<p>ES6の仕様のEditorである<a href="https://codezine.jp/article/detail/9071" title="アレン・ワーフスブラック">アレン・ワーフスブラック</a>の奥さんでもある<a href="https://www.ogis-ri.co.jp/otc/hiroba/ogisbooks/ObjectDesign.html" title="レベッカ・ワーフスブラック">レベッカ・ワーフスブラック</a>が書いた書籍。
責務駆動についてちょっと知りたい。</p>

<h3 id="実践uml-第3版-オブジェクト指向分析設計と反復型開発入門-2007"><a href="https://www.amazon.co.jp/dp/4894716828/" title="実践UML 第3版 オブジェクト指向分析設計と反復型開発入門">実践UML 第3版 オブジェクト指向分析設計と反復型開発入門</a> @ 2007</h3>

<p>オブジェクト指向について。
そもそも手に入らない。</p>

<h3 id="ユースケース駆動開発実践ガイド-2007"><a href="http://www.shoeisha.co.jp/book/detail/9784798114453" title="ユースケース駆動開発実践ガイド">ユースケース駆動開発実践ガイド</a> @ 2007</h3>

<p>ユースケースについて。今読んでる。</p>

<h2 id="おわり">おわり</h2>

<p>今もちょうどやっている翔泳社の電子書籍セールで買って読んだものが多い気がする。</p>

<ul>
<li><a href="http://www.shoeisha.co.jp/campaign/fes/20160926" title="半期に1度のエンジニア応援祭：電子書籍40％割引セール ｜ 翔泳社">半期に1度のエンジニア応援祭：電子書籍40％割引セール ｜ 翔泳社</a></li>
</ul>

<p>他にも見たほうがいいやつがあったら知りたいなー</p>

<p>色々見てた感じアーキテクチャという分野を扱うものは、あんまりパーマネントリンクが貼れるようにできていない気がする。そういう意味でも<a href="http://www.martinfowler.com/" title="Martin Fowler">Martin Fowler</a>は正しくてすごい気がした。</p>

<p>最初に<a href="https://github.com/almin/almin" title="Almin">Almin</a>という成果物を作り、それの中に入ってる考えの名前を求める旅をしていた。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>Travis CIからgh-pagesへデプロイする設定 via SSH/git push</title>
   <link href="http://efcl.info/2016/09/27/deploy-from-travis-ci-to-gh-pages/"/>
   <updated>2016-09-27T23:29:00+09:00</updated>
   <id>http://efcl.info/2016/09/27/deploy-from-travis-ci-to-gh-pages</id>
   <content type="html"><![CDATA[ <p>最近はGitHubリポジトリのgh-pagesブランチでサイトを公開する機会が増えているのですが、
リポジトリが更新されたら自動でサイトも更新できるようにしたいです。</p>

<p>以前は、GitHub Access Tokenを発行して、Travis CIのconfig(secret)にそのTokenを埋め込んで、Tokenを使ってpushをしていました。</p>

<p>しかし、GitHub Access Tokenは簡単に発行できるとはいえリポジトリ単位で管理できる権限となっていないため、Tokenが漏れてしまうと管理ができないという問題があります。
(実際 <code>git push -q</code>などしないと簡単に漏れてしまう)</p>

<p>そのため、最近はSSH鍵を使ってリポジトリへpushする方針へと変更しました。</p>

<p>GitHubのリポジトリには、リポジトリごとにDeploy Keyという公開鍵を登録できる仕組みがあるため、リポジトリ毎の秘密鍵とと公開鍵の組み合わせで管理することができます。</p>

<p>基本的にはJavaScript関係のものが多いでの、npm run-scriptで実行できるような仕組みでこの鍵を使ったdeployをやってくれるものがないかなーと思って探してみたらありました。</p>

<ul>
<li><a href="https://github.com/alrra/travis-scripts" title="alrra/travis-scripts: Scripts to help automate things using Travis CI">alrra/travis-scripts: Scripts to help automate things using Travis CI</a></li>
</ul>

<p>このスクリプトはTC39のECMAScriptの仕様書の自動デプロイとかにも使われています。</p>

<ul>
<li><a href="https://github.com/tc39/ecma262/blob/master/scripts/auto-deploy.sh" title="ecma262/auto-deploy.sh at master · tc39/ecma262">ecma262/auto-deploy.sh at master · tc39/ecma262</a></li>
</ul>

<p>仕組みとしては、次のようになっています。</p>

<p><a href="https://github.com/alrra/travis-scripts" title="alrra/travis-scripts: Scripts to help automate things using Travis CI">alrra/travis-scripts: Scripts to help automate things using Travis CI</a>のチュートリアルがちゃんと書かれているのでその通りにやっていればできるはずです。(環境変数の指定や<code>git config user.name</code>とかの設定が忘れやすいです)</p>

<ol>
<li>手元でssh-keygenして秘密鍵と公開鍵を作る</li>
<li>公開鍵をGitHubのリポジトリにWriteのDeploy Keyとして登録する</li>
<li><code>travis encrypt-file github_deploy_key</code>という感じで秘密鍵を暗号化する

<ul>
<li>このファイルはTravis CI上で復号化されたファイルとして手に入る</li>
<li><a href="https://github.com/alrra/travis-scripts">alrra/travis-scripts</a>はこれを<code>~/.ssh/</code>に移動してくれる</li>
</ul></li>
<li>後は、Traivs CIからgit push via sshができるので、普通に<code>git push</code>するだけ</li>
</ol>

<p>この仕組みのいいところとしては、GitHub Access Tokenより権限の範囲が小さい、漏れてもリポジトリ単位でrevokeできるという点がいいところです。
また、普通に<code>git push</code>ができるのでGitHub Access TokenでBasic認証的にpush先を変更しなくても動くのがいいところです。</p>

<hr>

<p>しかし、この一連の設定はDeploy Keyを登録したり自動化できていなくて面倒くさいです。
そのため大部分を自動化できるスクリプトを書きました。</p>

<p>まずは、alrra/travis-scriptsをインストール。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm i -D @alrra/travis-scripts
</code></pre></div>
<p>先に指定した、公開鍵をGitHubリポジトリに登録する<a href="https://github.com/azu/add-deploy-key-to-github" title="azu/add-deploy-key-to-github">azu/add-deploy-key-to-github</a>というツールを書いたのでそれを入れておきます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm i -g add-deploy-key-to-github
</code></pre></div>
<p>次に、先ほどの手順の1-3をある程度自動的にやってくれるスクリプトを該当するプロジェクトのディレクトリで実行します。</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="c">#!/bin/bash</span>
<span class="nb">set</span> -eu
<span class="c"># Usage:</span>
<span class="c"># $ travis-ssh-keygen.sh &quot;user/name&quot;</span>
<span class="nb">declare </span><span class="nv">repo</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

<span class="k">if</span> !type add-deploy-key-to-github &gt;/dev/null 2&gt;<span class="p">&amp;</span>1<span class="p">;</span> <span class="k">then</span>
  npm install -g add-deploy-key-to-github
<span class="k">fi</span>
<span class="c"># creat ssh key and add deploy key</span>
ssh-keygen -t rsa -b <span class="m">4096</span> -C <span class="s2">&quot;$(git config user.email)&quot;</span> -f github_deploy_key -N <span class="s1">&#39;&#39;</span>
<span class="c">## Add deploy to github</span>
add-deploy-key-to-github --key github_deploy_key.pub --repo <span class="k">${</span><span class="nv">repo</span><span class="k">}</span> --token <span class="s2">&quot;自分のGitHub Token&quot;</span>
<span class="c">## Remove pub key</span>
cat github_deploy_key.pub <span class="p">|</span> pbcopy
rm github_deploy_key.pub
<span class="c"># encrypt private key and move to .travis</span>
travis encrypt-file github_deploy_key --add
rm github_deploy_key
mkdir -p .travis/
mv github_deploy_key.enc .travis/
<span class="c"># Setup Travis Git Config</span>
travis env <span class="nb">set </span>GH_USER_EMAIL <span class="s2">&quot;$(git config user.email)&quot;</span>
travis env <span class="nb">set </span>GH_USER_NAME <span class="s2">&quot;$(git config user.name)&quot;</span>
</code></pre></div>
<p>たとえば、<code>azu/website</code>リポジトリなら、
そのディレクトリで実行すれば、SSHの鍵生成から登録、travis encrypt-file .travis/github_deploy_key.enc`の作成までをやってくれます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">travis-ssh-keygen.sh &quot;azu/website&quot;
</code></pre></div>
<p>後は、<code>.travis.yml</code>にデプロするブランチやディレクトリ、デプロイ前のコマンドを書けば自動デプロイの設定は完了です。</p>

<p>残念ながら<code>$encrypted_567c1b6fa013_key</code>の部分は毎回違うので、自動ができていません。
先ほどのスクリプトで<code>.travis.yml</code>に自動で値が書かれているので、それを手動でコピーする必要があります。。
(どうにかできないのかな…)</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="l-Scalar-Plain">sudo</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">false</span>
<span class="l-Scalar-Plain">language</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">node_js</span>
<span class="l-Scalar-Plain">node_js</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">stable</span>
<span class="l-Scalar-Plain">after_success</span><span class="p-Indicator">:</span>
  <span class="p-Indicator">-</span> <span class="p-Indicator">|</span>

        <span class="no">$(npm bin)/set-up-ssh --key &quot;$encrypted_567c1b6fa013_key&quot; \</span>
                             <span class="no">--iv &quot;$encrypted_567c1b6fa013_iv&quot; \</span>
                             <span class="no">--path-encrypted-key &quot;.travis/github_deploy_key.enc&quot;</span>

        <span class="no">$(npm bin)/update-branch --commands &quot;npm run build&quot; \</span>
                                 <span class="no">--commit-message &quot;Update website [skip ci]&quot; \</span>
                                 <span class="no">--directory &quot;./public&quot; \</span>
                                 <span class="no">--distribution-branch &quot;gh-pages&quot; \</span>
                                 <span class="no">--source-branch &quot;master&quot;</span>
</code></pre></div>
<p>参考リポジトリ</p>

<p>次のリポジトリは、このスクリプトの設定で、リポジトリにコミットする自動でgh-pagesへデプロイされています。</p>

<ul>
<li><a href="https://github.com/azu/presentation-annotator">https://github.com/azu/presentation-annotator</a></li>
</ul>

<p>Circle CIだと鍵を登録することができるので、もっと簡単にできた気がしますがTravis CIだとこんな感じで鍵を使ったgit pushの設定ができるという話でした。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>React Meetup #4 でJavaScriptでのCQRSの話をしてきた</title>
   <link href="http://efcl.info/2016/09/27/react-meetup-4/"/>
   <updated>2016-09-27T22:54:00+09:00</updated>
   <id>http://efcl.info/2016/09/27/react-meetup-4</id>
   <content type="html"><![CDATA[ <p><a href="http://reactjs-meetup.connpass.com/event/39793/">React Meetup #4</a>に参加してきました。</p>

<p>その中で、複雑なJavaScriptアプリケーションを考えながら作る話という話をしました。</p>

<ul>
<li>スライド: <a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a></li>
<li>補足資料: <a href="https://github.com/azu/large-scale-javascript" title="azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること">azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること</a></li>
</ul>

<p>クライアントサイドJavaScriptでも.NETとかサーバサイドでの知見とかを取り入れて考えてみましょう的な話です。</p>

<h1 id="graphql-and-falcor">GraphQL and Falcor</h1>

<blockquote>
<p><a href="https://quramy.github.io/graph-api-note/#/" title="Graph API: GraphQL and Falcor">Graph API: GraphQL and Falcor</a></p>
</blockquote>

<ul>
<li>APIを叩くものを効率的にやるためのパターン</li>
<li>REST API</li>
<li>欲しいものをほしいだけ取るパターン

<ul>
<li>Demand Driven Architectureという</li>
</ul></li>
<li>ReactとGrapQL

<ul>
<li>Relay</li>
<li>GraphQL Relay Specificationの実装</li>
</ul></li>
<li>データのとり方とコンポーネントが横並び

<ul>
<li>Relay</li>
</ul></li>
<li>Viewへのマッピングは自分でやる

<ul>
<li>Falcor</li>
</ul></li>
</ul>

<hr>

<h1 id="複雑なjavascriptアプリケーションを作るには-azu">複雑なJavaScriptアプリケーションを作るには - @azu</h1>

<p>複雑なJavaScriptアプリケーションを考えながら作る話という話をしました。</p>

<ul>
<li>スライド: <a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a></li>
<li>補足資料: <a href="https://github.com/azu/large-scale-javascript" title="azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること">azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること</a>

<ul>
<li>実際に作ったガイドラインとか参考資料とかをまとめたリポジトリ</li>
</ul></li>
</ul>

<p>JavaScriptで複雑なアプリケーションを作るアーキテクチャをどう考えたかについての話。
Fluxで未定義感があるドメインモデルをどのように考えて作っていくかについてを中心にしてます。</p>

<p>後は、<a href="https://github.com/almin/almin" title="Almin">Almin</a>ではドメインモデルを扱うために、どのような構造にしていったかについて。</p>

<hr>

<h1 id="redux-saga-kuy">redux-saga - @kuy</h1>

<ul>
<li>redux-saga

<ul>
<li>副作用を扱ってくれるライブラリ</li>
</ul></li>
<li>Saga

<ul>
<li>実行したい処理をまとめたプロセス</li>
</ul></li>
<li>Effect

<ul>
<li>データとしての副作用</li>
</ul></li>
<li>Saga Runtime

<ul>
<li>実行環境</li>
</ul></li>
<li>実装

<ul>
<li>Effectをyeildを返すGenerator関数で書く</li>
</ul></li>
<li>Saga RuntimeでSagaを実行する

<ul>
<li>内部的にはState Machineになっている</li>
</ul></li>
<li>Root Saga -&gt; 色々なsagaをforkする</li>
<li>Saga Runtime &lt;-&gt; Saga(プロセス)

<ul>
<li>これをやり取りする Effect が色々ある感じ</li>
</ul></li>
<li>ロジックをSagaに書いていく</li>
<li>redux-sagaのコードが増えてきたら

<ul>
<li>ファイルを分割したくなる</li>
<li>1個のことだけをするSagaを作っていく</li>
<li>sagaはあくまでロジックを書く場所</li>
</ul></li>
<li>solidな処理はmiddlewareで書く</li>
<li>問題点

<ul>
<li>初見が難しい</li>
<li>generaotr/yeild</li>
<li>regeneratorを使う必要がある</li>
</ul></li>
</ul>

<hr>

<h1 id="realworld-react-mizchi">RealWorld React - @mizchi</h1>

<ul>
<li>最近はリファクタリングをしてる</li>
<li>普通のウェブサイトにReactをあてていく</li>
<li>設計レベルでSPAが難しいので徐々に書き換えていく話

<ul>
<li>ボトムアップで変えていく</li>
</ul></li>
<li>Reactの難しさ

<ul>
<li>Reactの使うためのエコシステムの難しさ</li>
<li>Flux的な設計の難しさ</li>
<li>React自体は難しいというわけではない</li>
</ul></li>
<li>最近だと分割統治していくとモジュールを作っていく

<ul>
<li>読み込むだけで副作用があるモジュールが古の時代には多いので難しい</li>
</ul></li>
<li>リファクタリングしていく

<ul>
<li>Backbone + jasmineテストちょろっと</li>
<li>jQuery pluginが大量にある状態のもの</li>
</ul></li>
<li>リファクタリングの方針

<ul>
<li>モダンな環境の導入</li>
<li>今のコードを良くする =&gt; 諦めた</li>
<li>再利用できるものとできないものを分けるところから始めた</li>
</ul></li>
<li>JavaScriptが複雑な画面

<ul>
<li>投稿画面とフィード画面</li>
<li>「やってみた」「無理だった」 </li>
<li>分からない仕様が大量にでてくるので、まず仕様を理解するところから</li>
</ul></li>
<li>ゴールの設定

<ul>
<li>React/Babelで受け入れる環境</li>
<li>Turbolinkができるような初期化フローを作る

<ul>
<li>ある程度、Stateが整理されている目安としてTurbolinkが使える</li>
</ul></li>
</ul></li>
<li>enzymeがテストに便利</li>
<li>FlowTypeはJSXにも型が付けやすくて便利</li>
</ul>

<hr>

<h1 id="reactコンポーネントとcssコンポーネントは1対1なのかについて-shibe97">ReactコンポーネントとCSSコンポーネントは1対1なのかについて - shibe97</h1>

<blockquote>
<p><a href="https://speakerdeck.com/shibe97/reactkonponentotocsskonponentoha1dui-1nafalsekawen-ti-nituite" title="ReactコンポーネントとCSSコンポーネントは1対1なのか問題について // Speaker Deck">ReactコンポーネントとCSSコンポーネントは1対1なのか問題について // Speaker Deck</a></p>
</blockquote>

<ul>
<li>1対1なのかどうか</li>
<li>ReactコンポーネントはViewとロジックを分離する</li>
<li>Presentational Component

<ul>
<li>再利用可能なコンポーネント</li>
</ul></li>
<li>Container Component

<ul>
<li>Reduxのconnect関数を使ったコンポーネント</li>
<li>Presentationに値渡したり</li>
</ul></li>
<li>Atomic Design

<ul>
<li><a href="http://blog.kubosho.com/entry/using-atomic-design">Atomic Designの考え方と利点・欠点 - I&#39;m kubosho_</a></li>
<li>最小の単位(atom)でコンポーネントを作ってそれを使っていく</li>
</ul></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>複雑なJavaScriptアプリケーションを作るためにやったことをまとめた</title>
   <link href="http://efcl.info/2016/09/27/large-scale-javascript/"/>
   <updated>2016-09-27T10:18:00+09:00</updated>
   <id>http://efcl.info/2016/09/27/large-scale-javascript</id>
   <content type="html"><![CDATA[ <p>タイトルどおりですが、次のリポジトリに複雑なクライアントJavaScriptアプリケーションをどう考えて作っていくかを実践した内容をまとめてあります。</p>

<ul>
<li><a href="https://github.com/azu/large-scale-javascript" title="azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること">azu/large-scale-javascript: 複雑なJavaScriptアプリケーションを作るために考えること</a></li>
</ul>

<p>ここでいう複雑なアプリケーションとは、ライブラリ抜きで数万LOC以上ぐらいの規模になることが予測されているようなものを扱っています。(巨大というよりは複雑という印象)</p>

<h2 id="140文字でok">140文字でOK</h2>

<p>140文字向けのサマリだと次のような感じです。</p>

<blockquote>
<p>JavaScriptで複雑なアプリケーションを作る構成と実践ガイド。
ドメインモデルをどのように考えて作っていくかについて。
Babel、React、Almin、PostCSSがベース。</p>
</blockquote>

<p>作成するアプリケーションによって必要な構造は異なるため、この構成がよいということを主張するものではありませんが、 何か参考になるものがあれば幸いです。</p>

<h2 id="内容">内容</h2>

<p><a href="https://github.com/azu/large-scale-javascript" title="azu/large-scale-javascript">azu/large-scale-javascript</a>は、同じ趣旨の<a href="http://azu.github.io/slide/2016/react-meetup/large-scale-javascript.html" title="複雑なJavaScriptアプリケーションを考えながら作る話">複雑なJavaScriptアプリケーションを考えながら作る話</a>というスライドと合わせて読む感じの内容になっています。</p>

<p><a href="./docs">コーディングガイド</a>的なドキュメントや<a href="https://github.com/azu/presentation-annotator" title="azu/presentation-annotator: viewing presentation and annotate.">小さな実装例</a>などがおいてあります。
また<a href="https://github.com/almin/almin" title="Almin">Almin</a>でCQRS的な実装するための<a href="https://github.com/azu/large-scale-javascript/blob/master/refs.md">参考にした書籍/スライド/記事</a>や<a href="https://github.com/azu/large-scale-javascript">ポエム</a>みたいなやつも書いてあります。</p>

<p>疑問や意見などは<a href="https://github.com/azu/large-scale-javascript/issues/new">New Issue</a>を作って書くか、<a href="https://twitter.com/azu_re">Twitter</a>とか適当に聞いてください。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>文章をTDDする</title>
   <link href="http://efcl.info/2016/09/14/text-testing/"/>
   <updated>2016-09-14T20:22:00+09:00</updated>
   <id>http://efcl.info/2016/09/14/text-testing</id>
   <content type="html"><![CDATA[ <h1 id="文章のテスト">文章のテスト</h1>

<p>技術書とかの文書を開発するにあたってテストを先に書きたくなったという話です。</p>

<ul>
<li><a href="http://efcl.info/2015/11/07/nodefest-2015/">東京Node学園祭2015で技術文書をソフトウェア開発する話をしてきた | Web Scratch</a></li>
<li><a href="https://azu.gitbooks.io/nodefest-technical-writing/content/">Introduction | 技術文書をソフトウェア開発する話</a></li>
</ul>

<p>とかの続きみたいなものです。</p>

<p>ここで扱う文章は、Markdownですが、構造を持った文章なら多分適応できる気がします。
具体的には<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>で扱うパーサを再利用しているので、reStructuredTextとかRe:VIEWとかHTMLも多分頑張ればできる。</p>

<h2 id="構造化された文章">構造化された文章</h2>

<p>構造を持った文章とはどういうものかというと、セクションやパラグラフなどがシンタックスとして大体分かる文章の事をここでは言っています。</p>

<p>しかし、Markdownにはセクション(HTMLでは <code>&lt;section&gt;</code> タグに該当するもの)がないので、HeaderとHeaderの間を一つのセクションとして認識しています。</p>

<ul>
<li><a href="https://github.com/azu/text-testing/tree/master/packages/select-section" title="text-testing/packages/select-section at master · azu/text-testing">text-testing/packages/select-section at master · azu/text-testing</a></li>
</ul>

<h2 id="文章が特定のキーワードを含むかテストする">文章が特定のキーワードを含むかテストする</h2>

<p>実際どうやって文章をテストするかというと次のようなBDDっぽいようなテストを書きます。</p>

<ul>
<li><a href="https://github.com/azu/text-testing/tree/master/packages/text-testing-mocha" title="text-testing-mocha">text-testing-mocha</a></li>
</ul>

<p>このテストでは<code>サンプル</code>というワードを含むセクションが、
<code>単語</code>というキーワードを含んでいるかをテストしています。</p>

<p><code>**</code> で囲んだ範囲だけをキーワードの対象にできます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">tester</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;text-testing-mocha&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;fs&quot;</span><span class="p">);</span>
<span class="c1">// テストする対象の文章を読み込む</span>
<span class="kr">const</span> <span class="nx">content</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s2">&quot;README.md&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">);</span>
<span class="nx">tester</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">section</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 指定したセクションが</span>
    <span class="nx">section</span><span class="p">(</span><span class="s2">&quot;この**サンプル**が&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">test</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">test</span><span class="p">(</span><span class="s2">&quot;この**単語**を含んでいるかをテストする&quot;</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>例えば次の文章だと、先ほどのテストはパスします。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># サンプルA

ある単語を含んでいる文章なのでOK
</code></pre></div>
<p>しかし、次の文章だと、先ほどのテストは失敗します。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># サンプルB

ある???を含んでいないのでダメ
</code></pre></div>
<p>デフォルトでは含んでいる事をテストしていますが、第二引数で任意の判定をかけるので、含まない事も書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">tester</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="p">(</span><span class="nx">section</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">section</span><span class="p">(</span><span class="s2">&quot;ある**サンプル**は&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">it</span><span class="p">,</span> <span class="nx">sections</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;**unknown**を含まない&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">texts</span><span class="p">,</span> <span class="nx">section</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">texts</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="nx">text</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">section</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">text</span><span class="p">));</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p><a href="https://github.com/azu/text-testing/tree/master/packages/text-testing-mocha" title="text-testing-mocha">text-testing-mocha</a>は名前の通り、Mochaを使って動くDSLみたいなものです。</p>

<p>正直すごい雑で大したことをやっていないです。</p>

<h2 id="モチベーション">モチベーション</h2>

<p><a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a>を書いていて、一つの章が長くなると目的を見失う事がままあります。</p>

<p>そのため、まずその章が何を説明したいのかという目標規定文を書き、書きながらそれを何度も見なおして脇道に逸れないように注意を払う必要がありました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">目標規定文<br>-- 理科系の作文技術 <a href="https://t.co/qpHTynwfBh">pic.twitter.com/qpHTynwfBh</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/776034638942707712">September 14, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>章やセクションと言った単位で書いてる途中で、その目標が変わることはあまりないはずなので、何かガイドとなるものが欲しかったのが一つのモチベーションです。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">文章に関係しそうな文をキーワードを書き<br>その文章が何を伝えたいのかをかく目標規定文を書き<br>文章のアウトラインを考え<br>アウトラインの詳細を決める実験やコードを集め<br>もう一度アウトラインを構成し<br>アウトラインからテストを書き<br>文章に落とす</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/767584331875311617">August 22, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h3 id="テストファースト">テストファースト</h3>

<p>新しい文章を書いてて一番気が重たいのは最初の一行を書くことだと思います。
しかし、アウトラインは本文に比べてラクな気持ちで書くことができていました。</p>

<p>なので、最初にアウトラインをテストとして書いてみることから始めました。
そうすることで、テストが落ちます。</p>

<p>テストが落ちてるので、次はテストが通るように文章を書き始めれば良くなります。
そうすることで、書き始めが楽になるのではないかなという実験も兼ねて作り始めました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;2000年は閏年&quot;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">isLeap</span><span class="p">(</span><span class="mi">2000</span><span class="p">));</span>
<span class="p">});</span>
</code></pre></div>
<p>というテストを書いて、</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">isLeap</span><span class="p">(</span><span class="nx">year</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>というコードから書き始めるのと同じような気分でスタートできます。</p>

<p>また、技術書のような文書はある程度文章の構造があると思うので、入力(文章)に対する出力(伝えたい結果)はテストできてもいいんじゃないかなという期待も持っています。</p>

<p>実際にこのテストを取り入れて書いてみたものは次のものになっています。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/implicit-coercion/" title="暗黙的な型変換 · JavaScriptの入門書 #jsprimer">暗黙的な型変換 · JavaScriptの入門書 #jsprimer</a></li>
<li><a href="https://github.com/asciidwango/js-primer/pull/129" title="feat(implicit-coercion): 暗黙的な型変換について by azu · Pull Request #129 · asciidwango/js-primer">feat(implicit-coercion): 暗黙的な型変換について by azu · Pull Request #129 · asciidwango/js-primer</a></li>
</ul>

<p>後は、何かと文章は一度に多くを書きすぎてしまう問題を持っている気がします。
小さなPull Requestして開発を進めるのがいいように、文章にも同じアプローチが正しいのかは今後検証していきたい気がします。
この時に、より&quot;構造&quot;というものを意識した書き方が必要になるのかもしれません。</p>

<p>分かりやすいコードも分かりやすい文章もある程度のレベルまでは、センスとかではなく技術的なアプローチで解決できる問題なのではないかなと考えています。</p>

<ul>
<li><a href="https://github.com/azu/text-testing" title="azu/text-testing: Testing library for structured texts.">azu/text-testing: Testing library for structured texts.</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>NaNはNot a NumberだけどNumber型である話</title>
   <link href="http://efcl.info/2016/09/06/nan/"/>
   <updated>2016-09-06T21:54:00+09:00</updated>
   <id>http://efcl.info/2016/09/06/nan</id>
   <content type="html"><![CDATA[ <p>この記事では、JavaScriptの<code>NaN</code>について改めて学ぶという趣旨の話をします。</p>

<p>JavaScriptで、文字列などから数値へ値を変換したいことがあると思います。
典型的なケースでは、ユーザーに入力してもらった数字となる文字列を、Number型へ変換するというケースです。</p>

<p>この場合、<code>Number</code>コンストラクタ関数や<code>Number.parseInt</code>、<code>Number.parseFloat</code>などが利用できます。(ここでは、<code>Number.parseInt</code>にしていますが、<code>parseInt</code>と同じです)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// ユーザー入力を文字列として受け取る</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s2">&quot;数字を入力してください&quot;</span><span class="p">,</span> <span class="s2">&quot;42&quot;</span><span class="p">);</span>
<span class="c1">// 文字列を数値に変換する</span>
<span class="kd">var</span> <span class="nx">number</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">number</span><span class="p">);</span> <span class="c1">// =&gt; &quot;number&quot;;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span> <span class="c1">// 入力された文字列を数値に変換したもの</span>
</code></pre></div>
<p>しかし、<code>Number</code>コンストラクタ関数や<code>Number.parseInt</code>を使って、値を明示的に変換したとしても結果は<code>NaN</code>になる場合があります。
端的に言えば、Number型と互換性のない性質のデータをNumber型へ変換した結果は<code>NaN</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 数字ではないため、数値へは変換できない</span>
<span class="nb">Number</span><span class="p">(</span><span class="s2">&quot;文字列&quot;</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
<span class="c1">// 整数としてパースできない文字列だった</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&quot;e10s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
<span class="c1">// 未定義の値はNaNになる</span>
<span class="nb">Number</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
<span class="c1">// 空オブジェクトは数値にできない</span>
<span class="nb">Number</span><span class="p">({});</span> <span class="c1">// =&gt; NaN</span>
</code></pre></div>
<p>JavaScriptでは数値に<a href="https://ja.wikipedia.org/wiki/IEEE_754" title="IEEE 754">IEEE 754</a>を採用していて、<code>NaN</code>もIEEE 754で定義されている値です。
<code>NaN</code>はNot a Numberの略称で、特殊な性質をもつNumber型のデータです。</p>

<p>また、<code>NaN</code>は何と演算しても結果は<code>NaN</code>になる特殊な値です。
次のように、計算の途中で値が<code>NaN</code>になると、最終的な結果も<code>NaN</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="kc">NaN</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// =&gt; 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
</code></pre></div>
<p>しかし、<code>NaN</code>はNumber型の一種であるという名前と矛盾したデータに見えますが仕様です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// NaNはnumber型</span>
<span class="k">typeof</span> <span class="kc">NaN</span><span class="p">;</span> <span class="c1">// =&gt; &quot;number&quot;</span>
</code></pre></div>
<p>NaNしか持っていない特殊な性質として、自分自身と一致しないという特徴があります。
この特徴を利用することで、ある値が<code>NaN</code>であるかを判定することもできます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">isNaN</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// NaNは自分自身と一致しない</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">isNaN</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// =&gt; false</span>
<span class="nb">isNaN</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">);</span> <span class="c1">// =&gt; false</span>
<span class="nb">isNaN</span><span class="p">({});</span> <span class="c1">// =&gt; false</span>
<span class="nb">isNaN</span><span class="p">([]);</span> <span class="c1">// =&gt; false</span>
<span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>同様の処理を行う方法としてES2015から<code>Number.isNaN(x)</code>メソッドが追加されています。
実際に値が<code>NaN</code>かを判定する際には、<code>Number.isNaN(x)</code>メソッドを利用するとよいでしょう。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>注記: <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/isNaN" title="isNaN()">isNaN()</a>というグローバル関数もありますが、こちらは引数を暗黙的にNumber型へ変換してから<code>NaN</code>かどうかを判定します。</p>

<p>暗黙的な変換をしてしまうことで、明らかにバグっているような挙動を引き起こすため使わないようにしましょう。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// グローバルの`isNaN`関数</span>
<span class="c1">// 上で作ったisNaN関数とは別もの</span>
<span class="nb">isNaN</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="c1">// `isNaN`関数は以下のようなことをやっているのと同じ</span>
<span class="c1">// Numberコンストラクタ関数で変換してから、`Number.isNumber`で判定するのと同じようなもの</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">));</span><span class="c1">// =&gt; true</span>
<span class="c1">// 安全に使うならxが number か判定してから isNaNで判定する</span>
<span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span> <span class="o">&amp;&amp;</span> <span class="nb">isNaN</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div>
<p><code>NaN</code>は暗黙的な型変換の中でももっとも避けたい値となります。
理由として、先ほど紹介したように<code>NaN</code>は何と演算しても結果が<code>NaN</code>となってしまうためです。
これにより、計算していた値がどこで<code>NaN</code>となったのかが分かりにくく、デバッグが難しくなります。</p>

<p>たとえば、次の<code>sum</code>関数は可変長引数（任意の個数の引数）を受け取り、その合計値を返します。
しかし、<code>sum(x, y, z)</code>と呼び出した時の結果が<code>NaN</code>になってしまいました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 任意の個数の数値を受け取り、その合計値を返す関数</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">total</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
</code></pre></div>
<p>よく注意して見ると、<code>y</code>の値が未定義となっています。
そのため、<code>sum(1, undefined, 10);</code>と呼ばれていたのと同じ結果になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
<span class="c1">// 計算中にNaNとなったため最終結果もNaNになった</span>
<span class="mi">1</span> <span class="o">+</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// =&gt; NaN</span>
<span class="kc">NaN</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// =&gt; NaN</span>
</code></pre></div>
<p>これは、<code>sum関数</code>において引数を明示的にNumber型へ変換したとしても回避することはできません。
つまり、次のように明示的な型変換しても解決できない問題あることが分かります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `value`をNumberで明示的に変換して扱ったバージョン</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">total</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">total</span> <span class="o">+</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; NaN</span>
</code></pre></div>
<p>この意図しない<code>NaN</code>への変換を避ける方法として、大きく分けて２つの方法があります。</p>

<ul>
<li><code>sum</code>関数側（呼ばれる側）で、Number型の値以外を受け付けなくする</li>
<li><code>sum</code>関数を呼び出す側で、Number型の値のみを渡すようにする</li>
</ul>

<p>つまり、呼び出す側または呼び出される側で対処するということですが、
どちらも行うことがより安全なコードにつながります。</p>

<p>そのためには、<code>sum</code>関数が数値のみを受け付けるということを明示する必要があります。</p>

<p>明示する方法として<code>sum</code>関数のドキュメント（コメント）として記述したり、
引数に数値以外の値がある場合は例外を投げるという処理を追加するといった形です。</p>

<p>JavaScriptではコメントで引数の型を記述する書式として<a href="http://usejsdoc.org/" title="Use JSDoc: Index">JSDoc</a>が有名です。
また、<a href="http://www.typescriptlang.org/" title="TypeScript - JavaScript that scales.">TypeScript</a>や<a href="https://flowtype.org/" title="Flow">Flow</a>を使うことで型定義や静的チェックもできます。</p>

<p>ランタイム時に値をチェックし例外または警告を表示する関数として<code>console.assert(条件式, メッセージ)</code>メソッドが多くの実行環境で利用できます。
(Node.jsだと例外をなげ、ブラウザだとコンソールへの警告になります)</p>

<p>この２つを利用して<code>sum</code>関数の前提条件を詳細に実装したものは次のようになります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/**</span>
<span class="cm"> * 数値を合計した値を返します。</span>
<span class="cm"> * 一つ以上の数値と共に呼び出す必要があります。</span>
<span class="cm"> * @param {...number} values</span>
<span class="cm"> * @returns {number}</span>
<span class="cm"> **/</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">total</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 第一引数の評価結果がtrueではない場合、第二引数のメッセージが警告として出る</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span><span class="err">は</span><span class="nb">Number</span><span class="err">型ではありません`</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">total</span> <span class="o">+</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
<span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; AssertionError</span>
</code></pre></div>
<p>JSDocに書いたことを<code>console.assert</code>でも実装しているのが気になります。
Babelを使って変換している場合は<a href="https://github.com/azu/babel-preset-jsdoc-to-assert" title="babel-preset-jsdoc-to-assert">babel-preset-jsdoc-to-assert</a>を使うことで、JSDocから同等のassertionへ自動的に変換することができます。</p>

<ul>
<li><a href="http://akabeko.me/blog/2016/08/jsdoc-to-assert/" title="jsdoc-to-assert を試す – アカベコマイリ">jsdoc-to-assert を試す – アカベコマイリ</a></li>
</ul>

<hr>

<p>おまけ: さらに意地悪なことをすると、先ほどの<code>sum</code>関数に引数として<code>NaN</code>を渡すと、<code>NaN</code>はNumber型なのでassertをすり抜けることができます。
そのため、typeofではなく、<code>Number.isFinite(value)</code>を使い有限数かをチェックし、コメントもそのように書き換えるとより渡す値が明確になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/**</span>
<span class="cm"> * 数値を合計した値を返します。</span>
<span class="cm"> * 一つ以上の有限数と共に呼び出す必要があります。</span>
<span class="cm"> * @param {...number} values</span>
<span class="cm"> * @returns {number}</span>
<span class="cm"> **/</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">total</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// NaNがきたらassertで落ちる</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span><span class="err">は有限数ではありません`</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">total</span> <span class="o">+</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
<span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; AssertionError</span>
</code></pre></div>
<p><code>console.assert</code>なども今は<a href="https://github.com/twada/unassert" title="unassert">unassert</a>を使えばproductionビルドからは簡単に取り除けるので、気軽に使うようにしても問題ないと思います。</p>

<hr>

<p>このように、<code>sum</code>関数はどのように使うべきかを明示することで、
エラーとなった時に呼ばれる側と呼び出し側でどちらに問題があるのかが明確になります。
この場合は、<code>sum</code>関数へ<code>undefined</code>な値を渡している呼び出し側に問題があります。</p>

<p>関数/モジュールの責務をどう実装するかという設計の方針としては、防御的プログラミングや契約による設計など色々あると思いますが、<a href="https://twitter.com/t_wada">誰かが</a>分かりやすく解説してくれると信じています。</p>

<h3 id="おわりに">おわりに</h3>

<p>JavaScriptは、Number型へ値を変換した場合に<code>NaN</code>となってしまうことがあります。
多くの場合、何らかの暗黙的な型変換が処理中に発生して<code>NaN</code>となっていることが多いです。
(または<code>parseInt</code>後に<code>Number.isNaN</code>でチェックしていないなど)</p>

<p>そのため、JavaScriptでアプリケーションを書く場合は、このような検出しにくいバグを見つけられるように書くことは重要です。</p>

<p>というような話を<a href="https://asciidwango.github.io/js-primer/basic/implicit-coercion/" title="暗黙的な型変換 · JavaScriptの入門書 #jsprimer">暗黙的な型変換 · JavaScriptの入門書 #jsprimer</a>で書きました。(暗黙的な型変換についてがメインで<code>NaN</code>はおまけ)</p>

<p>まだまだ書いてる最中なので、興味がある人は<a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a>を見てみてください。</p>

<p>基本の基本は書いたのですが、まだどういうことを書くべきか迷っている部分も多いので、以下のIssueに意見をください。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer/issues/137" title="Meta(基本文法): ロードマップ · Issue #137 · asciidwango/js-primer">Meta(基本文法): ロードマップ · Issue #137 · asciidwango/js-primer</a></li>
</ul>
 ]]></content>
 </entry>
 

</feed>
