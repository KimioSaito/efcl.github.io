<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Web Scratch</title>
 <link href="http://efcl.info/feed/" rel="self"/>
 <link href="http://efcl.info"/>
 <updated>2018-03-07T14:55:25+09:00</updated>
 <id>http://efcl.info/</id>
 
 <author>
   <name>azu</name>
   
 </author>
 

 
 <entry>
   <title>ECMAScriptの仕様/プロポーザルの調べ方を知る</title>
   <link href="http://efcl.info/2018/03/07/ecmascript-usage/"/>
   <updated>2018-03-07T11:54:00+09:00</updated>
   <id>http://efcl.info/2018/03/07/ecmascript-usage</id>
   <content type="html"><![CDATA[ <h2 id="はじめに">はじめに</h2>

<p>この文章は<a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a>で書いた<a href="https://asciidwango.github.io/js-primer/basic/ecmascript/" title="ECMAScript · JavaScriptの入門書 #jsprimer">ECMAScript</a>の章が元となっています。</p>

<p>また、<a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a>というスライドでどのようの話をしているのであわせて参照してみてください。</p>

<blockquote>
<p>スライド: <a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a></p>
</blockquote>

<h2 id="ecmascript">ECMAScript</h2>

<p>ECMAScriptは<a href="http://www.ecma-international.org/" title="Ecma International">Ecma International</a>という団体によって標準化されている仕様です。
Ecma InternationalはECMAScript以外にもC#やDartなどの標準化作業を行っています。
Ecma International中のTechnical Committee 39（TC39）という技術委員会が中心となって、ECMAScript仕様についてを議論しています。
この技術委員会はMicroSoft、Mozilla、Google、AppleといったブラウザベンダーやECMAScriptに関心のある企業などによって構成されます。</p>

<h2 id="ecmascriptのバージョンの歴史">ECMAScriptのバージョンの歴史</h2>

<p>ここで、簡単にECMAScriptのバージョンの歴史を振り返ってみましょう。</p>

<table>
<thead>
<tr>
<th>バージョン</th>
<th>リリース時期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1997年6月</td>
</tr>
<tr>
<td>2</td>
<td>1998年6月</td>
</tr>
<tr>
<td>3</td>
<td>1999年12月</td>
</tr>
<tr>
<td>4</td>
<td>破棄</td>
</tr>
<tr>
<td>5</td>
<td>2009年12月</td>
</tr>
<tr>
<td>5.1</td>
<td>2011年6月</td>
</tr>
<tr>
<td>2015</td>
<td>2015年6月</td>
</tr>
<tr>
<td>2016</td>
<td>2016年6月</td>
</tr>
<tr>
<td>2017</td>
<td>2017年6月</td>
</tr>
</tbody>
</table>

<!-- textlint-disable -->

<p>ES5.1からES2015がでるまで4年もの歳月がかかっているの対して、ES2015以降は毎年リリースされています。
毎年安定したリリースを行えるようになったのは、ES2015以降は仕様策定プロセスの変更が行われたためです。</p>

<!-- textlint-enable -->

<h2 id="living-standardとなるecmascript">Living StandardとなるECMAScript</h2>

<p>現在、ECMAScriptの仕様書のドラフトはGitHub上の<a href="https://github.com/tc39/ecma262" title="tc39/ecma262: Status, process, and documents for ECMA262">tc39/ecma262</a>で管理されており日々更新されています。
そのため、本当の意味での最新のECMAScript仕様は<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>となります。
このように更新ごとにバージョン番号を付けずに、常に最新版を公開する仕様のことを<strong>Living Standard</strong>と呼びます。</p>

<p>ECMAScriptはLiving Stadardですが、これに加えてECMAScript 2017のようにバージョン番号をつけたものも公開されています。
このバージョン付きECMAScriptは、毎年決まった時期のドラフトを元にしたスナップショットのようなものです。</p>

<p>ブラウザなどに実際にJavaScriptとして実装される際には、Living StandardのECMAScriptを参照しています。
これは、ブラウザ自体も日々更新されるものであり、決まった時期にしかリリースされないバージョン付きよりもLiving Standardの方が適当であるためです。</p>

<h2 id="仕様策定のプロセス">仕様策定のプロセス</h2>

<p>ES2015以前はすべての仕様の合意が取れるまで延々と議論を続けすべてが決まってからリリースされていました。
そのため、ES2015がリリースされるまでには4年もの歳月がかかり言語の進化が停滞していました。
この問題を解消するために、TC39は毎年リリースするためにECMAScriptの策定プロセスを変更しました。</p>

<p>この策定プロセスはES2015がリリース後に適応され、このプロセスで初めてリリースされたのがES2016となります。
ES2016以降では、次のような仕様策定のプロセスで議論を進めて仕様が決定されています。</p>

<p>仕様に追加する機能（API、構文など）をそれぞれ個別の<strong>プロポーザル</strong>（提案書）として進めていきます。
現在策定中のプロポーザルはGitHub上の<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>に一覧が公開されています。
それぞれのプロポーザルは責任者である<strong>チャンピオン</strong>と<strong>ステージ</strong>（Stage）と呼ばれる<code>0</code>から<code>4</code>の5段階の状態を持ちます。</p>

<table>
<thead>
<tr>
<th style="text-align:center">ステージ</th>
<th>ステージの概要</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td>アイデアの段階</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>機能提案の段階</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>機能の仕様書ドラフトを作成した段階</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>仕様としては完成しており、ブラウザの実装やフィードバックを求める段階</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>仕様策定が完了し、2つ以上の実装が存在している。<br />正式にECMAScriptにマージできる段階</td>
</tr>
</tbody>
</table>

<p>このステージの詳細については<a href="https://tc39.github.io/process-document/" title="The TC39 Process">The TC39 Process</a>を参照してください。</p>

<p>2ヶ月に1度行われるTC39のミーティングにおいて、プロポーザルごとにステージを進めるかどうかを議論します。
このミーティングの議事録もGitHub上の<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>にて公開されています。
ステージ4となったプロポーザルはドラフト版である<a href="https://github.com/tc39/ecma262" title="tc39/ecma262: Status, process, and documents for ECMA262">tc39/ecma262</a>へマージされます。
そして毎年の決まった時期にドラフト版を元にして<code>ECMAScript 20XX</code>としてリリースします。</p>

<p>この仕様策定プロセスの変更は、ECMAScriptに含まれる機能の形にも影響しています。</p>

<p>たとえば、<code>class</code>構文の策定は<strong>最大限に最小のクラス</strong>（maximally minimal classes）と呼ばれる形で提案されています。
これによりES2015で<code>class</code>構文が導入されましたが、クラスとして合意が取れる最低限の機能だけの状態で入りました。
その他のクラスの機能は別のプロポーザルとして提案され、ES2015以降に持ち越された形で議論が進められています。</p>

<p>このような合意が取れる最低限の形でプロポーザルを進めていくのには、ES4の苦い失敗が背景にあります。
ES4ではECMAScriptに多くの変更を入れることを試みましたが、TC39内でも意見が分かれ最終的に合意できませんでした。
これによりES4の策定に割いた数年分のリソースが無駄となってしまったという経緯があります。</p>

<p>詳しくはES2015のエディタであるAllenさんによる<a href="http://wirfs-brock.com/allen/files/papers/standpats-asianplop2016.pdf">プログラミング言語標準化</a>というPaperにかかれています。</p>

<p>またES2016以降の策定プロセスでも、すべてのプロポーザルが仕様に入るわけではありません。
別の代替プロポーザルが出た場合や後方互換性と保てない場合などにプロポーザルの策定を中断する場合があります。
しかし、この場合でもプロポーザルという単位であるため策定作業の無駄は最小限で済みます。
このようにモジュール化されたプロポーザルは入れ替えがし易いという性質もあります。</p>

<h2 id="プロポーザルの機能を試す">プロポーザルの機能を試す</h2>

<p>ECMAScriptの策定プロセスのステージ4に「2つ以上の実装が存在している」という項目があります。
そのためブラウザのJavaScriptエンジンには、策定中のプロポーザルが実装されている場合があります。
多くの場合は試験的なフラグ付きで実装されておりフラグを有効化することで、試すことができるようになっています。</p>

<p>またTranspilerやPolyfillといった手段で、プロポーザルの機能をエミュレートできる場合があります。</p>

<p>Transpilerとは、新しい構文を既存の機能で再現できるようにソースコードを変換するツールのことです。
たとえば、ES2015で<code>class</code>構文が導入されましたが、ES5では<code>class</code>は予約語であるため構文エラーとなり実行することはできません。
Transpilerでは、<code>class</code>構文を含むソースコードを<code>function</code>キーワードを使い擬似的に再現するコードへ変換します。
Transpilerとしては<a href="https://babeljs.io/" title="Babel · The compiler for writing next generation JavaScript">Babel</a>や<a href="https://www.typescriptlang.org/" title="TypeScript - JavaScript that scales.">TypeScript</a>などが有名です。</p>

<p>Polyfillとは、新しい関数やメソッドなどの仕様を満たすような実装を提供するライブラリのことです。
たとえば、ES2016では<code>Array#inclues</code>というメソッドが追加されました。
構文とは異なり<code>Array#inclues</code>のようなメソッドはビルトインオブジェクトを書き換えることで実装できます。
Polyfillを提供するものとしては<a href="https://github.com/zloirock/core-js" title="zloirock/core-js: Standard Library">core-js</a>や<a href="https://polyfill.io/v2/docs/" title="Polyfill service">polyfill.io</a>などが有名です。</p>

<p>注意点としてはTranspilerやPolyfillはあくまで既存の機能で新しい機能を再現を試みているだけに過ぎません。
そのため、既存の機能で再現ができないプロポーザル（機能）はTranspilerやPolyfillでは再現できません。
また、完全な再現はできていないことがあるためTranspilerやPolyfillを新しい機能を学ぶために使うべきではありません。</p>

<!-- Notes: バージョンが西暦となった理由

実際に各ブラウザなどはECMAScriptを実装していますが、このときに参照するのは基本的にLiving StandardであるECMAScriptです。
また、PolyfillやTranspilerといった手段で、タグ付けされたECMAScript 20XXがリリースされる前にその機能が利用できることも多いです。
ECMAScriptのバージョンとしてES6ではなくES2015のように西暦をバージョンとして使うようになったのも、Living Standardを意識しての試みです。

-->

<h2 id="仕様や策定プロセスを知る意味">仕様や策定プロセスを知る意味</h2>

<p>こうしたECMAScriptという仕様や策定プロセスを知る意味は何があるのでしょうか？
主に次のような理由で知る意味があると考えています。</p>

<ul>
<li>言語を学ぶため</li>
<li>言語が進化しているため</li>
<li>情報の正しい状態を調べるため</li>
</ul>

<h3 id="言語を学ぶため">言語を学ぶため</h3>

<p>もっとも単純な理由はJavaScriptという言語そのものを学ぶためです。
言語の詳細を知りたい場合にはECMAScriptという仕様を参照できます。</p>

<p>しかしながら、JavaScriptにおいては言語機能に関しては<a href="https://developer.mozilla.org/ja/" title="MDN Web Docs">MDN Web Docs</a>という優れたリファレンスサイトなどがあります。
そのため、使い方を覚えたいなどの範囲ではECMAScriptの仕様そのものを参照する機会は少ないでしょう。</p>

<h3 id="言語が進化しているため">言語が進化しているため</h3>

<p>ECMAScriptはLiving Standardであり、日々更新されています。
これは、言語仕様に新しい機能や修正などが常に行われていることを表しています。</p>

<p>ECMAScriptは後方互換性を尊重するため、今学んでいることが無駄になるわけではありません。
しかしながら言語自体も進化していることは意識しておくとよいでしょう。</p>

<p>ECMAScriptのプロポーザル（機能）は問題を解決するために提案されます。
そのプロポーザルがECMAScriptにマージされ利用できる場合、その機能が何を解決するために導入されたのか知ることは大切です。
その際には、ECMAScriptの策定プロセスを知っておくことが調べることに役立ちます。</p>

<p>この仕様はなぜこうなったのかということを知りたいと思ったときに、その機能がどのような経緯で入ったのかを調べる手段をもつことは大切です。
特にES2015以降は策定プロセスもGitHubを利用したオープンなものとなり、過去の記録なども探しやすくなっています。</p>

<h3 id="情報の正しい状態を調べるため">情報の正しい状態を調べるため</h3>

<p>JavaScriptは幅広く使われている言語であるため、世の中には膨大な情報があります。
そして、検索して見つかる情報には正しいものや間違ったものが混在しています。</p>

<p>その中においてECMAScriptの仕様やその策定中のプロポーザルに関する情報は状態が明確です。
基本的にECMAScriptの仕様に入ったものは、後方互換性を維持するために破壊的変更は殆ど行なえません。
プロポーザルはステージという明示された状態があり、ステージ4未満の場合はまだ安定していないことが分かります。</p>

<p>そのため、問題を見つけた際に該当する仕様やプロポーザルを確認してみることは重要です。</p>

<p>これはECMAScriptにかぎらず、ウェブやブラウザに関する情報に関しては同じことがいえます。
ブラウザ関してはHTML、DOM API、CSSなどもオープンな仕様とそれぞれ策定プロセスが存在しています。</p>

<h3 id="ここまでのまとめ">ここまでのまとめ</h3>

<p>JavaScriptと一言にいってもECMAScript、ブラウザ、Node.js、WebAssembly、WebGL、WebRTCなど幅広い分野があります。
そのためすべてのことを知っている必要はありませんし、知っている人もおそらくいないでしょう。
このような状況下においては知識そのものよりも、それについて知りたいと思ったときに調べる方法を持っていることが大切です。</p>

<p>なにごとも突然全く新しい概念が増えるわけではなく、ものごとには過程が存在します。
ECMAScriptにおいては策定プロセスという形でどのような段階であるかが公開されています。
つまり、仕様にいきなり新しい機能が増えるのではなくプロポーザルという段階を踏んでいます。</p>

<p>日々変化しているソフトウェアにおいては、自身に適切な調べ方をもつことが大切です。</p>

<h2 id="具体例">具体例</h2>

<p>話しだけ見てもよくわからないと思うので、ここからは具体的な使い方の話です。</p>

<p>どのような場合に仕様やプロポーザルを調べたりするのか、またどのように調べるかについてです。</p>

<h2 id="実装が仕様に準拠しているかを調べたい">実装が仕様に準拠しているかを調べたい</h2>

<p>あるブラウザ/JavaScriptエンジンの挙動が仕様なのかを調べたいときがあります。</p>

<p>それぞれのメジャーブラウザはJavaScriptエンジンを各自実装しています。
そのため、どれかのブラウザが間違った実装だった場合に結果を比較することで分かる可能性があります。</p>

<p><a href="https://github.com/bterlson/eshost-cli">eshost-cli</a>というツールを使うことで、ローカルにインストール済みのJavaScriptエンジンでの実行結果をまとめて出力してくれます。
それぞれのJavaScriptエンジンをインストールするには<a href="https://github.com/GoogleChromeLabs/jsvu">jsvu</a>を使うのが簡単です。</p>

<ul>
<li><a href="https://github.com/GoogleChromeLabs/jsvu">GoogleChromeLabs/jsvu: JavaScript (engine) Version Updater</a>

<ul>
<li>主要なJavaScriptエンジンをまとめてインストール</li>
<li>macOSならChakraを含めてほぼ対応できる</li>
</ul></li>
<li><a href="https://github.com/bterlson/eshost-cli">bterlson/eshost-cli: Run ECMAScript code uniformly across any ECMAScript host</a>

<ul>
<li>指定したJavaScriptエンジンでコードを実行できる</li>
</ul></li>
</ul>

<p>次のように各種JavaScriptエンジンをインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># jsvuとeshostをインストール
npm install jsvu eshost-cli -g
# インストール先
export PATH=&quot;${HOME}/.jsvu:${PATH}&quot;
# JavaScriptエンジンをまとめてインストールしてくれる
jsvu
# インストールしたJavaScriptエンジンをeshotに登録
eshost --add &#39;Chakra&#39; ch ~/.jsvu/chakra
eshost --add &#39;JavaScriptCore&#39; jsc ~/.jsvu/javascriptcore
eshost --add &#39;SpiderMonkey&#39; jsshell ~/.jsvu/spidermonkey
eshost --add &#39;V8&#39; d8 ~/.jsvu/v8
</code></pre></div>
<p>後は、eshostでコードを実行するだけです。
次のコードではV8だけ結果が異なることが分かります。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># eshotでコードを実行
eshost -e &#39;new RegExp(&quot;\n&quot;).toString()&#39;
#### Chakra
/\n/

#### SpiderMonkey
/\n/

#### JavaScriptCore
/\n/

#### V8
/
/
</code></pre></div>
<p>このようにECMAScriptレベルのコードでJavaScriptエンジンの結果に差異がある場合は、大抵は実装依存の問題か実装の間違いといったケースになります。</p>

<h2 id="ecmascriptの仕様を読む">ECMAScriptの仕様を読む</h2>

<p>あるコードの実行結果が正しいのかを検証するためにECMAScriptの仕様書を読むことが参考になる場合があります。ECMAScriptの仕様書は2箇所にありますが基本的にはLiving Standard版を参照するのがよいでしょう(特定のバージョンに関するときはスナップショット版を参照します)</p>

<ul>
<li>スナップショット版: <a href="https://www.ecma-international.org/ecma-262/">https://www.ecma-international.org/ecma-262/</a></li>
<li>Living Standard版: <a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a></li>
</ul>

<p>ECMAScriptの仕様を読む機会はそこまで多くないと思いますが、Transpilerのような変換したコードの結果が異なる場合は仕様そのものを見てみるとどこにバグを報告すれば良いのかが明確になります。例えば、次の例はクラスのメソッド定義の挙動がBabelとTypeScriptで異なるケースです。</p>

<h3 id="例-babelとtypescriptのクラス">例: BabelとTypeScriptのクラス</h3>

<p>次のコードはBabelとTypeScriptでES5相当への変換と実行結果が異なります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span>
</code></pre></div>
<h4 id="babel-preset-envのデフォルト">Babel(preset-envのデフォルト)</h4>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">_createClass</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="kd">function</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">||</span> <span class="kc">false</span><span class="p">;</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">writable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">protoProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">protoProps</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nx">staticProps</span><span class="p">)</span> <span class="nx">defineProperties</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">,</span> <span class="nx">staticProps</span><span class="p">);</span> <span class="k">return</span> <span class="nx">Constructor</span><span class="p">;</span> <span class="p">};</span> <span class="p">}();</span>

<span class="kd">function</span> <span class="nx">_classCallCheck</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">Constructor</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">Constructor</span><span class="p">))</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">MyClass</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">_createClass</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">,</span> <span class="p">[{</span>
        <span class="nx">key</span><span class="o">:</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">method</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}]);</span>

    <span class="k">return</span> <span class="nx">MyClass</span><span class="p">;</span>
<span class="p">}();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span> <span class="c1">// =&gt; []</span>
</code></pre></div>
<h4 id="typescript-target-es5">TypeScript(target:es5)</h4>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
    <span class="k">return</span> <span class="nx">MyClass</span><span class="p">;</span>
<span class="p">}());</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span> <span class="c1">// =&gt; [&quot;method&quot;]</span>
</code></pre></div>
<p>変換結果も異なりますが、実行結果（コンソールへの出力)も異なります。</p>

<ul>
<li>Babelはメソッド（プロパティ）は列挙されないので <code>[]</code></li>
<li>TypeSdriptはメソッド（プロパティ）が列挙されるので <code>[&quot;method&quot;]</code></li>
</ul>

<p>このようなときにどちらが仕様準拠の挙動なのかはを仕様を調べてみましょう。</p>

<h3 id="仕様書の調べ方">仕様書の調べ方</h3>

<p>先ほども書きましたが、ECMAScriptにはLiving Standardの<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>とスナップショット版の<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>があります。
このケースではどちらでも良いですが、<a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a>の方が使いやすいこともあるので、こちらで見ていきます。</p>

<p>今回の目的は「<code>class</code>構文のメソッド定義の仕方を調べたい」です。
このような構文自体の挙動を調べたい場合は、次のような流れで探していきます。</p>

<p>大きな流れ</p>

<ol>
<li><code>class</code> というSyntaxの定義を探す</li>
<li><code>class</code>のRuntime Semantics(Syntaxにはそれぞれ実行時に何をするかという定義がある)</li>
<li>Runtime Semanticsでそれぞれの <code>method(){}</code> がどのように定義されているかを見ていく</li>
<li>今回は列挙されているかなので <code>enumerable</code> を調べる</li>
</ol>

<p>仕様書を上記の流れで調べている動画を撮ったので参考にしてみてください。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/xT8GupiJIio" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>仕様書を見た結果、クラスのメソッドは必ず<code>enumerable</code>を<code>false</code>で定義されています。
そのため、Babelは仕様に準拠するためにdefinePropertyで列挙しないように(<code>enumerable</code>を<code>false</code>)定義していますが、
TypeScriptは単純にプロトタイプオブジェクトのメソッドを追加してるだけなので列挙されています。</p>

<p>このIssueは既にありますが、パフォーマンスの問題などあるので一概にどちらが良いとも言えません。
(Babelもlooseで似たような変換にできます)</p>

<ul>
<li><a href="https://github.com/Microsoft/TypeScript/issues/15038" title="Method class enumerable · Issue #15038 · Microsoft/TypeScript">Method class enumerable · Issue #15038 · Microsoft/TypeScript</a></li>
</ul>

<h3 id="ecmascriptの読み方の補助資料">ECMAScriptの読み方の補助資料</h3>

<p>ECMAScriptの仕様書は巨大(800ページ以上)なので、基本的に上から下に読んでいくのは難しいです。
そのため、仕様書には目次検索、Pin（ブックマーク）、各リンクの逆引きなど便利な機能があるのでそれを活用して気になったものを読むのが良さそうです。</p>

<p>また、仕様書内で使われている記号や短縮記法などが<a href="https://tc39.github.io/ecma262/#sec-notational-conventions" title="Notational Conventions">Notational Conventions</a>にかかれています。また、次のサイトも仕様書を読むのに役立ちます。</p>

<ul>
<li><a href="https://timothygu.me/es-howto/" title="How to Read the ECMAScript Specification">How to Read the ECMAScript Specification</a>

<ul>
<li>ECMAScriptの読み方について解説してる</li>
<li><code>[[内部プロパティ]]</code>やAbstract Operator、Runtime semanticsなど仕様書に出てくる記号や読み方を解説してる</li>
</ul></li>
<li><a href="https://github.com/anba/es6draft" title="anba/es6draft: ECMAScript 2015 (ECMA-262 6th Edition) compiler and runtime">anba/es6draft: ECMAScript 2015 (ECMA-262 6th Edition) compiler and runtime</a>

<ul>
<li>ECMAScriptのJava実装</li>
<li>リファレンス実装的に仕様書と対応したアルゴリズムステップで実装されているので読みやすい</li>
<li><a href="https://github.com/anba/es6draft/blob/7e196e8a1482384ca83946998f5fbd22068b47c6/src/main/java/com/github/anba/es6draft/compiler/DefaultCodeGenerator.java#L1609-L1825" title="ClassDefinitionEvaluation">ClassDefinitionEvaluation</a>の実装もそのままある</li>
</ul></li>
</ul>

<p>今回は構文を見ていましたが、メソッドなど実際にJavaScriptのAPIに存在するものはもっと読みやすいです。
<a href="https://tc39.github.io/ecma262/#sec-string.prototype.includes" title="String.prototype.includes ( searchString [ , position ] )">String.prototype.includes ( searchString [ , position ] )</a>のように仕様がほぼそのまま実行ステップになっているので比較的単純です。</p>

<h2 id="例-js-primerの場合">例: <a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>の場合</h2>

<ul>
<li>サイト: <a href="https://asciidwango.github.io/js-primer/" title="この書籍について · JavaScriptの入門書 #jsprimer">この書籍について · JavaScriptの入門書 #jsprimer</a></li>
<li>リポジトリ: <a href="https://github.com/asciidwango/js-primer">github.com/asciidwango/js-primer</a></li>
</ul>

<p>最近、<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>というES21015以降を基本としたJavaScriptの入門書を書いています。
この書籍はLiving StandardであるECMAScriptに追従するように書いています。</p>

<hr>

<p><a href="https://github.com/asciidwango/js-primer"><img src="http://azu.github.io/slide/2018/node/img/repo-actions-watch.png" alt="inline, repo-actions-watch.png"></a></p>

<p>興味ある人はStarやWatchしてください。</p>

<hr>

<p>この書籍では、どのように説明するべきか迷った場合はECMAScriptを参照しています。
例えば用語の問題や、説明するためにどのような表現を使うべきか、実際の仕様的な動作を元にしています。</p>

<p>単純に今存在するブラウザなどの挙動を元にすれば、ほとんどのケースでは問題はありません。
ブラウザはできる限り仕様に準拠した実装にするためです。</p>

<p>しかし、その機能の仕組みを理解するとなるともう少し深掘りしてから解説を書く必要がでてきます。
なぜなら同じ結果になるような方法が考えられるためです。</p>

<p>そのような際には仕様書ではどのように定義しているのかを参考にしています。</p>

<h3 id="例1-関数とthisの表現-–-arrow-function">例1: <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis</a>の表現 – Arrow Function</h3>

<blockquote>
<p><code>function</code>キーワードで定義した関数は呼び出し時に、ベースオブジェクトが暗黙的な引数のように<code>this</code>の値として渡されます。
一方、Arrow Functionの関数は呼び出し時に<code>this</code>を受け取らないため、定義時のArrow Functionにおける<code>this</code>の参照先が静的に決定されます。
-- <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></p>
</blockquote>

<p>この部分だけ切り出してもちょっと分かりにくいですが、よくあるような「Arrow Functionは<code>this</code>をbindする」という説明にはしていません。
仕様ではArrowFunctionは<code>[[ThisValue]]</code>を持たないLexicalEnvironmentという定義になっていて、Arrow Functionが<code>this</code>を持つ(bind)わけではないからです。
そのため、「Arrow Functionは<code>this</code>をbindする」というよりは、「Arrow Functionは<code>this</code>を持たないので移譲する」と言ったほうが仕様に近いかもしれません。</p>

<p>この辺の説明はホントややこしいので、詳細は<a href="http://efcl.info/2018/01/04/what-is-this/" title="ECMAScript 2015以降のJavaScriptの`this`を理解する | Web Scratch">ECMAScript 2015以降のJavaScriptの<code>this</code>を理解する | Web Scratch</a>に譲ります。</p>

<p>実際に書いているときには以下のIssueのようにメモしながら、どのような表現が良いのかを考えながら書いています。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer/issues/316" title="関数とthis · Issue #316 · asciidwango/js-primer">関数とthis · Issue #316 · asciidwango/js-primer</a></li>
</ul>

<h2 id="例2-関数とthisの表現-–-thisの値">例2: <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis</a>の表現 – <code>this</code>の値</h2>

<p>また<code>this</code>の話ですが、<code>this</code>の解説をするためにあらゆる場所の<code>this</code>の挙動を調べていました。
<code>this</code>は普通はクラスぐらいにしか使いませんが、JavaScriptでは<code>this</code>はどこにでも書けます。
また、その時の<code>this</code>の値はコンテキスト変わります。</p>

<p>最初はブラウザやNode.jsで実行しながら調べていましたが、次の&quot;Module&quot;の挙動がブラウザによって違いました。
Chromeは<code>Window</code>、 その他のブラウザは<code>undefined</code>となりました。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>最初はChromeだけで試していたので、なぜ<code>Window</code>を返すのかが分かりませんでした。</p>

<p>Arrow Functionにおける<code>this</code>は外側のスコープの<code>this</code>を参照します。
そのため、次のようにトップレベルの<code>this</code>とトップレベルのArrow Functionにおける<code>this</code>は同じになるはずです。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="c1">// =&gt; undefined</span>
    <span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">()</span> <span class="o">===</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>&quot;Module&quot;コンテキストのトップレベル<code>this</code>は常に<code>undefined</code>ということは調べて知っていました。</p>

<ul>
<li><a href="http://efcl.info/2015/05/06/this-is-es6-module/" title="ES6 moduleのtop levelにある`this`の値は何になるのか? | Web Scratch">ES6 moduleのtop levelにある<code>this</code>の値は何になるのか?</a></li>
</ul>

<p>なので、最初のコードは<code>undefined</code>になるはずで、何か自分の仕様の解釈が間違っているのかなと思いました。</p>

<p>他のブラウザでの挙動も調べてみようと思い、<code>this</code>の値の一覧を出すサイトを作りました。</p>

<ul>
<li><a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a></li>
</ul>

<p>ここでChromeが何かおかしいのではないかと思いバグ報告をしました。</p>

<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791334" title="791334 - `this` in top level Arrow Function in Module Context should be `undefined` - chromium - Monorail">791334 - <code>this</code> in top level Arrow Function in Module Context should be <code>undefined</code> - chromium - Monorail</a></li>
</ul>

<p>結果的にはChromeの問題だったため、Chrome 65で修正されています。</p>

<h2 id="プロポーザルのステータスを知りたい">プロポーザルのステータスを知りたい</h2>

<p>プロポーザルの今のステータスを知りたい場合があります。
例えばあるライブラリがプロポーザル段階の書き方をREADMEに書いていたり、記事で「これが最新版」のような記述があった場合に、実際のステータスを知ることで異なる見かたができるようになります。</p>

<p>最初に紹介していたようにプロポーザルのステータスは0から4まであり、4以外は変更や廃止の可能性があるステータスとなります。</p>

<p>これはES2015以前ではなかった事例の１つです。なぜならES2015以前は策定プロセスが現在と異なるため、個別のプロポーザルのステータスを知る意味は殆どなかったためです。</p>

<p>これは<a href="http://azu.github.io/slide/2016/jser5years/javascript-information.html" title="JavaScript情報ってなんだっけ?">JavaScript情報ってなんだっけ?</a>でも触れています、比較的新しい悩みの一種となります。</p>

<p>プロポーザルの置き場所は決まっているため、ステータスの数値やTranspilerの実装は次のページを見ると確認できます。</p>

<ul>
<li><a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals: Tracking ECMAScript Proposals</a>

<ul>
<li>ECMAScriptのプロポーザル一覧</li>
</ul></li>
<li><a href="https://github.com/babel/proposals" title="babel/proposals: ✍️ Tracking the status of Babel&amp;#39;s implementation of TC39 proposals">babel/proposals: ✍️ Tracking the status of Babel&#39;s implementation of TC39 proposals</a>

<ul>
<li>Babelの実装との対応表</li>
</ul></li>
</ul>

<h2 id="このプロポーザルって進んでるの">このプロポーザルって進んでるの?</h2>

<p>ステータスは現時点での値にすぎないため、どちらかというとそのステータスが変化しているかを知りたい場合があると思います。</p>

<p>プロポーザルのステータスの変化を知りたい場合は次のサイトなどを購読するのが簡単でしょう。
また、<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>もただのGitHubリポジトリなのでそちらをWatchするのもいいでしょう。</p>

<ul>
<li><a href="https://ecmascript-daily.github.io/" title="ECMAScript Daily">ECMAScript Daily</a>

<ul>
<li>ECMAScript関係のニュースブログ(@azu)</li>
</ul></li>
<li><a href="http://ecmascript.in/" title="EcmaScript.in | Stay updated about EcmaScript proposal changes">EcmaScript.in | Stay updated about EcmaScript proposal changes</a>

<ul>
<li>プロポーザルのStage変化の通知メール</li>
</ul></li>
<li><a href="http://2ality.com/index.html" title="2ality – JavaScript and more">2ality – JavaScript and more</a>

<ul>
<li>プロポーザルの解説</li>
</ul></li>
</ul>

<h2 id="このプロポーザルはなぜ止まっているの">このプロポーザルはなぜ止まっているの?</h2>

<p>興味があるプロポーザルがある場合になぜそのプロポーザルのステータスが進まないかということに興味を持つひともいるでしょう。</p>

<p>プロポーザルにはそれぞれチャンピオンとなる責任者いて、そのチャンピオンが策定作業を進めることで初めてステージが進みます。
<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a> にかかれている :rocket: はプロポーザルのステージをチャンピオンが進める意志がある状態かを表しています。(頻繁に更新されるためあくまで参考情報に過ぎません)</p>

<p><img src="http://azu.github.io/slide/2018/node/img/rockets.png" alt="inline, rockets.png"></p>

<p>:rocket: マークがついていない場合やしばらくステージが更新されていないプロポーザルは何かしらの課題や問題を抱えています。
ここではそれのプロポーザルがどのような課題を持っていて、ステージが更新されないのかを見ていきます。</p>

<h3 id="例-tc39-proposal-global">例: <a href="https://github.com/tc39/proposal-global" title="tc39/proposal-global">tc39/proposal-global</a></h3>

<p><code>global</code>はグローバルオブジェクトを取得するプロポーザルです。
現在(2018年2月の段階)はStage 3で止まっています。</p>

<p>なぜ止まっているかの理由はREADMEに書いています。</p>

<blockquote>
<p>however, due to <a href="https://github.com/tc39/proposal-global/issues/20">web compatibility concerns</a>, it is on hold pending a new global identifier name.</p>
</blockquote>

<p><a href="https://github.com/tc39/proposal-global/issues/20" title="global breaks flickr.com · Issue #20 · tc39/proposal-global">global breaks flickr.com · Issue #20 · tc39/proposal-global</a>のIssueで具体的に話し合われています。
このIssueやREADMEをみることで、<code>global</code>という名前によって壊れるサイトがいる問題がありこれが理由で止まっていることが割ります。</p>

<hr>

<h4 id="tips">Tips</h4>

<ul>
<li>プロポーザルはそれぞれGitHubリポジトリを持っている</li>
<li>プロポーザルのIssueには課題が書かれている</li>
<li>ウェブ互換性の問題については基本的にメトリクスデータを元に話を進める

<ul>
<li>壊れるウェブサイトはn%あるか</li>
<li><a href="https://www.chromestatus.com/metrics/feature/popularity" title="Chrome Platform Status">Chrome Platform Status</a>、<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/data/" title="Microsoft Edge Platform Data - Microsoft Edge Development">Microsoft Edge Platform Data</a>、<a href="https://blog.mozilla.org/data/" title="Firefox Data">Firefox Data</a></li>
</ul></li>
</ul>

<hr>

<h3 id="例-tc39-proposal-decorators">例: <a href="https://github.com/tc39/proposal-decorators" title="tc39/proposal-decorators">tc39/proposal-decorators</a></h3>

<p><code>proposal-decorators</code>はデコレーターを導入するプロポーザルです。
現時点(2018年3月)ではStage 2となっています。</p>

<p><a href="https://ecmascript-daily.github.io/2016/07/30/last-minutes-proposals-changes" title="ECMAScript proposal updates @ 2016-07 | ECMAScript Daily">ECMAScript proposal updates @ 2016-07 | ECMAScript Daily</a>というプロポーザルのステージ更新の記事を見ると、2016年7月からずっとステージ2となっていることが分かります。</p>

<p>ここではデコレーターにはどのような問題がありステージが更新されていないのかを調べてみましょう。
プロポーザルは2ヶ月に1度行われるTC39のミーティングでステージを更新をするかを判断します。</p>

<p>つまり、<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>に公開されているミーティングのログを見ることでわかりそうです。
それぞれのミーティングはアジェンダが事前に用意されており、事前に何を話し合うかが決められています(時間は有限であるため)</p>

<p>このアジェンダは<a href="https://github.com/tc39/agendas" title="tc39/agendas">tc39/agendas</a>で公開されているので、まずはアジェンダからデコレーターについて議論した月のミーティングを探してみます。</p>

<ul>
<li>何が原因で進んでないのかを調べる</li>
<li>=&gt; TC39のミーティングでどのような議論が行われてるのかを調べる</li>
<li>=&gt; 何が課題となっているかが話し合われているはず</li>
</ul>

<p><a href="https://github.com/tc39/agendas" title="tc39/agendas">tc39/agendas</a>（議事録のアジェンダ）を&quot;<a href="https://github.com/tc39/agendas/search?o=desc&amp;q=Decorators&amp;s=indexed&amp;type=&amp;utf8=%E2%9C%93" title="Search · Decorators">Decorators</a>&quot;で検索すると、<a href="https://github.com/tc39/agendas/blob/385085dead6e4f08a2100eccc7b8738dec97f236/2018/01.md" title="agendas/2018/01.md">agendas/2018/01.md</a>にも議題となったことが分かります。</p>

<p><img src="http://azu.github.io/slide/2018/node/img/decorators-agenda.png" alt="right, decorators-agenda.png"></p>

<p>このアジェンダと同じ月のミーティングノートを<a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>で探すと<a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/summary.md" title="2018-01/summary.md">2018-01/summary.md</a>が見つかります。
ミーティングの議事録事態は長いですが、<code>summary.md</code>にはその内容がまとまっているのでまずはそちらを見てみます。</p>

<p><img src="http://azu.github.io/slide/2018/node/img/summary-decorator.png" alt="inline, summary-decorator.png"></p>

<p>デコレーターでの議事録や関連するスライドを見てみると、幾つかの課題がその課題を解決するまでステージ3にはできないという話が書かれています。</p>

<ul>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-25.md#13vc-decorators-towards-stage-3" title="13.v.c Decorators: towards Stage 3">13.v.c Decorators: towards Stage 3</a>という議論が2018年1月に行われている</li>
<li><a href="https://docs.google.com/presentation/d/1g6hrJp_nk_OeapuPXlkE4D_31OZbz4wQbXuIagsyoUI/edit#slide=id.p" title="Decorators: Towards Stage 3 - Google スライド">Decorators: Towards Stage 3 - Google スライド</a>

<ul>
<li>Stage 3に向けて何をサポートし、何をサポートしないかをはっきりさせる</li>
<li>他のクラスのプロポーザル(hard private)との協調性についての課題があり調整している</li>
<li>実装者、テスト作成者、ライブラリ作者に対しても意見を求めてる</li>
<li>次のミーティング(3月)までにステークホルダーにアプローチする</li>
</ul></li>
</ul>

<p>このような課題があるためデコレーターはまだステージ2となっています。
このようなことがミーティングログを見ることでわかります。</p>

<hr>

<h2 id="tips">Tips</h2>

<ul>
<li>Stage 1までアイデアや実験なのでプロポーザル間でも重複する</li>
<li>Stage 2+あたりからプロポーザル間での協調的な仕様を検討する

<ul>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#revisiting-mixins-vs-protocols-proposal" title="Revisiting mixins-vs-protocols proposal">Revisiting mixins-vs-protocols proposal</a></li>
</ul></li>
<li>Decoratorはclass field、privateなど色々関係する</li>
<li>最近のDecoratorの変更は他のプロポーザルとの協調性やDecoratorが目指す範囲を確定する作業

<ul>
<li>今まで雰囲気で動いてた部分を明示的に例外を投げるようにするなど</li>
</ul></li>
</ul>

<hr>

<h2 id="おわりに">おわりに</h2>

<p>最初に述べたようにここに書いてあることをすべて知る必要性はありません。
具体的に気になることを見つけたときにそれを調べる手段にたどり着ければ問題ありません。</p>

<p>また、ECMAScriptがLiving Standardであるという話をしましたが、Living Standardである以上その策定プロセスなども細かく修正されていきます。
以前、<a href="http://efcl.info/2015/10/18/ecmascript-paper/" title="ECMAScriptの仕様策定に関するカンニングペーパー | Web Scratch">ECMAScriptの仕様策定に関するカンニングペーパー | Web Scratch</a>で書いたものはES2015時点のものでしたが、現在も細かくプロセスが変わったりより分かりやすくなっています。(ミーティングログにサマリが増えたり、<a href="https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md" title="Contributing to ECMAScript">Contributing to ECMAScript</a>などのドキュメントが増えたりなど)</p>

<p>ECMAScriptはこのようなオープンな仕組みであり、同じくブラウザに乗る機能も現在はオープンな仕様や議論を元にしていることが多いです(例外はあります)。
そのため、仕様やその仕様がどのような経緯で実装されたかといった事実を調べることは特別に難しいことではありません。
このような状況においては、推測だけで行動したり推測だけの意見に影響を受けるよりも、事実を確認して見るほうが簡単な場合もあります。</p>

<p>知識そのものよりも調べ方を知ることが重要なのかもしれません。</p>

<h2 id="リンクまとめ">リンクまとめ</h2>

<p>この記事で紹介した簡単なリンクのまとめです。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer">js-primer</a>版: <a href="https://asciidwango.github.io/js-primer/basic/ecmascript/" title="ECMAScript · JavaScriptの入門書 #jsprimer">ECMAScript · JavaScriptの入門書 #jsprimer</a></li>
<li>ECMAScript関係の情報: <a href="https://twitter.com/ecmascriptdaily" title="@EcmascriptDaily">@EcmascriptDaily</a>をフォローしておけばとりあえず流れてくる</li>
<li>ECMAScriptのプロポーザル: <a href="https://github.com/tc39/tc39-notes" title="tc39/tc39-notes: TC39 Meeting Notes">tc39/tc39-notes</a>、<a href="https://github.com/tc39/proposals" title="tc39/proposals: Tracking ECMAScript Proposals">tc39/proposals</a>に殆どの情報がある</li>
<li>ECMAScriptの策定プロセス: <a href="https://tc39.github.io/process-document/" title="The TC39 Process">The TC39 Process</a>に書かれてる</li>
<li>ECMAScriptの仕様: <a href="https://github.com/tc39/ecma262" title="tc39/ecma262">tc39/ecma262</a>にLiving Standard</li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Node学園 29時限目でECMAScriptの調べ方について発表してきた</title>
   <link href="http://efcl.info/2018/02/22/node29/"/>
   <updated>2018-02-22T21:46:00+09:00</updated>
   <id>http://efcl.info/2018/02/22/node29</id>
   <content type="html"><![CDATA[ <p><a href="https://nodejs.connpass.com/event/78902/" title="Node学園 29時限目 - connpass">Node学園 29時限目 - connpass</a>に参加して<a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a>について発表してきた。</p>

<p>ECMAScriptの仕様や仕様を使ってなぜその仕様が入ったのかを調べる方法についてなどを話しました。</p>

<p>スライド: <a href="http://azu.github.io/slide/2018/node/ecmascript39.html" title="ECMAScriptの使い方">ECMAScriptの使い方</a></p>

<ul>
<li>ECMAScriptとは何か</li>
<li>ECMAScriptの使い方について</li>
<li>ECMAScript仕様書の読み方の動画: <a href="https://www.youtube.com/watch?v=xT8GupiJIio" title="ECMAScriptの`class`のメソッド定義を調べる - YouTube">ECMAScriptの<code>class</code>のメソッド定義を調べる - YouTube</a></li>
</ul>

<p><a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>に書いているので<a href="https://asciidwango.github.io/js-primer/basic/ecmascript/" title="ECMAScript · JavaScriptの入門書 #jsprimer">ECMAScript · JavaScriptの入門書 #jsprimer</a>を参照してみてください。</p>

<hr>

<p>以下メモ。</p>

<h2 id="nodeにコントリビュートし始めて一ヶ月でコラボレーターになった-by-leko">Nodeにコントリビュートし始めて一ヶ月でコラボレーターになった by Leko</h2>

<p>スライド: <a href="https://speakerdeck.com/leko/node-dot-jsnicontributesite-keyue-decollaboratorninatuta" title="Node.jsにContributeして一ヶ月でCollaboratorになった // Speaker Deck">Node.jsにContributeして一ヶ月でCollaboratorになった // Speaker Deck</a></p>

<ul>
<li>Node.jsのコラボレータになった話し</li>
<li>JavaScript OSS Contribution Guideというスライドがきっかけ</li>
<li><a href="https://kt3k.github.io/njs-talk/">https://kt3k.github.io/njs-talk/</a></li>
<li>Code + Learn

<ul>
<li>初めてのPRをコラボレータがサポートしてくれる</li>
</ul></li>
<li>Node学園祭 他の人の発表を見てもっとNode.jsに詳しくなってコラボレータを目指そうと思った</li>
<li>CTC、STC etc...

<ul>
<li><a href="http://abouthiroppy.hatenablog.jp/entry/2017/07/05/090952" title="Node.js FoundationとNode.jsについて - 技術探し">Node.js FoundationとNode.jsについて - 技術探し</a></li>
<li>Node.jsは広いのでどこにコントビュートしたいかを決める</li>
</ul></li>
<li>Code + Leranで 2 PRを出した</li>
<li>他のCode + Learnは簡単なものが多い</li>
<li>他の修正に手を出してみた

<ul>
<li>色々細かい問題がでてきた</li>
</ul></li>
<li>Node.jsのカバレッジを上げるコントビュート

<ul>
<li><a href="https://coverage.nodejs.org/" title="Node.js Code Coverage">Node.js Code Coverage</a></li>
</ul></li>
<li>Cryptoのテストのカバレッジが少し低かった

<ul>
<li>カバレッジを上げるIssueに取り組んでいる</li>
</ul></li>
<li>Streamのテストカバレッジを上げる</li>
<li>Node.js コラボレータのノミネートされた</li>
<li>OnBoarding Sessionに参加

<ul>
<li>TSCのメンバーとリアルタイムにやりとり</li>
<li>2FAを有効にするとか</li>
<li>自身をコラボレータ一覧に入れるPRする</li>
</ul></li>
<li>コラボレータになってレビューする

<ul>
<li>コンテキストがよくわからない問題がよくある</li>
</ul></li>
</ul>

<hr>

<h2 id="headless-chromeでクローリング-by-yuji-isobe">headless chromeでクローリング by yuji isobe</h2>

<p>スライド: <a href="https://speakerdeck.com/yujiosaka/an-gazui-chu-nihetudoresuchromedekurorazuo-tuta-shi-ninannekana" title="俺が最初にヘッドレスChromeでクローラ作った 事になんねーかな // Speaker Deck">俺が最初にヘッドレスChromeでクローラ作った 事になんねーかな // Speaker Deck</a></p>

<ul>
<li>EC専門家デビュー</li>
<li><a href="https://developers.google.com/web/updates/2017/04/headless-chrome?hl=ja" title="ヘッドレス Chrome ことはじめ  |  Web  |  Google Developers">ヘッドレス Chrome ことはじめ  |  Web  |  Google Developers</a></li>
<li>headless chromeのいいところ

<ul>
<li>Chromeに起動オプションを使える</li>
<li>標準への追従が早い</li>
</ul></li>
<li>クローラー

<ul>
<li>静的クローラー</li>
<li>HTMLとかの静的なサイトにリクエスト -&gt; パース</li>
<li>動的クローラー</li>
<li>JSで動く動的なサイトにリクエスト -&gt; パース</li>
<li>headless chromeはこちら</li>
</ul></li>
<li>動的クローラー

<ul>
<li><a href="https://chromedevtools.github.io/devtools-protocol/" title="Chrome DevTools Protocol Viewer">Chrome DevTools Protocol Viewer</a></li>
</ul></li>
<li>PhantomJSはメンテ終了</li>
<li>Headless Chromeを使うようになる</li>
<li>問題

<ul>
<li>APIが低レベル過ぎて使いにくい</li>
<li>仕様が不安定(experimental)</li>
<li>セキュリティのブロックに引っかかる</li>
<li>CSPなどかかったりする</li>
<li>結構バグが多い</li>
</ul></li>
<li><a href="https://github.com/GoogleChrome/puppeteer" title="GoogleChrome/puppeteer: Headless Chrome Node API">GoogleChrome/puppeteer: Headless Chrome Node API</a>

<ul>
<li>例レベルなHeadless Chromeより高レベルなAPI</li>
</ul></li>
<li><a href="https://github.com/GoogleChrome/puppeteer/tree/master/examples" title="puppeteer/examples">puppeteer/examples</a>

<ul>
<li>実用的なクローラーのサンプルがなかった</li>
<li>Node.jsでモダンなクローラーがまだなかった</li>
<li>Promise</li>
</ul></li>
<li><a href="https://github.com/yujiosaka/headless-chrome-crawler" title="yujiosaka/headless-chrome-crawler: Distributed crawler powered by Headless Chrome">yujiosaka/headless-chrome-crawler: Distributed crawler powered by Headless Chrome</a>

<ul>
<li>作った</li>
<li>Headless Chromeを使ったクローラーライブラリ</li>
</ul></li>
</ul>

<hr>

<h2 id="dynamic-import-あれこれ-by-小田島">Dynamic import あれこれ  by 小田島</h2>

<p>スライド: <a href="https://speakerdeck.com/shimataro/dynamic-import-overview-and-pitfalls" title="dynamic import あれこれ / dynamic import - overview and pitfalls // Speaker Deck">dynamic import あれこれ / dynamic import - overview and pitfalls // Speaker Deck</a></p>

<ul>
<li>ES2015は静的なimport</li>
<li>Dynamic Import</li>
<li>Dynamic importを使ったリロード</li>
<li>動的に読むことで様々な問題/考えることがでてくる

<ul>
<li>モジュールが古い場合</li>
<li>モジュールを削除した場合</li>
</ul></li>
<li>Dynamic importの用途

<ul>
<li>起動時の動的ロード</li>
</ul></li>
</ul>

<hr>

<h2 id="npm-prepublish-の現状と今後どう変わっていくかを調べてみた-by-しとりーさん">npm prepublish の現状と今後どう変わっていくかを調べてみた by しとりーさん</h2>

<ul>
<li>ローカルにあるモジュールを <code>npm install</code> すると 
なぜかインストール先の <code>prepublish</code> が呼ばれる問題</li>
<li><a href="https://github.com/npm/npm/issues/10074" title="resolving prepublish-on-install · Issue #10074 · npm/npm">resolving prepublish-on-install · Issue #10074 · npm/npm</a></li>
<li>npm 4で prepublishOnlyとprepareというの新しく生えた</li>
<li>prepublishを

<ul>
<li>publishする前にprepublishOnly</li>
<li>インストールするときだけにprepare</li>
</ul></li>
<li>将来的にprepublishOnlyは廃止される</li>
</ul>

<hr>

<h2 id="rxjs-v6-について-by-berlysia">rxjs v6 について by berlysia</h2>

<ul>
<li>rxjs v6の変更点について</li>
<li>ゴールにbundle sizeを小さくしたいというのが増えた</li>
<li>pipeable operator

<ul>
<li>ただの関数としてimportできるのでtree shakeできる</li>
<li>不要なoperatorを消せす</li>
</ul></li>
<li>RxJs 5.xはbind operatorでの使いやすさを検討してた

<ul>
<li><a href="https://github.com/tc39/proposal-bind-operator" title="tc39/proposal-bind-operator: This-Binding Syntax for ECMAScript">tc39/proposal-bind-operator: This-Binding Syntax for ECMAScript</a></li>
</ul></li>
<li>RxJs 6.xはpipeline operatowでの使いやすさを検討してた

<ul>
<li><a href="https://github.com/tc39/proposal-pipeline-operator" title="tc39/proposal-pipeline-operator: A proposal for adding the simple-but-useful pipeline operator to JavaScript.">tc39/proposal-pipeline-operator: A proposal for adding the simple-but-useful pipeline operator to JavaScript.</a></li>
</ul></li>
<li>現状はまだファイルサイズは小さくなってない</li>
</ul>

<hr>

<h2 id="introduction-to-jamstack-by-sotayamashita">introduction to JAMStack by sotayamashita</h2>

<ul>
<li><a href="https://jamstack.org/" title="JAMstack | JavaScript, APIs, and Markup">JAMstack | JavaScript, APIs, and Markup</a>

<ul>
<li>クライアント側のJavaScript、再利用可能なAPI、備前にビルドされたマークアップ</li>
</ul></li>
<li>JavaScript + API + Markup = JAM</li>
<li>JAMを使ったスタック

<ul>
<li>速い: CDNから静的コンテンツ</li>
<li>セキュリティ: SaaSなどを使う(自前じゃなくて)</li>
<li>スケール: スケールしやすい</li>
<li>低コスト: 静的コンテンツが中心なので</li>
</ul></li>
<li>JAMスタックではない

<ul>
<li>Workpress</li>
</ul></li>
<li>JAMスタック

<ul>
<li><a href="https://forestry.io/" title="Static CMS for Hugo &amp;amp; Jekyll | Forestry.io">Static CMS for Hugo &amp; Jekyll | Forestry.io</a></li>
<li><a href="https://www.wework.com/" title="WeWork Coworking and Office Space">WeWork Coworking and Office Space</a></li>
</ul></li>
<li><a href="https://jamstack.org/community/" title="JAMstack | JavaScript, APIs, and Markup">JAMstack | JavaScript, APIs, and Markup</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Jestなどを使わずにスナップショットテストを書く</title>
   <link href="http://efcl.info/2018/02/02/snapshot-test/"/>
   <updated>2018-02-02T19:28:00+09:00</updated>
   <id>http://efcl.info/2018/02/02/snapshot-test</id>
   <content type="html"><![CDATA[ <p>スナップショットテストといえば<a href="https://github.com/facebook/jest" title="Jest">Jest</a>や<a href="https://github.com/bahmutov/snap-shot-it" title="snap-shot-it">snap-shot-it</a>などが有名です。
しかし、どちらもそれ自体がAssertionを含むため、比較したいだけには大掛かりな仕組みです。</p>

<ul>
<li><a href="https://facebook.github.io/jest/docs/ja/snapshot-testing.html" title="スナップショットテスト · Jest">スナップショットテスト · Jest</a></li>
</ul>

<p>自分がスナップショットテストを書くときはいつもその場でパターン化したテストコードを書いています。</p>

<h2 id="スナップショットテスト">スナップショットテスト</h2>

<p>スナップショットテストは、何かの入力を受け取り、その出力とファイルに保存しておいた前回の出力結果を比較してテストする手法だと思います。
主な目的はコードの変更して既存の機能を壊してしまうようなリグレッションを防ぐことです。</p>

<p>Babelプラグインのようなコード変換、パーサ、ジェネレータなど何かの入力を受け取り出力できるものに利用できます。</p>

<p>入力と出力の組み合わせをどんどん作っていけばテストも増えるので、テストを簡単に増やせるのが特徴的です。</p>

<h2 id="スナップショットテストを書く">スナップショットテストを書く</h2>

<p>次のようなテストコードを書きます。(これはMochaを使っていますが大体どんなテストフレームワークでも同じことが出来ます。)</p>

<p>次のスナップショットでは、<code>transform</code>というJSONを入力に受け取り、JSONを出力する関数をテストしています。</p>

<p><code>snapshot-test.js</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;fs&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">assert</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;assert&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">fixturesDir</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s2">&quot;snapshots&quot;</span><span class="p">);</span>
<span class="c1">// 変換する関数</span>
<span class="kr">const</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;../transform&quot;</span><span class="p">);</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;Snapshot testing&quot;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="nx">fixturesDir</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">caseName</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">normalizedTestName</span> <span class="o">=</span> <span class="nx">caseName</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/-/g</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">);</span>
      <span class="nx">it</span><span class="p">(</span><span class="err">`</span><span class="nx">Test</span> <span class="nx">$</span><span class="p">{</span><span class="nx">normalizedTestName</span><span class="p">}</span><span class="err">`</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">fixtureDir</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">fixturesDir</span><span class="p">,</span> <span class="nx">caseName</span><span class="p">);</span>
        <span class="kr">const</span> <span class="nx">actualFilePath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">fixtureDir</span><span class="p">,</span> <span class="s2">&quot;input.json&quot;</span><span class="p">);</span>
        <span class="kr">const</span> <span class="nx">actualContent</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">actualFilePath</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">));</span>
        <span class="kr">const</span> <span class="nx">actual</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">(</span><span class="nx">actualContent</span><span class="p">);</span>
        <span class="kr">const</span> <span class="nx">expectedFilePath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">fixtureDir</span><span class="p">,</span> <span class="s2">&quot;output.json&quot;</span><span class="p">);</span>
        <span class="c1">// UPDATE_SNAPSHOT=1 npm test で呼び出したときはスナップショットを更新</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">UPDATE_SNAPSHOT</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileSync</span><span class="p">(</span><span class="nx">expectedFilePath</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">skip</span><span class="p">();</span> <span class="c1">// スキップ</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// inputとoutputを比較する</span>
        <span class="kr">const</span> <span class="nx">expected</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">expectedFilePath</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">));</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">deepEqual</span><span class="p">(</span>
          <span class="nx">actual</span><span class="p">,</span>
          <span class="nx">expected</span><span class="p">,</span>
          <span class="err">`</span>
<span class="nx">$</span><span class="p">{</span><span class="nx">fixtureDir</span><span class="p">}</span>
<span class="nx">$</span><span class="p">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">actual</span><span class="p">)}</span>
<span class="err">`</span>
        <span class="p">);</span>
      <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<h3 id="スナップショットファイルの作成">スナップショットファイルの作成</h3>

<p>先ほどのテストに書いた <code>fixturesDir</code> に対して、テストケース毎のディレクトリを作っていくだけです。
それぞれのディレクトリには、入力となる<code>input.json</code>、出力となる<code>output.json</code>を作って配置していくだけです。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">├── snapshot-test.js
└── snapshots
    ├── テストケース名1
    │   ├── input.json
    │   └── output.json
    └── テストケース名2
        ├── input.json
        └── output.json
</code></pre></div>
<h3 id="スナップショットのテスト作成">スナップショットのテスト作成</h3>

<p>スナップショットテストの良いところは、前回の結果とずれてないかを目視で確認するのが主な目的であるところです。つまり、テストケースの期待する結果をわざわざ自分で書く必要はありません。</p>

<p>先ほどのテストも<code>UPDATE_SNAPSHOT=1</code>という環境変数を付けて実行すると、<code>input.json</code>から<code>output.json</code>のファイルを自動的に作成してくれます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UPDATE_SNAPSHOT=1 npm test
</code></pre></div>
<p>この自動的に作られた<code>output.json</code>が期待している形ならコミットして終わりです。
次からは、環境変数をつけないで実行すれば単に比較されます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm test 
</code></pre></div>
<p>また新しいスナップショットテストを追加したい場合は同じように<code>input.json</code>を作って、<code>output.json</code>が期待するものかを確認して追加を繰り返すだけです。</p>

<p>既存の挙動を変えたときも<code>UPDATE_SNAPSHOT=1 npm test</code>で既存のスナップショットがすべて更新できるので、テストの変更に必要な労力は殆どありません(その結果が期待するものかは確認が必要です)</p>

<p>このようにテストケースがコピペのような形で増やせて、かつ今まで追加したスナップショットテストがリグレッションを防いでくれます。</p>

<h2 id="おわりに">おわりに</h2>

<p>すべてのパターンに使えるテスト方法ではありませんが、変換ツールやCLIといったものをテストする際には費用対効果が良いのでおすすめです。
Jestなどを使わずにスナップショットテストを書くメリットとしてはAssertionを自由にカスタマイズできる点です。<code>assert.deepEqual(actual, expected);</code>はテスト内容によって異なるAssertionを使えます。</p>

<p>スナップショットテストを使ってる例:</p>

<ul>
<li><a href="https://github.com/azu/sentence-splitter/blob/master/test/fixtures-test.ts">sentence-splitter/fixtures-test.ts at master · azu/sentence-splitter</a>

<ul>
<li>パースした結果のJSONをスナップショットとして保存しています</li>
</ul></li>
<li><a href="https://github.com/azu/ecmascript-proposals-json/blob/master/test/snapshot-test.js">ecmascript-proposals-json/snapshot-test.js at master · azu/ecmascript-proposals-json</a>

<ul>
<li>HTMLをスクレイピングして抽出した結果をスナップショットとして保存しています</li>
</ul></li>
<li><a href="https://github.com/textlint/textlint/blob/master/packages/%40textlint/markdown-to-ast/test/parsing-test.js" title="textlint/parsing-test.js at master · textlint/textlint">textlint/parsing-test.js at master · textlint/textlint</a>

<ul>
<li>大量のvalidなMarkdownをパースできるかを検証しつつ、そのパース結果のASTをJSONとして保存しています</li>
</ul></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Almin 0.15リリース</title>
   <link href="http://efcl.info/2018/01/25/almin-0.15/"/>
   <updated>2018-01-25T10:56:00+09:00</updated>
   <id>http://efcl.info/2018/01/25/almin-0.15</id>
   <content type="html"><![CDATA[ <p>ステート管理ライブラリの<a href="https://almin.js.org/" title="Almin">Almin</a> 0.15をリリースしました。</p>

<ul>
<li><a href="https://github.com/almin/almin/releases/tag/almin%400.15.0" title="Release Almin 0.15.0 · almin/almin">Release Almin 0.15.0 · almin/almin</a></li>
</ul>

<h2 id="🌟-features">🌟 Features</h2>

<h3 id="usecase-shouldexecuteをサポート"><code>UseCase#shouldExecute</code>をサポート</h3>

<p><code>UseCase#shouldExecute</code>はユースケースを実行するかどうかの事前条件を定義できます。</p>

<p>今までの問題として、ユースケースを宣言的に実行するかどうかを決めることができませんでした。
動作としては<code>UseCase#execute()</code>が実行されたときに条件が合ってなければreturnすれば機能としては同じです。</p>

<p>しかし、<a href="https://github.com/almin/almin/tree/master/packages/almin-logger" title="almin-logger">almin-logger</a>などのイベント的には&quot;実行した&quot;という記録が残ってしまうのでイマイチでした。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">condition</span><span class="p">){</span>
             <span class="k">return</span><span class="p">;</span> <span class="c1">// Should not execute this UseCase</span>
        <span class="p">}</span>
        <span class="c1">// do something</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>UseCase#shouldExecute</code>ではこのケースを宣言的に表現できます。
<code>UseCase#shouldExecute</code>で<code>false</code>を返せば、そのユースケースを実行しません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">MyUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">shouldExecute</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// if this usecase should not execute</span>
    <span class="p">}</span>
    <span class="nx">execute</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
        <span class="c1">// do something</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>この&quot;実行しなかった&quot;というログは別途<code>onWillNotExecuteEachUseCase</code>イベントで取得できるのできます。
詳しくは<a href="https://almin.js.org/docs/en/lifecycleeventhub-api.html" title="LifeCycleEventHub · Almin">LifeCycleEventHub · Almin</a>をみてください。</p>

<h2 id="📝-documentation">📝 Documentation</h2>

<p><a href="http://efcl.info/2017/12/26/docusaurus-almin/" title="AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した | Web Scratch">AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した | Web Scratch</a>で書いたようにAlminのドキュメントサイトを作り直しました。</p>

<ul>
<li><a href="https://almin.js.org/">https://almin.js.org/</a></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/19714/35078145-318fa092-fc44-11e7-83ff-a4a6e07f0ef8.png" alt="image"></p>

<p><img src="https://user-images.githubusercontent.com/19714/35078141-2a626f2a-fc44-11e7-874e-5cfebdee12f7.png" alt="cqrs patterns for javascript application 2018-01-18 11-38-49"></p>

<p>また、いくつかのドキュメントを追加したり修正しています。</p>

<p>Thanks to <a href="https://github.com/almin/almin/commits?author=koba04" title="koba04">@koba04</a>.</p>

<p>まだチュートリアルの前段階の所がイマイチなので直していきたいです。</p>

<p>Alminは必要なレイヤー分けをするために必要なものを置くために、Reduxなどに比べると登場人物が多いです。これは、特別な記法などを増やしてまで減らすことは目的ではなく、必要なものはちゃんと見える形にすることが目的にあるからです。</p>

<p>そのためこの辺の知識などを補完するためのドキュメントがもっとあるといいなという感じがしています。
(ライブラリに依存したものというよりは、よくあるレイヤードアーキテクチャなどにもでてくるような知識。<a href="http://hanamirb.org/" title="Hanami">Hanami</a>とか<a href="http://terasolunaorg.github.io/guideline/" title="TERASOLUNA Server Framework">TERASOLUNA Server Framework</a>のようなそのライブラリ利用者以外にも役立つとより良い。)</p>

<h2 id="🔥-breaking-change">🔥 Breaking Change</h2>

<p>破壊的な変更が一部ありますが、<a href="https://github.com/almin/migration-tools" title="almin/migration-tools: Migration scripts for Almin.">almin/migration-tools</a>でマイグレーションできたり、TypeScriptの型の問題になっています。</p>

<p><strong>TypeScript</strong></p>

<ul>
<li><code>Payload</code>の<code>type</code>プロパティの型定義を改善しました</li>
<li><code>Payload</code>クラスを継承してる人だけに影響があります。</li>
</ul>

<p><strong>Before:</strong></p>

<p>今まではよくないものが型エラーになっていませんでした。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// OK</span>
<span class="kr">class</span> <span class="nx">P1</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="nx">type</span> <span class="o">=</span> <span class="s2">&quot;P1&quot;</span>
<span class="p">}</span>
<span class="c1">// OK</span>
<span class="kr">class</span> <span class="nx">P2</span> <span class="kr">extends</span> <span class="nx">Payload</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;P2&quot;</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// OK</span>
<span class="kr">class</span> <span class="nx">P3</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;P2&quot;</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// OK - It is a bug</span>
<span class="kr">class</span> <span class="nx">P4</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="c1">// no type</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>After:</strong></p>

<p>0.15で型チェックが厳密になりました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// OK</span>
<span class="kr">class</span> <span class="nx">P1</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="nx">type</span> <span class="o">=</span> <span class="s2">&quot;P1&quot;</span>
<span class="p">}</span>
<span class="c1">// OK</span>
<span class="kr">class</span> <span class="nx">P2</span> <span class="kr">extends</span> <span class="nx">Payload</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;P2&quot;</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// NG - Need to defined `type: string`</span>
<span class="kr">class</span> <span class="nx">P3</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;P2&quot;</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// NG: Fix a bug #295 </span>
<span class="kr">class</span> <span class="nx">P4</span> <span class="kr">extends</span> <span class="nx">Payload</span><span class="p">{</span>
    <span class="c1">// no type</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="♻️-remove-deprecated-api">♻️ Remove deprecated API</h3>

<ul>
<li><code>Context#on*</code> APIなどを <code>Context#events.on*</code> へ移動

<ul>
<li> <a href="https://github.com/almin/almin/issues/206">https://github.com/almin/almin/issues/206</a></li>
</ul></li>
<li><code>ChangedPayload</code> を削除 <a href="https://github.com/almin/almin/issues/285">https://github.com/almin/almin/issues/285</a></li>
</ul>

<p>この２つに変更は<a href="https://github.com/almin/migration-tools" title="@almin/migration-tools">@almin/migration-tools</a>で自動的にマイグレーションできます。</p>

<h3 id="how-to-migrate">How to migrate?</h3>

<p><code>@almin/migration-tools</code>をインストールして、対話式で移行したバージョンを指定すれば後はコードを自動的に変換してくれます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install -g @almin/migration-tools
almin-migration-tools &quot;src/**/*.js&quot;
</code></pre></div>
<p><img src="https://cdn.rawgit.com/almin/migration-tools/dbd1895e/docs/screen-shot.gif" alt="screenshot"></p>

<p>実際には次のようなコード変更が行われます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">UseCase</span><span class="p">,</span> <span class="nx">ChangedPayload</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">class</span> <span class="nx">ExampleUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">(</span><span class="k">new</span> <span class="nx">ChangedPayload</span><span class="p">()).</span><span class="nx">execute</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>to </p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">UseCase</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;almin&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">class</span> <span class="nx">ExampleUseCase</span> <span class="kr">extends</span> <span class="nx">UseCase</span> <span class="p">{</span>
    <span class="nx">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">useCase</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;ChangedPayload&quot;</span> <span class="p">}).</span><span class="nx">execute</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>くわしくは<a href="https://github.com/almin/migration-tools" title="@almin/migration-tools">@almin/migration-tools</a>を見てください。</p>

<p>また、このようなマイグレーションツールを作るためのライブラリも作りました。</p>

<ul>
<li><a href="https://github.com/azu/code-migrator" title="azu/code-migrator: Create code migration tool for your tool/library/framework.">azu/code-migrator: Create code migration tool for your tool/library/framework.</a></li>
</ul>

<p><code>code-migrator</code>を使えば、<code>1.0.0</code> -&gt; <code>2.0.0</code>への移行というような対話CLIを簡単につくれます。実際にマイグレーションする処理はjscodeshiftなどの任意のcodemodツールを使えるので、<code>code-migrator</code>自体は選択されたバージョンに対するスクリプトを起動するだけです。</p>

<ul>
<li><a href="https://github.com/facebook/jscodeshift">facebook/jscodeshift: A JavaScript codemod toolkit.</a></li>
<li><a href="https://github.com/square/babel-codemod">square/babel-codemod: babel-codemod rewrites JavaScript using babel plugins.</a></li>
<li><a href="https://github.com/KnisterPeter/tscodeshift">KnisterPeter/tscodeshift: tscodeshift is a toolkit for running codemods over multiple TS files</a></li>
</ul>

<h2 id="その他">その他</h2>

<p><a href="https://github.com/krasimir/kuker" title="kuker">kuker</a>に対応したAlminのDevToolsを作ったりしています。kukerはイベントのログビューア拡張なので、イベントをちゃんと定義してるAlminなどとは相性がいいです。(Redux-DevTools版の<a href="https://github.com/almin/almin-devtools" title="almin-devtools">almin-devtools</a>もある)</p>

<ul>
<li><a href="https://github.com/almin/almin-kuker-devtools" title="almin/almin-kuker-devtools: Integrate almin with kuker">almin/almin-kuker-devtools: Integrate almin with kuker</a></li>
</ul>

<p><img src="http://efcl.info/wp-content/uploads/2018/01/25-1516878025.png" alt="kuker"></p>

<p>また、<a href="https://almin.js.org/" title="Almin">Almin</a>はいつでもコントビュートを募集しています。</p>

<p><a href="https://github.com/almin/almin/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>label:&quot;good first issue&quot;</code></a>というラベルがついたIssueなどが手が出しやすいかもしれません。</p>

<ul>
<li><a href="https://github.com/almin/almin/issues/185" title="Make Dispatcher optional in Context · Issue #185 · almin/almin">Make Dispatcher optional in Context · Issue #185 · almin/almin</a></li>
</ul>

<p>また、Alminは<a href="https://github.com/almin/almin/tree/master/packages/almin-react-container" title="almin-react-container">almin-react-container</a>というReact連携用のライブラリを公開しています。(自分がReactを使うことが多いので作った)
最近、Reactが<a href="https://github.com/facebook/react/pull/11818">新しいContext API</a>や<a href="https://reactjs.org/docs/render-props.html" title="Render Props">Render Props</a>のドキュメント追加などパターンに変化が見られます。そのためReactとの連携をする<a href="https://github.com/almin/almin/tree/master/packages/almin-react-container" title="almin-react-container">almin-react-container</a>を新しく作り直そうとしています。(別物を作るイメージ)</p>

<p>この辺に興味がある人は次のIssueを見てみると面白いかもしれません。</p>

<ul>
<li><a href="https://github.com/almin/almin/issues/318">Render props for Almin + React · Issue #318 · almin/almin</a></li>
<li><a href="https://github.com/almin/almin/issues/312">Almin: Store#receivePayload design · Issue #312 · almin/almin</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>ECMAScript 2015以降のJavaScriptの`this`を理解する</title>
   <link href="http://efcl.info/2018/01/04/what-is-this/"/>
   <updated>2018-01-04T19:02:00+09:00</updated>
   <id>http://efcl.info/2018/01/04/what-is-this</id>
   <content type="html"><![CDATA[ <p>この記事はJavaScriptの入門書として書いている<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>の<code>this</code>に関する部分をベースにしています。
またjs-primerでは書けなかった現在時点(2018年1月1日)でのブラウザの挙動についてを加えたものです。</p>

<p>次の場所に<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>版（書籍版）の<code>this</code>についての解説があります。
この記事と違って実際にコードを実行しながら読めるので、学習ソースとしては<a href="https://asciidwango.github.io/js-primer/basic/function-this/">書籍版</a>を推奨します。</p>

<ul>
<li>書籍版: <a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></li>
</ul>

<p>また、バグ報告やPRも直接リポジトリにして問題ありません。</p>

<ul>
<li><a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a></li>
</ul>

<p>おかしい場所を選択した状態で右下にある&quot;Bug Report&quot;ボタンを押せば、簡単にtypoとかのバグを報告できます。(PRでも歓迎)</p>

<p><a href="https://asciidwango.github.io/js-primer/basic/function-this/"><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515061693.png" alt="バグ報告のフロー"></a></p>

<p>前置きはこの辺までで、ここから本編。</p>

<blockquote>
<p>この記事では注釈がないコードはstrict modeとして扱います</p>
</blockquote>

<h1 id="ecmascript-2015以降のthis">ECMAScript 2015以降の<code>this</code></h1>

<p>この記事では<code>this</code>という特殊な動作をするキーワードについてを見ていきます。
<code>this</code>は基本的にはメソッドの中で利用します。しかし、<code>this</code>は読み取り専用のグローバル変数のようなものでどこにでも書くことができます。
また、<code>this</code>の参照先（値）は条件によってさまざまです。</p>

<p><code>this</code>の参照先は主に次の条件によって変化します。</p>

<ul>
<li>実行コンテキストにおける<code>this</code></li>
<li>コンストラクタにおける<code>this</code></li>
<li>関数とメソッドにおける<code>this</code></li>
<li>Arrow Functionにおける<code>this</code></li>
</ul>

<p>もっとも複雑な条件が存在するのは「関数とメソッドにおける<code>this</code>」です。
そのためこの記事では関数と<code>this</code>の関係を主に扱います。
(コンストラクタにおける<code>this</code>はクラスと一緒に学んだ方がいいので省きます。)</p>

<p>この記事では、さまざまな条件下で変わる<code>this</code>の参照先と関数やArrow Functionとの関係を見ていきます。</p>

<h2 id="目標-thisの評価結果を理解する">目標: <code>this</code>の評価結果を理解する</h2>

<p><code>this</code>はさまざまな条件でその評価結果(参照先)は異なります。
基本的な関数やメソッドについては次のようなパターンが考えられます。</p>

<p>この記事では表では<code>???</code>となっている<code>this</code>の評価結果を仕組みから理解できることを目標にします。</p>

<p><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515062180.png" alt="`this`の評価結果の穴埋め"></p>

<ul>
<li><code>＊</code>はどの場合でも結果に影響しないということを示すワイルドカード</li>
<li>関数は<code>fn()</code>と実行した場合の<code>this</code>の評価結果、メソッドは<code>obj.method()</code>と実行した場合の<code>this</code>の評価結果</li>
</ul>

<p>例えば、<strong>実行コンテキスト</strong>がScriptで<strong>strict mode</strong>がNO(strict modeはない)ときに、<strong>コード</strong>が<code>const fn = function(){ return this; }</code>というのは、次のように評価した場合における<code>this</code>の評価結果(<code>???</code>)を表にしたものです。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script&gt;</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span> <span class="c1">// このときに出力結果が ??? に入る</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>表の結果がすべてわかっている人にはこの記事は不要だと思います。</p>

<ul>
<li><a href="https://gist.github.com/azu/ca9d5a0f4b7c137bc5e2453f8783bf8c">Gist: 穴埋め用の<code>this</code>表</a></li>
</ul>

<p>記事の最後に答え合わせ用の表を置いています。</p>

<h2 id="目標ではないこと">目標ではないこと</h2>

<p>この記事は<code>this</code>を使うために必要な実用的な使い方(プラクティス)を学ぶことが目標の記事ではありません。
この記事では<code>this</code>の実用外の知識(仕様やトップレベルの<code>this</code>など)についても書いています。
実用的に使うだけなら、不要な知識も含まれていることにご了承ください。</p>

<p>実用性だけを学ぶならもっと簡略化した内容を元にした方が混乱が減って良いと思います。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this" title="this - JavaScript | MDN">this - JavaScript | MDN</a></li>
</ul>

<h2 id="実行コンテキストとthis">実行コンテキストと<code>this</code></h2>

<p>JavaScriptには実行コンテキストとして&quot;Script&quot;と&quot;Module&quot;があります。
トップレベルにある<code>this</code>は、実行コンテキストによって値が異なります。
実行コンテキストの違いは意識しにくい部分であり、トップレベルで<code>this</code>を使うことは混乱を生むことになります。
そのため、コードのトップレベルにおいては<code>this</code>を使うべきではありませんが、それぞれの実行コンテキストにおける動作を紹介します。</p>

<h3 id="スクリプトにおけるthis">スクリプトにおける<code>this</code></h3>

<p>実行コンテキストが&quot;Script&quot;である場合、トップレベルに書かれた<code>this</code>はグローバルオブジェクトを参照します。
グローバルオブジェクトとは、実行環境において異なるものが定義されています。
ブラウザなら<code>window</code>オブジェクト、Node.jsなら<code>global</code>オブジェクトとなります。</p>

<p>ブラウザでは、<code>script</code>要素の<code>type</code>属性を指定してない場合は実行コンテキストが&quot;Script&quot;として実行されます。
この<code>script</code>要素の直下に書いた<code>this</code>はグローバルオブジェクトである<code>window</code>オブジェクトとなります。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script&gt;</span>
<span class="c1">// 実行コンテキストは&quot;Script&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; window</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<h3 id="モジュールにおけるthis">モジュールにおける<code>this</code></h3>

<p>実行コンテキストの&quot;Module&quot;はES 2015で導入され、名前の通り<code>import</code>や<code>export</code>などのES modulesが動作する実行コンテキストです。
実行コンテキストが&quot;Module&quot;である場合、トップレベルに書かれた<code>this</code>は常に<code>undefined</code>となります。</p>

<p>ブラウザでは、<code>script</code>要素の<code>type=&quot;module&quot;</code>属性がついた場合は実行コンテキストが&quot;Module&quot;として実行されます。
この<code>script</code>要素の直下に書いた<code>this</code>は<code>undefined</code>となります。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="c1">// 実行コンテキストは&quot;Module&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>このように、コード直下の<code>this</code>は実行コンテキストによって<code>undefined</code>となる場合があります。
単純にグローバルオブジェクトを参照したい場合は、<code>this</code>ではなく<code>window</code>などのグローバルオブジェクトを直接参照した方がよいです。</p>

<h4 id="📝-note">📝 Note</h4>

<p>なぜModuleコンテキストではトップレベルの<code>this</code>が<code>undefined</code>となるかは次の記事で解説しています。</p>

<ul>
<li><a href="http://efcl.info/2015/05/06/this-is-es6-module/" title="ES6 moduleのtop levelにある`this`の値は何になるのか? | Web Scratch">ES6 moduleのtop levelにある<code>this</code>の値は何になるのか? | Web Scratch</a></li>
</ul>

<p>また現時点では環境へ依存せずにグローバルオブジェクトを取得するのはややこしい方法が必要です。
しかし、現在(2018-01-01) Stage 3のProposalである<code>global</code>が将来的には利用できます。</p>

<ul>
<li><a href="https://github.com/tc39/proposal-global" title="tc39/proposal-global: ECMAScript Proposal, specs, and reference implementation for `global`">tc39/proposal-global: ECMAScript Proposal, specs, and reference implementation for <code>global</code></a></li>
</ul>

<h2 id="関数とメソッドにおけるthis">関数とメソッドにおける<code>this</code></h2>

<p><strong>関数</strong>を定義する方法として、<code>function</code>キーワードによる関数宣言と関数式、Arrow Functionなどがあります。
<code>this</code>が参照先を決めるルールはArrow Functionとそれ以外の方法で異なります。</p>

<p>まずは<strong>Arrow Function以外</strong>の関数やメソッドにおける<code>this</code>を見ていきます。</p>

<h2 id="arrow-function以外の関数におけるthis">Arrow Function以外の関数における<code>this</code></h2>

<p>Arrow Function以外の関数（メソッドも含む)における<code>this</code>は実行時に決まる値となります。
言い方をかえると<code>this</code>は関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行する時に決まります。</p>

<p>次のコードは擬似的なものです。
関数の中に書かれた<code>this</code>は、関数の呼び出し元から暗黙的に渡される値を参照することになります。
このルールはArrow Function以外の関数やメソッドで共通した仕組みとなります。Arrow Functionで定義した関数やメソッドはこのルールとは別の仕組みとなります。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 擬似的な`this`の値の仕組み</span>
<span class="c1">// 関数は引数として暗黙的に`this`の値を受け取るイメージ</span>
<span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="err">暗黙的渡される</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="err">仮引数</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; 暗黙的渡されるthisの値</span>
<span class="p">}</span>
<span class="c1">// 暗黙的に`this`の値を引数として渡しているイメージ</span>
<span class="nx">fn</span><span class="p">(</span><span class="err">暗黙的に渡す</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="err">引数</span><span class="p">);</span>
</code></pre></div>
<!-- textlint-disable no-js-function-paren -->

<p>関数における<code>this</code>の基本的な参照先（暗黙的に関数に渡す<code>this</code>の値）は<strong>ベースオブジェクト</strong>となります。
ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
ベースオブジェクトがない場合の<code>this</code>は<code>undefined</code>となります。</p>

<p>たとえば、<code>fn()</code>のように関数を呼び出したとき、この<code>fn</code>関数呼び出しのベースオブジェクトはないため、<code>this</code>は<code>undefiend</code>となります。
一方、<code>obj.method()</code>のようにメソッドを呼び出したとき、この<code>obj.method</code>メソッド呼び出しのベースオブジェクトは<code>obj</code>オブジェクトとなり、<code>this</code>は<code>obj</code>となります。</p>

<!-- textlint-enable no-js-function-paren -->

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `fn`関数はメソッドではないのでベースオブジェクトはない</span>
<span class="nx">fn</span><span class="p">();</span>
<span class="c1">// `obj.method`メソッドのベースオブジェクトは`obj`</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
<span class="c1">// `obj1.obj2.method`メソッドのベースオブジェクトは`obj2`</span>
<span class="c1">// ドット演算子、ブラケット演算子どちらも結果は同じ</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
<span class="nx">obj1</span><span class="p">[</span><span class="s2">&quot;obj2&quot;</span><span class="p">][</span><span class="s2">&quot;method&quot;</span><span class="p">]();</span>
</code></pre></div>
<p><code>this</code>は関数の定義ではなく呼び出し方で参照する値が異なります。これは、後述する「<code>this</code>が問題となるパターン」で詳しく紹介します。
Arrow Function以外の関数では、関数の定義だけを見て<code>this</code>の値が何かということは決定できない点には注意が必要です。</p>

<h3 id="関数宣言や関数式におけるthis">関数宣言や関数式における<code>this</code></h3>

<p>まずは、関数宣言や関数式の場合を見ていきます。</p>

<p>次の例では、関数宣言と関数式で定義した関数の中の<code>this</code>をコンソールに出力しています。
このとき、<code>fn1</code>と<code>fn2</code>はただの関数として呼び出されています。
つまり、ベースオブジェクトがないため<code>this</code>は<code>undefined</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">fn1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 関数の中の`this`が参照する値は呼び出し方によって決まる</span>
<span class="c1">// `fn1`と`fn2`どちらもただの関数として呼び出している</span>
<span class="c1">// メソッドとして呼び出していないためベースオブジェクトはない</span>
<span class="c1">// ベースオブジェクトがない場合、`this`は`undefined`となる</span>
<span class="nx">fn1</span><span class="p">();</span> <span class="c1">// =&gt; undefined</span>
<span class="nx">fn2</span><span class="p">();</span> <span class="c1">// =&gt; undefined</span>
</code></pre></div>
<p>これは、関数の中に関数を定義して呼びだす場合も同じです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
    <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// =&gt; undefined</span>
    <span class="p">}</span>
    <span class="c1">// `inner`関数呼び出しのベースオブジェクトはない</span>
    <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// `outer`関数呼び出しのベースオブジェクトはない</span>
<span class="nx">outer</span><span class="p">();</span>
</code></pre></div>
<p>この記事では注釈がないコードはstrict modeとして扱いますが、コード例に<code>&quot;use strict&quot;;</code>でわざわざstrict modeを明示しています。
なぜなら、strict modeではない場合に<code>this</code>が<code>undefined</code>の場合は、<code>this</code>がグローバルオブジェクトへと暗黙的に変換されてしまう問題があるからです。
strict modeかどうかによって挙動が異なるのは混乱の元であるため、関数呼び出しする関数においては<code>this</code>を使うべきではありません。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Strict_mode" title="Strict モード - JavaScript | MDN">Strict モード - JavaScript | MDN</a></li>
</ul>

<h3 id="メソッド呼び出しにおけるthis">メソッド呼び出しにおける<code>this</code></h3>

<p>次に、メソッドの場合を見ていきます。
メソッドの場合は、そのメソッドは何かしらのオブジェクトに所属しています。
なぜなら、JavaScriptではオブジェクトのプロパティとして指定される関数のことをメソッドと呼ぶためです。</p>

<p>次の例では<code>method1</code>と<code>method2</code>はそれぞれメソッドとして呼び出されています。
このとき、それぞれのベースオブジェクトは<code>object</code>となり、<code>this</code>は<code>object</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 関数式をプロパティの値にしたメソッド</span>
    <span class="nx">method1</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="c1">// 短縮記法で定義したメソッド</span>
    <span class="nx">method2</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// メソッド呼び出しの場合、それぞれの`this`はベースオブジェクト(`object`)を参照する</span>
<span class="c1">// メソッド呼び出しの`.`の左にあるオブジェクトがベースオブジェクト</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">method1</span><span class="p">();</span> <span class="c1">// =&gt; object</span>
<span class="nx">object</span><span class="p">.</span><span class="nx">method2</span><span class="p">();</span> <span class="c1">// =&gt; object</span>
</code></pre></div>
<p>これを利用すれば、メソッドの中から同じオブジェクトに所属する別のプロパティを<code>this</code>で参照できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// `person.fullName`と書いているのと同じ</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `person.fullName`を出力する</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">());</span> <span class="c1">// =&gt; &quot;Brendan Eich&quot;</span>
</code></pre></div>
<p>このようにメソッドが所属するオブジェクトのプロパティを、<code>オブジェクト名.プロパティ名</code>の代わりに<code>this.プロパティ名</code>で参照できます。</p>

<p>オブジェクトは何重にもネストできますが、<code>this</code>はベースオブジェクトを参照するというルールは同じです。</p>

<p>次のコードを見てみると、ネストしたオブジェクトにおいてメソッド内の<code>this</code>がベースオブジェクトである<code>obj3</code>を参照していることが分かります。
このときのベースオブジェクトはドットで繋いだ一番左の<code>obj1</code>ではなく、メソッドから見てひとつ左の<code>obj3</code>となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">obj2</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">obj3</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `obj1.obj2.obj3.method`メソッドの`this`は`obj3`を参照</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">obj3</span><span class="p">.</span><span class="nx">method</span><span class="p">()</span> <span class="o">===</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">obj3</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<h2 id="thisが問題となるパターン"><code>this</code>が問題となるパターン</h2>

<p><code>this</code>はその関数（メソッドも含む）呼び出しのベースオブジェクトを参照することがわかりました。
<code>this</code>は所属するオブジェクトを直接書く代わりとして利用できますが、一方<code>this</code>には色々な問題があります。</p>

<p>この問題の原因は<code>this</code>がどの値を参照するかは関数の呼び出し時に決まるという性質に由来します。
この<code>this</code>の性質が問題となるパターンの代表的な2つの例とそれぞれの対策についてを見ていきます。</p>

<h3 id="問題-thisを含むメソッドを変数に代入した場合">問題: <code>this</code>を含むメソッドを変数に代入した場合</h3>

<p>JavaScriptではメソッドとして定義したものが、後からただの関数として呼び出されることがあります。
なぜなら、メソッドは関数を値にもつプロパティのことで、プロパティは変数に代入し直すことができるためです。</p>

<p>そのため、メソッドとして定義した関数も、別の変数に代入してただの関数として呼び出されることがあります。
この場合には、メソッドとして定義した関数であっても、実行時にはただの関数であるためベースオブジェクトが変わっています。
これは<code>this</code>が定義した時点ではなく実行した時に決まるという性質そのものです。</p>

<p>具体的に、<code>this</code>が実行時に変わる例を見ていましょう。
次の例では、<code>person.sayName</code>メソッドを変数<code>say</code>に代入してから実行しています。
このときの<code>say</code>関数(<code>sayName</code>メソッドを参照)のベースオブジェクトはありません。
そのため、<code>this</code>は<code>undefined</code>となり、<code>undefined.fullName</code>は参照できずに例外をなげます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// `this`は呼び出し元によってことなる</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `sayName`メソッドは`person`オブジェクトに所属する</span>
<span class="c1">// `this`は`person`オブジェクトとなる</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// =&gt; &quot;Brendan Eich&quot;</span>
<span class="c1">// `person.sayName`を`say`変数に代入する</span>
<span class="kr">const</span> <span class="nx">say</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">;</span>
<span class="c1">// 代入したメソッドを関数として呼ぶ</span>
<span class="c1">// この`say`関数はどのオブジェクトにも所属していない</span>
<span class="c1">// `this`はundefinedとなるため例外を投げる</span>
<span class="nx">say</span><span class="p">();</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p>結果的には、次のようなコードが実行されているのと同じです。
次のコードでは、<code>undefined.fullName</code>を参照しようとして例外が発生しています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="c1">// const sayName = person.sayName; は次のようなイメージ</span>
<span class="kr">const</span> <span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// `this`は`undefined`となるため例外をなげる</span>
<span class="nx">say</span><span class="p">();</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p>このように、Arrow Function以外の関数において、<code>this</code>は定義した時ではなく実行した時に決定されます。
そのため、関数に<code>this</code>を含んでいる場合、その関数は意図した呼ばれ方がされないと間違った結果が発生するという問題があります。</p>

<p>この問題の対処法としては大きく分けて2つあります。</p>

<p>ひとつはメソッドとして定義されている関数はメソッドとして呼ぶということです。
メソッドをわざわざただの関数として呼ばなければそもそもこの問題は発生しません。</p>

<p>もうひとつは、<code>this</code>の値を指定して関数を呼べるメソッドで関数を実行する方法です。</p>

<h3 id="対処法-call、apply、bindメソッド">対処法: call、apply、bindメソッド</h3>

<p>関数やメソッドの<code>this</code>を明示的に指定して関数を実行する方法もあります。
<code>Function</code>（関数オブジェクト）には<code>call</code>、<code>apply</code>、<code>bind</code>といった明示的に<code>this</code>を指定して関数を実行するメソッドが用意されています。</p>

<p><code>call</code>メソッドは第一引数に<code>this</code>としたい値を指定し、残りの引数は呼びだす関数の引数となります。
暗黙的に渡される<code>this</code>の値を明示的に渡せるメソッドといえます。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">...</span><span class="err">関数の引数</span><span class="p">);</span>
</code></pre></div>
<p>次の例では<code>this</code>に<code>person</code>オブジェクトを指定した状態で<code>say</code>関数を呼び出しています。
<code>call</code>メソッドの第二引数で指定した値が、<code>say</code>関数の仮引数<code>message</code>に入ります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`にして`say`関数を呼びだす</span>
<span class="nx">say</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
<span class="c1">// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生</span>
<span class="nx">say</span><span class="p">(</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p><code>apply</code>メソッドは第一引数に<code>this</code>とする値を指定し、第二引数に関数の引数を配列として渡します。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">[</span><span class="err">関数の引数</span><span class="mi">1</span><span class="p">,</span> <span class="err">関数の引数</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div>
<p>次の例では<code>this</code>に<code>person</code>オブジェクトを指定した状態で<code>say</code>関数を呼び出しています。
<code>apply</code>メソッドの第二引数で指定した配列は、自動的に展開されて<code>say</code>関数の仮引数<code>message</code>に入ります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`にして`say`関数を呼びだす</span>
<span class="c1">// callとは異なり引数を配列として渡す</span>
<span class="nx">say</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
<span class="c1">// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生</span>
<span class="nx">say</span><span class="p">(</span><span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;fullName&#39; of undefined</span>
</code></pre></div>
<p><code>call</code>メソッドと<code>apply</code>メソッドの違いは、関数の引数への値の渡し方が異なるだけです。
また、どちらのメソッドも<code>this</code>の値が不要な場合は<code>null</code>を渡すのが一般的です。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// `this`は不要な場合はnullを渡す</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// =&gt; 3</span>
<span class="nx">add</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="c1">// =&gt; 3</span>
</code></pre></div>
<p>最後に<code>bind</code>メソッドについてです。
名前のとおり<code>this</code>の値を束縛（bind）した新しい関数を作成します。</p>

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="err">関数</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="err">の値</span><span class="p">,</span> <span class="p">...</span><span class="err">関数の引数</span><span class="p">);</span> <span class="c1">// =&gt; thisや引数がbindされた関数</span>
</code></pre></div>
<p>次の例では<code>this</code>を<code>person</code>オブジェクトに束縛した<code>say</code>関数の関数を作っています。
<code>bind</code>メソッドの第二引数以降に値を渡すことで、束縛した関数の引数も束縛できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`に束縛した`say`関数をラップした関数を作る</span>
<span class="kr">const</span> <span class="nx">sayPerson</span> <span class="o">=</span> <span class="nx">say</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span>
<span class="nx">sayPerson</span><span class="p">();</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
</code></pre></div>
<p>この<code>bind</code>メソッドをただの関数で表現すると次のように書けます。
<code>bind</code>は<code>this</code>や引数を束縛した関数を作るメソッドということがわかります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">say</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">message</span><span class="p">}</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span><span class="err">！`</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">fullName</span><span class="o">:</span> <span class="s2">&quot;Brendan Eich&quot;</span>
<span class="p">};</span>
<span class="c1">// `this`を`person`に束縛した`say`関数をラップした関数を作る</span>
<span class="c1">//  say.bind(person, &quot;こんにちは&quot;); は次のようなラップ関数を作る</span>
<span class="kr">const</span> <span class="nx">sayPerson</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">say</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&quot;こんにちは&quot;</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">sayPerson</span><span class="p">();</span> <span class="c1">// =&gt; &quot;こんにちは Brendan Eich！&quot;</span>
</code></pre></div>
<p>このように<code>call</code>、<code>apply</code>、<code>bind</code>メソッドを使うことで<code>this</code>を明示的に指定した状態で関数を呼び出せます。
しかし、毎回関数を呼びだすたびにこれらのメソッドを使うのは、関数を呼びだすための関数が必要になってしまい手間がかかります。
そのため、基本的には「メソッドとして定義されている関数はメソッドとして呼ぶこと」でこの問題を回避するほうがよいでしょう。
その中で、どうしても<code>this</code>を固定したい場合には<code>call</code>、<code>apply</code>、<code>bind</code>メソッドを利用します。</p>

<h3 id="問題-コールバック関数とthis">問題: コールバック関数と<code>this</code></h3>

<p>コールバック関数の中で<code>this</code>を参照すると問題となる場合があります。
この問題は、メソッドの中で<code>Array#map</code>メソッドなどコールバック関数を扱う場合に発生しやすいです。</p>

<p>具体的に、コールバック関数における<code>this</code>が問題となっている例を見てみましょう。
次のコードでは<code>prefixArray</code>メソッドの中で<code>Array#map</code>メソッドを使っています。
このとき、<code>Array#map</code>メソッドのコールバック関数の中で、<code>Prefixer</code>オブジェクトを参照するつもりで<code>this</code>を参照しています。</p>

<p>しかし、このコールバック関数における<code>this</code>は<code>undefined</code>となり、<code>this.prefix</code>は<code>undefined.prefix</code>であるためTypeErrorとなります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="cm">/**</span>
<span class="cm">     * `strings`配列の各要素にprefixをつける</span>
<span class="cm">     */</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// コールバック関数における`this`は`undefined`となる(strict mode)</span>
            <span class="c1">// そのため`this.prefix`は`undefined.prefix`となり例外が発生する</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;prefix&#39; of undefined</span>
</code></pre></div>
<p>なぜコールバック関数の中での<code>this</code>が<code>undefined</code>となるのかを見ていきます。
<code>Array#map</code>メソッドにはコールバック関数として、その場で定義した匿名関数を渡していることに注目してください。</p>

<!-- textlint-disable eslint -->

<!-- doctest:disable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// ...</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 匿名関数をコールバック関数として渡している</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div>
<!-- textlint-enable eslint -->

<!-- textlint-disable no-js-function-paren -->

<p>このとき、<code>Array#map</code>メソッドに渡しているコールバック関数は<code>callback()</code>のようにただの関数として呼び出されます。
つまり、コールバック関数として呼びだすとき、この関数にはベースオブジェクトはありません。
そのため<code>callback</code>関数の<code>this</code>は<code>undefined</code>となります。</p>

<p>先ほどの匿名関数をコールバック関数として渡しているのは、一度<code>callback</code>変数に入れてから渡しても結果は同じです。</p>

<!-- textlint-enable no-js-function-paren -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// コールバック関数は`callback()`のように呼び出される</span>
        <span class="c1">// そのためコールバック関数における`this`は`undefined`となる(strict mode)</span>
        <span class="kr">const</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span> <span class="c1">// =&gt; TypeError: Cannot read property &#39;prefix&#39; of undefined</span>
</code></pre></div>
<h4 id="対処法-thisを一時変数へ代入する">対処法: <code>this</code>を一時変数へ代入する</h4>

<p>コールバック関数内での<code>this</code>の参照先が変わる問題への対処法として、<code>this</code>を別の変数に代入し、その<code>this</code>の参照先を保持するという方法があります。</p>

<p><code>this</code>は関数の呼び出し元で変化し、その参照先は呼び出し元におけるベースオブジェクトです。
<code>prefixArray</code>メソッドの呼び出しにおいては、<code>this</code>は<code>Prefixer</code>オブジェクトです。
しかし、コールバック関数はあらためて関数として呼び出されるため<code>this</code>が<code>undefined</code>となってしまうのが問題でした。</p>

<p>そのため、最初の<code>prefixArray</code>メソッド呼び出しにおける<code>this</code>の参照先を一時変数として保存することでこの問題を回避できます。
つぎのように、<code>prefixArray</code>メソッドの<code>this</code>を<code>that</code>変数に保持しています。
コールバック関数からは<code>this</code>の代わりに<code>that</code>変数を参照することで、コールバック関数からも<code>prefixArray</code>メソッド呼び出しと同じ<code>this</code>を参照できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// `that`は`prefixArray`メソッド呼び出しにおける`this`となる</span>
        <span class="c1">// つまり`that`は`Prefixer`オブジェクトを参照する</span>
        <span class="kr">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `this`ではなく`that`を参照する</span>
            <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>もちろん<code>Function#call</code>メソッドなどで明示的に<code>this</code>を渡して関数を呼びだすこともできます。
また、<code>Arry#map</code>メソッドなどは<code>this</code>となる値引数として渡せる仕組みを持っています。
そのため、つぎのように第二引数に<code>this</code>となる値を渡すことでも解決できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// `Array#map`メソッドは第二引数に`this`となる値を渡せる</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `this`が第二引数の値と同じになる</span>
            <span class="c1">// つまり`prefixArray`メソッドと同じ`this`となる</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">},</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// `prefixArray`メソッドにおける`this`は`Prefixer`</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>しかし、これら解決方法はコールバック関数において<code>this</code>が変わることを意識して書く必要があります。
そもそもの問題としてメソッド呼び出しとその中でのコールバック関数における<code>this</code>が変わってしまうのが問題でした。
ES2015では<code>this</code>を変えずにコールバック関数を定義する方法として、Arrow Functionが導入されました。</p>

<h3 id="対処法-arrow-functionでコールバック関数を扱う">対処法: Arrow Functionでコールバック関数を扱う</h3>

<p>通常の関数やメソッドは呼び出し時に暗黙的に<code>this</code>の値を受け取り、関数内の<code>this</code>はその値を参照します。
一方、Arrow Functionはこの暗黙的な<code>this</code>の値を受け取りません。
そのためArrow Function内の<code>this</code>は、スコープチェーンの仕組みと同様で外側の関数(この場合は<code>prefixArray</code>メソッド)に探索します。
これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数の<code>this</code>をそのまま利用します。</p>

<p>Arrow Functionを使うことで、先ほどのコードは次のように書くことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Arrow Function自体は`this`を持たない</span>
            <span class="c1">// `this`は外側の`prefixArray`関数がもつ`this`を参照する</span>
            <span class="c1">// そのため`this.prefix`は&quot;pre&quot;となる</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// この時、`prefixArray`のベースオブジェクトは`Prefixer`となる</span>
<span class="c1">// つまり、`prefixArray`メソッド内の`this`は`Prefixer`を参照する</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<p>このように、Arrow Functionでのコールバック関数における<code>this</code>は簡潔です。
そのため、コールバック関数内での<code>this</code>の対処法として<code>this</code>を代入する方法を紹介しましたが、
ES2015からはArrow Functionを使うのがもっとも簡潔です。</p>

<p>このArrow Functionと<code>this</code>の関係についてもっと詳しく見ていきます。</p>

<h2 id="arrow-functionとthis">Arrow Functionと<code>this</code></h2>

<p>Arrow Functionで定義された関数やメソッドにおける<code>this</code>がどの値を参照するかは関数の定義時（静的）に決まります。
一方、Arrow Functionではない関数においては、<code>this</code>は呼び出し元に依存するため関数の実行時（動的）に決まります。</p>

<p>Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionは<code>this</code>を暗黙的な引数として受け付けないということです。
そのため、Arrow Function内には<code>this</code>が定義されていません。このときの<code>this</code>は外側のスコープ（関数）の<code>this</code>を参照します。</p>

<p>これは変数におけるスコープチェーンの仕組みと同様で、そのスコープに<code>this</code>が定義されていない場合には外側のスコープを探索するのと同じです。
そのため、Arrow Function内の<code>this</code>の参照先は、常に外側のスコープ（関数）へと<code>this</code>の定義を探索しに行きます（詳細は<a href="https://asciidwango.github.io/js-primer/basic/function-scope/#scope-chain">スコープチェーン</a>を参照）。
また、<code>this</code>は読み取り専用のキーワードであるため、ユーザーが<code>this</code>という変数を定義できません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="k">this</span> <span class="o">=</span> <span class="s2">&quot;thisは読み取り専用&quot;</span><span class="p">;</span> <span class="c1">// =&gt; SyntaxError: Unexpected token this</span>
</code></pre></div>
<p>これにより、Arrow Functionにおける<code>this</code>は通常の変数と同じように、どの値を参照するかは静的に決まるという性質があります（詳細は<a href="https://asciidwango.github.io/js-primer/basic/function-scope/#static-scope">静的スコープ</a>を参照）。
つまりArrow Functionにおける<code>this</code>の参照先は「Arrow Function自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」となります。</p>

<p>具体的な例を元にArrow Functionにおける<code>this</code>の動きを見ていきましょう。</p>

<p>まずは、関数式のArrow Functionを見ていきます。</p>

<p>次の例では、関数式で定義したArrow Functionの中の<code>this</code>をコンソールに出力しています。
このとき、<code>fn</code>の外側には関数はないため、「自身より外側のスコープにあるもっとも近い関数」の条件にあてはまるものはありません。
このときの<code>this</code>はトップレベルに書かれた<code>this</code>と同じ値になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Arrow Functionで定義した関数</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// この関数の外側には関数は存在しない</span>
    <span class="c1">// トップレベルの`this`と同じ値</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">fn</span><span class="p">()</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// =&gt; true</span>
</code></pre></div>
<p>トップレベルに書かれた<code>this</code>の値は実行コンテキストによって異なることを紹介しました。
<code>this</code>の値は、実行コンテキストが&quot;Script&quot;ならばグローバルオブジェクトとなり、&quot;Module&quot;ならば<code>undefined</code>となります。</p>

<p>次の例のように、Arrow Functionを包むように通常の関数が定義されている場合はどうでしょうか。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Arrow Functionで定義した関数を返す</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// この関数の外側には`outer`関数が存在する</span>
        <span class="c1">// `outer`関数に`this`を書いた場合と同じ</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// `outer`関数の返り値はArrow Functionにて定義された関数</span>
<span class="kr">const</span> <span class="nx">innerArrowFunction</span> <span class="o">=</span> <span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">innerArrowFunction</span><span class="p">());</span> <span class="c1">// =&gt; undefined;</span>
</code></pre></div>
<p>Arrow Functionにおける<code>this</code>は「自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」となります。
つまり、このArrow Functionにおける<code>this</code>は<code>outer</code>関数で<code>this</code>を参照した場合と同じ値になります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// `outer`関数直下の`this`</span>
    <span class="kr">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="c1">// Arrow Functionで定義した関数を返す</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Arrow Function自身は`this`を持たない</span>
        <span class="c1">// `outer`関数に`this`を書いた場合と同じ</span>
        <span class="k">return</span> <span class="nx">that</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// `outer()`と呼び出した時の`this`は`undefined`(strict mode)</span>
<span class="kr">const</span> <span class="nx">innerArrowFunction</span> <span class="o">=</span> <span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">innerArrowFunction</span><span class="p">());</span> <span class="c1">// =&gt; undefined;</span>
</code></pre></div>
<h3 id="メソッドとコールバック関数とarrow-function">メソッドとコールバック関数とArrow Function</h3>

<p>メソッド内におけるコールバック関数はArrow Functionをもっと活用できるパターンです。
<code>function</code>キーワードでコールバック関数を定義すると、<code>this</code>の値はコールバック関数の呼ばれ方を意識する必要があります。
なぜなら、<code>function</code>キーワードで定義した関数における<code>this</code>は呼び出し方によって変わるためです。</p>

<p>コールバック関数側から見ると、どのように呼ばれるかによって変わる<code>this</code>を使うことはエラーとなる場合もあるため使えません。
そのため、コールバック関数の外側のスコープで<code>this</code>を一時変数に代入し、それを使うという回避を取っていました。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `callback`関数を受け取り呼び出す関数</span>
<span class="kr">const</span> <span class="nx">callCallback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// `callback`を呼び出す実装</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">callCallback</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// ここでの `this` は`callCallback`の実装に依存する</span>
            <span class="c1">// `callback()`のように単純に呼び出されるなら`this`は`undefined`になる</span>
            <span class="c1">// `Function#call`などを使い特定のオブジェクトを指定するかもしれない</span>
            <span class="c1">// この問題を回避するために`const that = this`のような一時変数を使う</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>一方、Arrow Functionでコールバック関数を定義した場合は、1つ外側の関数の<code>this</code>を参照します。
このときのArrow Functionで定義したコールバック関数における<code>this</code>は呼び出し方によって変化しません。
そのため、<code>this</code>を一時変数に代入するなどの回避方法は必要ありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// `callback`関数を受け取り呼び出す関数</span>
<span class="kr">const</span> <span class="nx">callCallback</span> <span class="o">=</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// `callback`を呼び出す実装</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">callCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// ここでの`this`は1つ外側の関数における`this`と同じ</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>このArrow Functionにおける<code>this</code>は呼び出し方の影響を受けません。
つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなく<code>this</code>を扱うことができます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Prefixer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s2">&quot;pre&quot;</span><span class="p">,</span>
    <span class="nx">prefixArray</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// `Prefixer.prefixArray()` と呼び出されたとき</span>
            <span class="c1">// `this`は常に`Prefixer`を参照する</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kr">const</span> <span class="nx">prefixedStrings</span> <span class="o">=</span> <span class="nx">Prefixer</span><span class="p">.</span><span class="nx">prefixArray</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixedStrings</span><span class="p">);</span> <span class="c1">// =&gt; [&quot;pre-a&quot;, &quot;pre-b&quot;, &quot;pre-c&quot;]</span>
</code></pre></div>
<h3 id="arrow-functionはthisをbindできない">Arrow Functionは<code>this</code>をbindできない</h3>

<p>Arrow Functionで定義した関数には<code>call</code>、<code>apply</code>、<code>bind</code>を使った<code>this</code>の指定は単に無視されます。
これは、Arrow Functionは<code>this</code>をもつことができないためです。</p>

<p>次のようにArrow Functionで定義した関数に対して<code>call</code>で<code>this</code>をしても、<code>this</code>の参照先が代わっていないことが分かります。
同様に<code>apply</code>や<code>bind</code>メソッドを使った場合も<code>this</code>の参照先が変わりません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Scriptコンテキストの場合、スクリプト直下のArrow Functionの`this`はグローバルオブジェクト</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span> <span class="c1">// グローバルオブジェクト</span>
<span class="c1">// callで`this`を`{}`にしようとしても、`this`は変わらない</span>
<span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">({});</span> <span class="c1">// グローバルオブジェクト</span>
</code></pre></div>
<p>最初に述べたよう<code>function</code>キーワードで定義した関数は呼び出し時に、ベースオブジェクトが暗黙的な引数のように<code>this</code>の値として渡されます。
一方、Arrow Functionの関数は呼び出し時に<code>this</code>を受け取らずに、定義時のArrow Functionにおける<code>this</code>の参照先が静的に決定されます。</p>

<!-- textlint-disable -->

<p>また、<code>this</code>が変わらないのはあくまでArrow Functionで定義した関数だけで、Arrow Functionの<code>this</code>が参照する「自身の外側のスコープにあるもっとも近い関数の<code>this</code>の値」は<code>call</code>メソッドで変更できます。</p>

<!-- textlint-enable -->
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">arrowFunction</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nx">arrowFunction</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 通常の`this`は`object.method`の`this`と同じ</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">());</span> <span class="c1">// =&gt; object</span>
<span class="c1">// `object.method`の`this`を変更すれば、Arrow Functionの`this`も変更される</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s2">&quot;THAT&quot;</span><span class="p">));</span> <span class="c1">// =&gt; &quot;THAT&quot;</span>
</code></pre></div>
<h2 id="thisの評価結果のまとめ"><code>this</code>の評価結果のまとめ</h2>

<p><code>this</code>は状況によって異なる値を参照する性質を持ったキーワードであることについてを紹介しました。
その<code>this</code>の評価結果をまとめると次の表のようになります。</p>

<p><img src="http://efcl.info/wp-content/uploads/2018/01/04-1515062936.png" alt="`this`の評価結果のまとめ"></p>

<ul>
<li><a href="https://gist.github.com/azu/9833e2f66bc8f0c97258ab0c81258469" title="`this` の穴埋めの解答">Gist: <code>this</code> の穴埋めの解答</a></li>
</ul>

<!-- textlint-disable -->

<p>実際にブラウザで実行した結果は<a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a>で確認できます。</p>

<!-- textlint-enable -->

<p>Chrome 63を使ってる人は&quot;Module&quot;コンテキストのトップレベルArrow Functionにおける<code>this</code>の挙動が表と一致しないことに気づいたかもしれません。
Chrome 63では次のコードを&quot;Module&quot;コンテキストで実行すると<code>this</code>が<code>undefined</code>ではなく、グローバルオブジェクトを参照します。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;module&quot;</span><span class="nt">&gt;</span>
<span class="c1">// &quot;Module&quot; context @ Chrome 63</span>
<span class="kr">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span> <span class="c1">// =&gt; window</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>これはChrome(V8)のバグです。すでに報告して最新のCanary(65相当)では修正されています。</p>

<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791334" title="791334 - `this` in top level Arrow Function in Module Context should be `undefined` - chromium - Monorail">791334 - <code>this</code> in top level Arrow Function in Module Context should be <code>undefined</code> - chromium - Monorail</a></li>
</ul>

<p>Chrome 63とChrome 65では次のサイトの結果は異なることが分かります。</p>

<ul>
<li><a href="https://azu.github.io/what-is-this/" title="What is `this` value in JavaScript?">What is <code>this</code> value in JavaScript?</a></li>
</ul>

<h2 id="まとめ">まとめ</h2>

<p><code>this</code>はオブジェクト指向プログラミングのメソッドでの利用を目的としています。
メソッド以外においても<code>this</code>は評価できますが、実行コンテキストやstrict modeなどによって結果が異なり混乱の元となります。
そのため、メソッド以外では<code>this</code>を使うべきではありません（ここでは紹介してないコンストラクタは例外です）</p>

<p>この記事で紹介している半分以上（トップレベルにおける<code>this</code>、関数呼び出しの<code>this</code>など)のことは知らなくても、実用的にはあまり問題はありません。
実際にはメソッドやArrow Functionにおける<code>this</code>について理解していれば十分です。
特殊な書き方をしていると必要になる知識が半分なので、普通の書き方をして普通の使い方をしましょう。</p>

<ul>
<li><a href="https://github.com/Microsoft/TypeScript/wiki/&#x27;this&#x27;-in-TypeScript" title="&amp;#39;this&amp;#39; in TypeScript · Microsoft/TypeScript Wiki">&#39;this&#39; in TypeScript · Microsoft/TypeScript Wiki</a>

<ul>
<li>TypeScript向けですが、この記事で扱った内容が簡潔にまとまっています</li>
</ul></li>
<li><a href="https://eslint.org/docs/rules/no-invalid-this" title="no-invalid-this - Rules - ESLint - Pluggable JavaScript linter">no-invalid-this - Rules - ESLint - Pluggable JavaScript linter</a>

<ul>
<li>混乱の元となる<code>this</code>の書き方をチェックするESLintのルール</li>
</ul></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">+infinity<br>JS `this` is for OO methods, not standalone functions. Never use `this` as a parameter to non-method functions. <a href="https://t.co/tFHkqEepcM">https://t.co/tFHkqEepcM</a></p>&mdash; Allen Wirfs-Brock (@awbjs) <a href="https://twitter.com/awbjs/status/938272440085446657?ref_src=twsrc%5Etfw">December 6, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote>
<p>ECMAScript 2015の仕様策定者であるAllen Wirfs-Brock‏氏の意見</p>
</blockquote>

<p>また、メソッドにおいても<code>this</code>は呼び出し方によって異なる値となり、それにより発生する問題と対処法についてを紹介しました。
コールバック関数における<code>this</code>はArrow Functionを使うことで分かりやすく解決できます。
この背景にはArrow Functionで定義した関数は<code>this</code>を持たないという性質があります。</p>

<p>もっと<code>this</code>について理解してみたい人は、書籍版も実行しながら見ると良さそうです。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a></li>
</ul>

<p>書籍の更新を追いたい方はリポジトリをStarやWatchしてください。</p>

<blockquote>
<p><a href="https://github.com/asciidwango/js-primer" title="asciidwango/js-primer: JavaScriptの入門書">asciidwango/js-primer: JavaScriptの入門書</a></p>
</blockquote>

<p><a class="github-button" href="https://github.com/asciidwango/js-primer" data-size="large" data-show-count="true" aria-label="Star asciidwango/js-primer on GitHub">Star</a>
<a class="github-button" href="https://github.com/asciidwango/js-primer/subscription" data-size="large" data-show-count="true" aria-label="Watch asciidwango/js-primer on GitHub">Watch</a></p>

<!-- Place this tag in your head or just before your close body tag. -->

<script async defer src="https://buttons.github.io/buttons.js"></script>

<h3 id="📝-note-this-binding-syntax-proposal">📝 Note: This-Binding Syntax proposal</h3>

<p>通常の関数をmixin関数のように扱いやすくする<code>::</code>という構文のProposalがありましたが、しばらくステータスが更新されていません。
(Proposalの元々のAuthorがTC39メンバーではなくなったのも1つの理由)</p>

<ul>
<li><a href="https://github.com/tc39/proposal-bind-operator" title="ECMAScript This-Binding Syntax">ECMAScript This-Binding Syntax</a></li>
</ul>

<h3 id="📝-this名前解決の仕様">📝 <code>this</code>名前解決の仕様</h3>

<p><code>this</code> bindingの設定は、関数を呼ぶときの次の仕様で決定される。</p>

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-evaluatecall">https://tc39.github.io/ecma262/#sec-evaluatecall</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-call">https://tc39.github.io/ecma262/#sec-call</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist">https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-ordinarycallbindthis">https://tc39.github.io/ecma262/#sec-ordinarycallbindthis</a></li>
</ul>

<p>大きく分けると、WriteとReadの２つのフェーズで<code>this</code>が決まる。
ここでWriteとReadとつけているけど、仕様にそういうフェーズがあるわけじゃなくて自分の解釈です。</p>

<p>Write: 関数呼び出しをする際に、その関数のFunction Environment Recordsの<code>[[ThisValue]]</code>に<code>this</code>の値を入れる</p>

<p><code>[[ThisValue]]</code>には次のステップの結果が入る。
(ただしArrow Functionはlexicalなので<code>[[ThisValue]]</code>を持たない。<a href="https://tc39.github.io/ecma262/#sec-ordinarycallbindthis">Arrow Functionの詳細</a>)</p>

<p><a href="https://tc39.github.io/ecma262/#sec-evaluatecall" title="12.3.4.2Runtime Semantics: EvaluateCall(func, ref, arguments, tailPosition )">12.3.4.2Runtime Semantics: EvaluateCall(func, ref, arguments, tailPosition )</a>のステップを参照する</p>

<ul>
<li>プロパティならば

<ul>
<li><code>this</code>は<code>GetThisValue()</code>の結果

<ul>
<li><code>super.prop</code>なら

<ul>
<li><code>super</code>となる</li>
</ul></li>
<li>それ以外なら

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-getbase" title="6.2.4.1GetBase ( V )">6.2.4.1GetBase ( V )</a>の結果</li>
<li>ベースオブジェクトが<code>this</code>となる</li>
</ul></li>
</ul></li>
</ul></li>
<li>それ以外(ただの関数呼び出し)なら<a href="https://tc39.github.io/ecma262/#sec-object-environment-records-withbaseobject">WithBaseObject</a>の結果

<ul>
<li>withの場合

<ul>
<li>with bingingの値</li>
</ul></li>
<li>それ以外

<ul>
<li>undefined</li>
</ul></li>
</ul></li>
</ul>

<p>Read: <code>this</code>という識別子から、その値が何を参照するかを決めるフェーズ</p>

<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-getthisenvironment">https://tc39.github.io/ecma262/#sec-getthisenvironment</a>

<ul>
<li><code>this</code>の解決はスコープと同じく、一個つづ順に内側から外側へ探すのはスコープチェーンと同じ

<ul>
<li>見つかるまで再帰的に外側のEnvironment Recordsを探索する</li>
<li>見つからない場合は、&quot;Script&quot;や&quot;Module&quot;の実行コンテキストの<code>this</code>の値になる</li>
<li>&quot;Module&quot;の<a href="https://tc39.github.io/ecma262/#sec-module-environment-records-getthisbinding" title="GetThisBinding ( )">GetThisBinding ( )</a>は常に<code>undefined</code></li>
<li>&quot;Script&quot;の<a href="https://tc39.github.io/ecma262/#sec-global-environment-records-getthisbinding" title="GetThisBinding ( )">GetThisBinding ( )</a>は<code>[[GlobalThisValue]]</code></li>
</ul></li>
<li>ただし、Arrow Functionは<code>[[ThisValue]]</code>を持たないので必ずスキップされる</li>
<li>もっと近い関数(Function Environment Records)の<code>[[ThisValue]]</code>の値が<code>this</code>の値となる</li>
</ul></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>今年のOSS活動振り返り @ 2017</title>
   <link href="http://efcl.info/2017/12/30/oss-in-2017/"/>
   <updated>2017-12-30T21:04:00+09:00</updated>
   <id>http://efcl.info/2017/12/30/oss-in-2017</id>
   <content type="html"><![CDATA[ <p>2017年のOSS活動の振り返り記事です。</p>

<p>今までの振り返り。</p>

<ul>
<li><a href="http://efcl.info/2016/12/31/oss-in-2016/">今年のOSS活動振り返り @ 2016 | Web Scratch</a></li>
<li><a href="http://efcl.info/2015/12/31/oss-in-2015/">今年のOSS活動振り返り @ 2015 | Web Scratch</a></li>
<li><a href="http://efcl.info/2014/12/31/oss-in-2014/">今年のOSS活動振り返り @ 2014 | Web Scratch</a></li>
</ul>

<p>2017年のGitHubのContributionsは8000~10000ぐらいを推移していました。
(1/3ぐらいは<a href="https://jser.info/" title="JSer.info">JSer.info</a>関連だと思います。)</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/12/30-1514635832.png" alt="GitHub contributions"></p>

<p>今はGitHubに表示されないけど、Current Streakは1507日でした。(1507/365 = 4.128767123年)</p>

<ul>
<li><a href="https://azu.github.io/github-longest-streak/?user=azu" title="GitHub Full Longest Streak">GitHub Full Longest Streak:azu</a>

<ul>
<li>GitHubのLongest Streakを出してくれるツール</li>
</ul></li>
</ul>

<h2 id="issue-pr">Issue/PR</h2>

<ul>
<li><a href="https://github.com/search?o=asc&amp;q=author%3Aazu+created%3A2017-01-01..2018-01-01+is%3Apr+&amp;s=updated&amp;type=Issues&amp;utf8=%E2%9C%93" title="Search · author:azu created:2017-01-01..2018-01-01 is:pr">PR</a>: 527

<ul>
<li>去年: 457</li>
</ul></li>
<li><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=author%3Aazu+created%3A2017-01-01..2018-01-01+is%3Aissue+&amp;type=Issues">Issue</a>: 485

<ul>
<li>去年: 392</li>
</ul></li>
</ul>

<p>大体同じ程度増えている感じらしい</p>

<h2 id="作ったもの"><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=user%3Atextlint+user%3Atextlint-rule+user%3Atextlint-ja+user%3Aalmin+user%3Aazu+created%3A2017-01-01..2018-01-01&amp;type=Repositories">作ったもの</a></h2>

<blockquote>
<p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=user%3Atextlint+user%3Atextlint-rule+user%3Atextlint-ja+user%3Aalmin+user%3Aazu+created%3A2017-01-01..2018-01-01&amp;type=Repositories">https://github.com/search?utf8=%E2%9C%93&amp;q=user%3Atextlint+user%3Atextlint-rule+user%3Atextlint-ja+user%3Aalmin+user%3Aazu+created%3A2017-01-01..2018-01-01&amp;type=Repositories</a></p>
</blockquote>

<ul>
<li>今年: 95</li>
<li>去年: 108</li>
</ul>

<p>去年よりも減っているのは、<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>、<a href="https://github.com/almin/almin">almin</a>、<a href="https://github.com/azu/searchive">searchive</a>、<a href="https://github.com/azu/immutable-array-prototype" title="immutable-array-prototype">immutable-array-prototype</a>などmonorepoを結構積極的に使うようになったのでその影響もあるのかも。</p>

<p>順番に何を作ってたのかを見ていく</p>

<ul>
<li><a href="https://github.com/azu/web-application-template-2016" title="azu/web-application-template-2016">azu/web-application-template-2016</a>

<ul>
<li>ウェブアプリを書くときこういうテンプレ使ってる的なやつ</li>
<li>今は<a href="https://qiita.com/azu/items/a149501ca1b5864000a3" title="React + TypeScript (+ Electron)でアプリを書き始めるときにやってること - Qiita">React + TypeScript (+ Electron)でアプリを書き始めるときにやってること - Qiita</a>みたいな感じになってる</li>
<li>手元では<code>init*.sh</code>みたいのがなんこかあってそこから選んでるだけなので変わってない</li>
</ul></li>
<li><a href="https://github.com/azu/negaposi-analyzer-ja" title="negaposi-analyzer-ja">negaposi-analyzer-ja</a>

<ul>
<li>形態素解析したテキストからネガティブ/ポジティブ(単語感情極性)を判定したスコアを返すJavaScriptライブラリ</li>
<li><a href="https://jser.info/2017/01/15/jser-info-6years/" title="JSer.info 6周年記念イベントを開催しました - JSer.info">JSer.info 6周年記念イベント</a>で<a href="http://azu.github.io/slide/2017/jser_info/how_to_make_jser_info.html" title="JSer.infoの作り方">JSer.infoの作り方</a>の発表のために作った気がする</li>
<li>JSer.infoの紹介記事は偏りのある言葉を嫌うので、実際に今までのデータを解析するために作った</li>
<li>実際にネガ・ポジは0に収束してそうだった的な話をした</li>
</ul></li>
</ul>

<p><img src="http://azu.github.io/slide/2017/jser_info/resources/feeling-words.png" alt="JSer.infoの感情情極性"></p>

<ul>
<li><a href="https://github.com/azu/access-limit-http-proxy" title="access-limit-http-proxy">access-limit-http-proxy</a>

<ul>
<li>たしか数回リクエストした時の挙動を調べるテストを書くために作った気がする。</li>
<li>3回アクセスしたら500返すみたいなプロキシ</li>
</ul></li>
<li><a href="https://github.com/azu/env-development" title="azu/env-development: Set $NODE_ENV to &amp;#34;development&amp;#34; works best with mocha --require=env-development">azu/env-development: Set $NODE_ENV to &quot;development&quot; works best with mocha --require=env-development</a>

<ul>
<li><code>process.env.NODE_ENV = &quot;development&quot;</code>するだけ</li>
<li><code>mocha --require env-development</code> したかった</li>
</ul></li>
<li><a href="https://github.com/azu/uni-gitbook-server" title="azu/uni-gitbook-server: [WIP] [Unofficial] Alternative of GitBook server.">azu/uni-gitbook-server: [WIP] [Unofficial] Alternative of GitBook server.</a>

<ul>
<li>GitBookのビルドがあまりにも遅くて作ってた</li>
<li>GitBookのwatch buildは変更 -&gt; サーバを止める -&gt; ビルド -&gt; サーバ再開 みたいな結構やばい感じだった</li>
<li>GitBook 開発チームのレスポンスもあまりにも悪かったりしてちょこちょこ不満がある(PR出しても数ヶ月放置とかがよくある)</li>
<li><a href="https://github.com/GitbookIO/gitbook/issues/1808" title="Is GitBook still alive? · Issue #1808 · GitbookIO/gitbook">Is GitBook still alive? · Issue #1808 · GitbookIO/gitbook</a></li>
<li>小さな技術書を作るためのツールはやっぱり欲しいので、どうにかしたい</li>
</ul></li>
<li><a href="https://github.com/azu/search-prototype.js" title="azu/search-prototype.js: Search usage of prototype.js in your codes.">azu/search-prototype.js: Search usage of prototype.js in your codes.</a>

<ul>
<li>コード中に<a href="http://prototypejs.org/">prototype.js</a>のメソッドがないかを検出するツール</li>
<li>公式のAPIレスポンスからメソッドのリストを作ってgraspを使ってASTで検索してる</li>
<li><a href="http://efcl.info/2017/04/26/search-prototype.js/" title="コード中にあるprototype.jsの拡張メソッドを使ってる部分を検索するツール | Web Scratch">コード中にあるprototype.jsの拡張メソッドを使ってる部分を検索するツール | Web Scratch</a></li>
<li>さすがにそろそろ亡くなったでしょうみたいな感じではあるけど、prototype拡張という性質上静的検索が難しいので、専用のツールを作った</li>
</ul></li>
<li><a href="https://github.com/azu/path-to-glob-pattern" title="azu/path-to-glob-pattern: Convert file/directory path to glob pattern.">azu/path-to-glob-pattern: Convert file/directory path to glob pattern.</a>

<ul>
<li><code>src/</code> =&gt; <code>src/**/*</code> みたいにglobに変換するライブラリ</li>
<li><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>で使ってる</li>
</ul></li>
<li><a href="https://github.com/azu/get-github-pr-review-comments" title="azu/get-github-pr-review-comments: Get PR review comments from command line.">azu/get-github-pr-review-comments: Get PR review comments from command line.</a>

<ul>
<li><a href="http://efcl.info/2017/03/06/get-pull-request-review-comments/" title="GitHubのPull Requestのレビューコメントをコマンドラインから取得するツール | Web Scratch">GitHubのPull Requestのレビューコメントをコマンドラインから取得するツール | Web Scratch</a></li>
</ul></li>
<li><a href="https://github.com/azu/position-map-text-to-markdown" title="azu/position-map-text-to-markdown: Map rendered text/html position to Markdown position.">azu/position-map-text-to-markdown: Map rendered text/html position to Markdown position.</a>

<ul>
<li>Markdownのレンダリング済みテキストから、指定した文字列が元のMarkdownでどの位置にあるかを返すライブラリ</li>
<li><a href="https://github.com/azu/gitbook-plugin-github-issue-feedback" title="gitbook-plugin-github-issue-feedback">gitbook-plugin-github-issue-feedback</a>のために作った</li>
<li><a href="http://efcl.info/2017/05/29/gitbook-plugin-github-issue-for-review/" title="書いた文章をレビューしてGitHubにIssueを切るためのGitBookプラグイン | Web Scratch">書いた文章をレビューしてGitHubにIssueを切るためのGitBookプラグイン | Web Scratch</a></li>
<li>レンダリング済みのHTMLから元のMarkdownの行数を見つける感じ</li>
</ul></li>
<li><a href="https://github.com/azu/strip-X-Frame-Options-proxy" title="azu/strip-X-Frame-Options-proxy: strip X-Frame-Options header for embedding on iframe.">azu/strip-X-Frame-Options-proxy: strip X-Frame-Options header for embedding on iframe.</a>

<ul>
<li>GitHubに3段階のiframe埋め込み拒否機能があってそれの検証</li>
<li>CSP -&gt; <code>X-Frame-Options</code> -&gt; 埋め込みJavaScriptで<code>window.top</code>をとかをみてる拒否してくる</li>
<li>結局は<code>Webview</code>とか使わないと埋め込めない</li>
</ul></li>
<li><a href="https://github.com/azu/can-use-webview" title="azu/can-use-webview: Detect if you can use electron&amp;#39; &amp;lt;webview&amp;gt;">azu/can-use-webview: Detect if you can use electron&#39; <webview></a>

<ul>
<li><code>webview</code>要素が使えるかどうかの判定</li>
</ul></li>
<li><a href="https://github.com/azu/check-invalid-control-characters" title="azu/check-invalid-control-characters: Check invalid control characters like `\u0008` in plain text.">azu/check-invalid-control-characters: Check invalid control characters like <code>\u0008</code> in plain text.</a>

<ul>
<li>Slack.app 、Electron、Chromeあたりで問題になった制御文字の問題を検出するツール</li>
<li>最近textlintでもっと便利な感じのを書いた</li>
<li><a href="http://efcl.info/2017/12/29/textlint-rule-no-invalid-control-character/" title="文中に制御文字が混じっているのを見つけて自動修正するtextlintルール | Web Scratch">文中に制御文字が混じっているのを見つけて自動修正するtextlintルール | Web Scratch</a></li>
</ul></li>
<li><a href="https://github.com/azu/localstorage-ponyfill" title="azu/localstorage-ponyfill: Universal LocalStorage for browser and Node.js.">azu/localstorage-ponyfill: Universal LocalStorage for browser and Node.js.</a>

<ul>
<li>ブラウザ、Node、Electronで動くみたいな目的の<code>localstorage</code></li>
</ul></li>
<li><a href="https://github.com/azu/video-events-debugger" title="azu/video-events-debugger: [WIP] HTML5 Video element events debugging tools.">azu/video-events-debugger: [WIP] HTML5 Video element events debugging tools.</a>

<ul>
<li><code>video</code>要素とかのイベントをひたすら見られるデバッガー</li>
</ul></li>
<li><a href="https://github.com/azu/faao" title="azu/faao: Faao is a GitHub issue/pull-request client on Electron.">azu/faao: Faao is a GitHub issue/pull-request client on Electron.</a>

<ul>
<li><a href="https://github.com/almin/almin" title="Almin">Almin</a>の技術ショーケースもかねて作ってたGitHub Issueクライアント</li>
<li>ドメインモデルとかもしっかり考えて開発してる</li>
<li><a href="http://azu.github.io/slide/2017/teppeis-sushi/client-side-ddd-on-github.html" title="Faao - ドメイン駆動設計で作るGitHub Issue Client -">Faao - ドメイン駆動設計で作るGitHub Issue Client -</a></li>
<li>方向がしっかり決まってなかったけど、<a href="https://github.com/azu/faao/issues/85" title="Redesign Faao · Issue #85 · azu/faao">Redesign Faao · Issue #85 · azu/faao</a>で方向をちゃんと定め直して開発中</li>
<li>単純に言えばGitHub Issueを使ってちゃんとTODO管理したいという話</li>
</ul></li>
<li><a href="https://github.com/azu/immutable-array-prototype" title="azu/immutable-array-prototype: A collection of Immutable Array prototype methods(Per method packages).">azu/immutable-array-prototype: A collection of Immutable Array prototype methods(Per method packages).</a>

<ul>
<li><code>Array#push</code> とかのImmutable版ほしいよねって感じで作った</li>
<li><a href="http://efcl.info/2017/07/11/immutable-array/" title="Array.prototypeのImmutable版メソッドを個別のパッケージで使えるものを作った | Web Scratch">Array.prototypeのImmutable版メソッドを個別のパッケージで使えるものを作った | Web Scratch</a></li>
<li><a href="https://github.com/azu/faao" title="Faao">Faao</a>でも使ってる

<ul>
<li>ドメインモデルもImmutableにしたいときにこういうシンプルで小さいパーツが便利で欲しかった</li>
</ul></li>
</ul></li>
<li><a href="https://github.com/azu/node-browser-shim-gap" title="azu/node-browser-shim-gap: The gap issue between Node.js and Browser shims.">azu/node-browser-shim-gap: The gap issue between Node.js and Browser shims.</a>

<ul>
<li><a href="https://gist.github.com/azu/96471e0405afa20819e2eaeb91c944db" title="Node.jsコアモジュールとブラウザ向けShimの挙動の違い(ギャップ)について">Node.jsコアモジュールとブラウザ向けShimの挙動の違い(ギャップ)について</a>の問題</li>
</ul></li>
<li><a href="https://github.com/azu/text-map-kuromoji" title="azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ">azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ</a>

<ul>
<li><a href="http://efcl.info/2017/10/19/text-map-kuromoji/" title="kuromoji.jsで形態素解析した結果とテキストの関係をビジュアライズする | Web Scratch">kuromoji.jsで形態素解析した結果とテキストの関係をビジュアライズする | Web Scratch</a></li>
<li>ビジュアライズしたくなった</li>
</ul></li>
<li><a href="https://github.com/azu/mp3cat-bin" title="azu/mp3cat-bin: Binary wrapper for mp3cat - concat mp3 files.">azu/mp3cat-bin: Binary wrapper for mp3cat - concat mp3 files.</a>

<ul>
<li>mp3の結合</li>
<li><a href="https://github.com/jser/podcast" title="jser/podcast: JSer.info podcast creator">jser/podcast: JSer.info podcast creator</a>関連</li>
</ul></li>
<li><a href="https://github.com/azu/git-commit-push-via-github-api" title="azu/git-commit-push-via-github-api: Git commit and push by using GitHub API. No depended on Git binary.">azu/git-commit-push-via-github-api: Git commit and push by using GitHub API. No depended on Git binary.</a>

<ul>
<li>GitHub APIだけでコミットやプッシュするライブラリ</li>
<li>lambdaからpushしたかった</li>
</ul></li>
<li><a href="https://github.com/azu/pronunciation-lexicon-specification-json">azu/pronunciation-lexicon-specification-json: Convert JSON to Pronunciation Lexicon Specification (PLS) XML.</a></li>
<li><a href="https://github.com/azu/pronunciation-lexicon-specification-yaml">azu/pronunciation-lexicon-specification-yaml: Convert YAML(YML) to Pronunciation Lexicon Specification(PLS) XML.</a>

<ul>
<li><a href="https://aws.amazon.com/jp/polly/" title="Amazon Polly">Amazon Polly</a>関係</li>
<li>JSON or YAMLから<a href="http://www.asahi-net.or.jp/%7Eax2s-kmtn/ref/accessibility/REC-pronunciation-lexicon-20081014.html" title="発音辞書仕様（PLS）バージョン1.0">発音辞書仕様（PLS）バージョン1.0</a>を再生する</li>
</ul></li>
<li><a href="https://github.com/azu/move-github-repository" title="azu/move-github-repository: Move GitHub repository(Update description &amp;amp;&amp;amp; URL &amp;amp;&amp;amp; default branch &amp;amp;&amp;amp; Archived).">azu/move-github-repository: Move GitHub repository(Update description &amp;&amp; URL &amp;&amp; default branch &amp;&amp; Archived).</a>

<ul>
<li>monorepo化した後のリポジトリの後片付けツール</li>
<li><a href="http://efcl.info/2017/05/22/move-github-repository/" title="GitHubのリポジトリをDeprecatedにするスクリプト | Web Scratch">GitHubのリポジトリをDeprecatedにするスクリプト | Web Scratch</a></li>
<li>GitHubはTransferできないときに、そのリポジトリからリダイレクトとかできないのでその辺をいい感じにするツール</li>
<li>最近追加されたArchieveにも対応した</li>
</ul></li>
<li><a href="https://github.com/azu/VideoPlaybackQuality-polyfill" title="azu/VideoPlaybackQuality-polyfill: A ponyfill/polyfill for VideoPlaybackQuality.">azu/VideoPlaybackQuality-polyfill: A ponyfill/polyfill for VideoPlaybackQuality.</a>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/HTMLVideoElement/getVideoPlaybackQuality" title="getVideoPlaybackQuality()">getVideoPlaybackQuality()</a>というAPIを知ったけど、Chromeが残念だったのでpolyfillを書いた</li>
</ul></li>
<li><a href="https://github.com/azu/alfred-hantebookmark-mydata" title="azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred">azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred</a>

<ul>
<li><a href="http://efcl.info/2017/10/20/alfred-hatenabookmark/" title="Alfred上で自分のはてなブックマークを検索できるWorkflow | Web Scratch">Alfred上で自分のはてなブックマークを検索できるWorkflow | Web Scratch</a></li>
<li>検索 はてブ</li>
</ul></li>
<li><a href="https://github.com/azu/performance-mark-metadata" title="azu/performance-mark-metadata: `performance.mark` with custom meta data.">azu/performance-mark-metadata: <code>performance.mark</code> with custom meta data.</a>

<ul>
<li>クライアントサイドのメトリクスを作成するためのライブラリ</li>
<li><a href="https://dev.to/azu/performancemark-with-medata-is-useful-for-real-user-monitoring-54p"><code>performance.mark</code> with metadata is useful for Real user monitoring</a></li>
<li><a href="http://efcl.info/2017/11/15/performance.mark-metadata/">performance.markにメタデータを紐付けできるライブラリを書いた | Web Scratch</a></li>
<li><a href="http://efcl.info/2017/09/20/almin-performance-profile-0.14.0/">Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように | Web Scratch</a></li>
<li>最近60ページぐらいのウェブアプリのパフォーマンス改善事例集(問題の見つけ方や修正方法、計測方法、動画とか実際のプロファイルみたいなやつ)を書いたけど、そこでも結構使った</li>
</ul></li>
<li><a href="https://github.com/azu/rc-config-loader" title="azu/rc-config-loader: Load config from .{product}rc.{json,yml,js} file">azu/rc-config-loader: Load config from .{product}rc.{json,yml,js} file</a>

<ul>
<li><code>.textlintrc</code>とかみたいによく見る設定ファイルを探して読み込むローダ</li>
<li><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>で使ってる</li>
<li><a href="https://github.com/davidtheclark/cosmiconfig" title="cosmiconfig">cosmiconfig</a>が昔非同期だけで、同期版が欲しくて作った</li>
</ul></li>
<li><a href="https://github.com/azu/github-label-setup" title="azu/github-label-setup: 📦 Setup GitHub label without configuration.">azu/github-label-setup: 📦 Setup GitHub label without configuration.</a>

<ul>
<li>最近リポジトリを作るときはラベルも設定するようにしてる</li>
<li>そのテンプレラベルを集めたもの</li>
<li><a href="http://efcl.info/2017/05/17/github-label/" title="GitHubのラベルをいい感じにセットアップするツール | Web Scratch">GitHubのラベルをいい感じにセットアップするツール | Web Scratch</a></li>
<li>知見としてはGitHubは<code>good first issue</code>など特定のラベルは優遇(Issueの画面に案内が表示される)されているのでその辺はGitHubに合わせたほうがいい</li>
</ul></li>
<li><a href="https://github.com/azu/avoid-json-stringify-on-react" title="azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&amp;#39;s shouldComponentUpdate">azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&#39;s shouldComponentUpdate</a>

<ul>
<li>Reactの<code>shouldComponentUpdate</code>でshallow equalとdeep equalの話</li>
<li><a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">Reactの公式ドキュメントでJSON.stringifyとかで比較するな</a>って話があるのでそれを検証した</li>
<li><a href="http://efcl.info/2017/11/30/shallow-equal/" title="shallow-equal for Object/React props | Web Scratch">shallow-equal for Object/React props | Web Scratch</a></li>
</ul></li>
<li><a href="https://github.com/azu/shallow-equal-object">azu/shallow-equal-object: Shallow equal check object that support TypeScript.</a></li>
<li><a href="https://github.com/azu/shallow-equal-props">azu/shallow-equal-props: Shallow Equal for React&#39;s props. Help to implement shouldComponentUpdate.</a>

<ul>
<li>上の検証時に作ったshallow equalライブラリ</li>
<li>デバッグオプションがあって何が違っているのかが確認できるのが特徴</li>
</ul></li>
<li><a href="https://github.com/azu/what-is-this" title="azu/what-is-this: What value is `this` in Strict, Script, or Module?">azu/what-is-this: What value is <code>this</code> in Strict, Script, or Module?</a>

<ul>
<li>いろんなコンテキストで<code>this</code>の値を確認するサイト</li>
<li><a href="https://azu.github.io/what-is-this/">https://azu.github.io/what-is-this/</a></li>
<li><a href="https://asciidwango.github.io/js-primer/basic/function-this/" title="関数とthis · JavaScriptの入門書 #jsprimer">関数とthis · JavaScriptの入門書 #jsprimer</a>を書くために色々検証する目的で作った</li>
<li>このツールでV8のモジュールコンテキストでは<code>this</code>がバグってるのを見つけて報告した</li>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=791334" title="791334 - `this` in top level Arrow Function in Module Context should be `undefined` - chromium - Monorail">791334 - <code>this</code> in top level Arrow Function in Module Context should be <code>undefined</code> - chromium - Monorail</a></li>
</ul></li>
<li><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.</a>

<ul>
<li><a href="http://efcl.info/2017/10/31/nlp-pattern-match/" title="自然言語にマッチする正規表現を書いて、形態素解析結果でテストして、置換するライブラリを書いた | Web Scratch">自然言語にマッチする正規表現を書いて、形態素解析結果でテストして、置換するライブラリを書いた | Web Scratch</a></li>
<li>言語処理をもっと楽にしたい！みたいな方向で書いてた</li>
<li>最近は逆に言語処理をもっと丁寧にしたい！みたいな方向で<a href="https://github.com/azu/sentence-splitter" title="sentence-splitter">sentence-splitter</a>を書き直したりした</li>
<li>多くの言語処理はただの文字列として扱ってるのが問題でその分いろんな情報がなくなってることに気づいてきた</li>
<li><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>では文章はASTにしてから扱えるので、ASTのまま言語処理してコンテキストを維持して扱いたいみたいな方向を最近やっている</li>
<li><a href="https://github.com/textlint/textlint/issues/366" title="Core rule utility · Issue #366 · textlint/textlint">Core rule utility · Issue #366 · textlint/textlint</a></li>
</ul></li>
</ul>

<h2 id="searchive"><a href="https://github.com/azu/searchive" title="azu/searchive: Search All My Documents{PDF}.">Searchive</a></h2>

<blockquote>
<p><a href="https://github.com/azu/searchive" title="azu/searchive: Search All My Documents{PDF}.">azu/searchive: Search All My Documents{PDF}.</a></p>
</blockquote>

<p><a href="https://github.com/azu/searchive" title="azu/searchive: Search All My Documents{PDF}.">Searchive</a>というローカルのPDFを全文検索、串刺し検索するアプリを書いた。</p>

<ul>
<li><a href="http://efcl.info/2017/11/17/searchive/" title="ローカルのPDFを全文検索するクライアント/サーバ/Electronアプリを書いた | Web Scratch">ローカルのPDFを全文検索するクライアント/サーバ/Electronアプリを書いた | Web Scratch</a></li>
</ul>

<p>これもmonorepoでリポジトリにアプリ、クライアント、サーバ、CLIなどが全部入ってる。</p>

<p>副産物</p>

<ul>
<li><a href="https://github.com/azu/search-query-tester" title="azu/search-query-tester: Test object with search query syntax.">azu/search-query-tester: Test object with search query syntax.</a>

<ul>
<li>GitHubみたいな検索演算子をパースしてオブジェクトにしてマッチしてくれる</li>
</ul></li>
</ul>

<h2 id="ldr">LDR</h2>

<p>残念ながらLDRが閉鎖したので<a href="http://www.inoreader.com/">Inoreader</a>に移行した。
<a href="http://www.inoreader.com/">Inoreader</a>のクライアントは満足できなかったので、<a href="https://github.com/azu/irodr" title="azu/irodr: RSS reader client like LDR for Inoreader.">irodr</a>を作って使ってる</p>

<ul>
<li><a href="https://github.com/azu/ldr-export-opml" title="azu/ldr-export-opml: Convert exported json from LDR to opml with Rate.">azu/ldr-export-opml: Convert exported json from LDR to opml with Rate.</a>

<ul>
<li>LDR閉鎖にともなってエクスポートツールを作成した</li>
<li><a href="http://efcl.info/2017/07/29/ldr-rate-export/" title="LDRのフィードをレート情報付きでエクスポートする | Web Scratch">LDRのフィードをレート情報付きでエクスポートする | Web Scratch</a></li>
</ul></li>
<li><a href="https://github.com/azu/irodr" title="azu/irodr: RSS reader client like LDR for Inoreader.">azu/irodr: RSS reader client like LDR for Inoreader.</a>

<ul>
<li><a href="http://efcl.info/2017/08/31/ldr-to-irodr/" title="LDRがサービス終了のため、Inoreader/Feedlyをバックエンドに動くRSSリーダを書いている | Web Scratch">LDRがサービス終了のため、Inoreader/Feedlyをバックエンドに動くRSSリーダを書いている | Web Scratch</a></li>
</ul></li>
<li><a href="http://irodr.netlify.com/">http://irodr.netlify.com/</a></li>
</ul>

<p>NetlifyのおかげてCORSも特に問題なくなった。
ウェブで動くInoreaderのクライアントという感じで、LDRのときと同じぐらい使ってる。</p>

<p>細かいバグとかもあるのでPR歓迎しています。
基本的にまだレート読みしか考えて作ってないのでその辺のオプションが欲しい人もIssueなどどうぞ。</p>

<ul>
<li><a href="https://github.com/azu/irodr/issues" title="Issues · azu/irodr">Issues · azu/irodr</a></li>
</ul>

<p><a href="https://github.com/almin/almin" title="Almin">Almin</a>と<a href="https://developer.microsoft.com/en-us/fabric" title="Office UI Fabric">Office UI Fabric</a>(React)を使って作った。
(2-3日ぐらいで突貫的に作れてよかった)</p>

<h2 id="almin"><a href="https://github.com/almin/almin" title="Almin">Almin</a></h2>

<p>最近Alminのサイトを<a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>で作り直した。</p>

<ul>
<li><a href="http://efcl.info/2017/12/26/docusaurus-almin/" title="AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した | Web Scratch">AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した | Web Scratch</a></li>
</ul>

<p>Almin自体はあいかわらずアプリを作る際にもっとドメインに集中できるようにすることを目的に作ってる。最近、よそでも使ってくれてる人が増えてきてる。</p>

<ul>
<li><a href="https://qiita.com/kmdsbng/items/dc03d89c0ca5acc30a44" title="Almin.js がやってくれること - Qiita">Almin.js がやってくれること - Qiita</a></li>
<li><a href="https://qiita.com/tsuwatch/items/d53c4bb940ecde7016de" title="Electronアプリをリリースするまでにあった知見 - Qiita">Electronアプリをリリースするまでにあった知見 - Qiita</a></li>
</ul>

<p>既にあるAPIを使ってアプリを作るみたいなところには<a href="https://github.com/almin/almin" title="Almin">Almin</a>は結構強い部分はあるし(クライアントに裁量を強く持たせられる)、<a href="https://github.com/azu/searchive" title="azu/searchive: Search All My Documents{PDF}.">Searchive</a>みたいにほぼReduxみたいなこともできるので、その辺はちゃんとドキュメントを整備していきたい。</p>

<p><a href="https://github.com/almin/almin" title="Almin">Almin</a>へのコントビュートはいつでも歓迎しています。
興味がある人は<a href="https://github.com/almin/almin/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>や<a href="https://github.com/almin/almin/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>label:&quot;good first issue&quot;</code></a>から見てくれると手が出しやすい気がします。</p>

<p>増えたライブラリとかツール</p>

<ul>
<li><a href="https://github.com/almin/almin/tree/master/packages/almin-react-container" title="almin-react-container">almin-react-container</a>

<ul>
<li>AlminとReactを連携するContainerコンポーネント</li>
</ul></li>
<li><a href="https://github.com/almin/almin-usecase-map-generator" title="almin/almin-usecase-map-generator: Command line tool that generate UseCase map from almin&amp;#39;s UseCases.">almin/almin-usecase-map-generator: Command line tool that generate UseCase map from almin&#39;s UseCases.</a>

<ul>
<li>Alminのユースケースからユースケース図を自動生成するツール</li>
<li>例) <a href="https://azu.github.io/faao/meta/use-case.html" title="Faao - UseCase architecture">Faao - UseCase architecture</a></li>
</ul></li>
</ul>

<p><img src="https://github.com/almin/almin-usecase-map-generator/raw/master/out.png" alt="https://github.com/almin/almin-usecase-map-generator/raw/master/out.png"></p>

<ul>
<li><a href="https://github.com/almin/almin-devtools" title="almin/almin-devtools: Integrate almin into redux-devtools">almin/almin-devtools: Integrate almin into redux-devtools</a>

<ul>
<li><a href="https://github.com/zalmoxisus/redux-devtools-extension" title="redux-devtools-extension">redux-devtools-extension</a>をAlminを繋ぐ開発者ツール</li>
<li>ActionとかStateを開発者ツール的に見られる</li>
</ul></li>
<li><a href="https://github.com/almin/migration-tools" title="almin/migration-tools: Migration scripts for Almin.">almin/migration-tools: Migration scripts for Almin.</a>

<ul>
<li>マイグレーションツール</li>
<li><a href="https://github.com/avajs/ava-codemods" title="avajs/ava-codemods: Codemods for AVA">avajs/ava-codemods: Codemods for AVA</a>がかっこよかったので作った</li>
<li>最近<a href="https://github.com/facebook/jscodeshift" title="jscodeshift">jscodeshift</a>があんまりアクティブじゃなくてちょっとリスクあるかもと思った</li>
<li>Babelのメジャーアップデートもあるので</li>
</ul></li>
<li><a href="https://github.com/almin/ddd-base" title="almin/ddd-base: DDD base class library for JavaScript application.">almin/ddd-base: DDD base class library for JavaScript application.</a>

<ul>
<li>DDDには別にベースはいらないんだけど、やっぱり毎回同じような基礎部品がでてきてしまうのでその辺をとりあえず書いてみた</li>
<li>これ自体が何かできるというわけでもないので、ちょっとだけ便利になるかも的な補助ライブラリ(設計は助けてくれない)</li>
</ul></li>
</ul>

<p>本体もかなり書き換えてTypeScript化したり基盤部分のライフサイクルをしっかりもつようになった。後はどういうユースケースがあるかに基づいて進んでいく段階になっていると思う。</p>

<ul>
<li><a href="http://efcl.info/2017/07/24/almin-0.13/" title="Almin 0.13リリース - アプリケーションレイヤーのトランザクション | Web Scratch">Almin 0.13リリース - アプリケーションレイヤーのトランザクション | Web Scratch</a></li>
<li><a href="http://efcl.info/2017/07/17/JavaScript-to-TypeScript/" title="JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch">JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch</a></li>
<li><a href="http://efcl.info/2017/03/08/almim0.10/" title="Inroducing Almin 0.10.0: TypeScript, FlowType, Logger | Web Scratch">Inroducing Almin 0.10.0: TypeScript, FlowType, Logger | Web Scratch</a></li>
</ul>

<h2 id="textlint"><a href="https://github.com/textlint/textlint" title="textlint">textlint</a></h2>

<p>自然言語のLintツールの<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>はあいかわらず開発してて、色々なルールや本体の改善をした。</p>

<p>この一年で</p>

<ul>
<li>TypeScript化

<ul>
<li><a href="http://efcl.info/2017/11/06/textlint-core-refactoring/" title="textlintのコアをTypeScriptで書き直した、textlintの今後について | Web Scratch">textlintのコアをTypeScriptで書き直した、textlintの今後について | Web Scratch</a></li>
</ul></li>
<li>monorepo化</li>
<li>メインのコントビューターが2人増えた

<ul>
<li><a href="http://efcl.info/2017/12/18/textlint-10.0.0/" title="textlint 10.0.0 リリース | Web Scratch">textlint 10.0.0 リリース | Web Scratch</a></li>
<li>人も増えて開発も活発化しています</li>
</ul></li>
</ul>

<p>こちらも<a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>や初めてでも手が付けやすい<a href="https://github.com/textlint/textlint/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>label:&quot;good first issue&quot;</code></a>がついたIssueがあります。</p>

<ul>
<li><a href="https://gist.github.com/azu/2b482e8e2aa636970f5f6110f6488719" title="textlintの直し方">textlintの直し方</a></li>
</ul>

<p>コントビュートはいつでも歓迎してるので、何かやってみたいという人はお知らせください。</p>

<p><a href="https://gitter.im/textlint-ja/textlint-ja?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/textlint-ja/textlint-ja.svg" alt="Gitter"></a></p>

<p>アプリ</p>

<ul>
<li><a href="https://github.com/textlint/textlint-app" title="textlint/textlint-app: textlint standalone application top on Electron.">textlint/textlint-app: textlint standalone application top on Electron.</a>

<ul>
<li>Nodeのインストールもいらない単独で動くtextlintアプリ</li>
<li><a href="http://efcl.info/2017/05/12/textlint-app/" title="textlintのElectronアプリを作った | Web Scratch">textlintのElectronアプリを作った | Web Scratch</a></li>
<li>メンテしたいなー</li>
</ul></li>
</ul>

<p>ルール</p>

<ul>
<li><a href="https://github.com/textlint-ja/textlint-rule-no-mixed-zenkaku-and-hankaku-alphabet" title="textlint-ja/textlint-rule-no-mixed-zenkaku-and-hankaku-alphabet: 全角と半角アルファベットを混在をチェックするtextlintルール">textlint-ja/textlint-rule-no-mixed-zenkaku-and-hankaku-alphabet: 全角と半角アルファベットを混在をチェックするtextlintルール</a></li>
<li><a href="https://github.com/textlint-ja/textlint-rule-ja-unnatural-alphabet" title="textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール">textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール</a></li>
<li><a href="https://github.com/azu/textlint-rule-period-in-list-item" title="azu/textlint-rule-period-in-list-item: textlint rule that check with or without period in list item.">azu/textlint-rule-period-in-list-item: textlint rule that check with or without period in list item.</a></li>
<li><a href="https://github.com/textlint-ja/textlint-rule-no-insert-dropping-sa" title="textlint-ja/textlint-rule-no-insert-dropping-sa: サ抜き、サ入れ表現の誤用をチェックするtextlintルール">textlint-ja/textlint-rule-no-insert-dropping-sa: サ抜き、サ入れ表現の誤用をチェックするtextlintルール</a></li>
<li><a href="https://github.com/azu/textlint-rule-abbr-within-parentheses" title="azu/textlint-rule-abbr-within-parentheses: textlint rule check if write abbreviations within parentheses.">azu/textlint-rule-abbr-within-parentheses: textlint rule check if write abbreviations within parentheses.</a></li>
<li><a href="https://github.com/textlint-ja/textlint-rule-prefer-tari-tari" title="textlint-ja/textlint-rule-prefer-tari-tari: 例示・並列・対表現の「〜たり〜たりする」をチェックするtextlintルール">textlint-ja/textlint-rule-prefer-tari-tari: 例示・並列・対表現の「〜たり〜たりする」をチェックするtextlintルール</a></li>
<li><a href="https://github.com/textlint-rule/textlint-rule-en-capitalization" title="textlint-rule/textlint-rule-en-capitalization: textlint rule that check capitalization in english text.">textlint-rule/textlint-rule-en-capitalization: textlint rule that check capitalization in english text.</a></li>
<li><a href="https://github.com/textlint-rule/textlint-rule-preset-google" title="textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.">textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.</a>

<ul>
<li>Google開発者ドキュメントガイドのルール化</li>
</ul></li>
</ul>

<p>ライブラリ</p>

<ul>
<li><a href="https://github.com/azu/check-ends-with-period" title="azu/check-ends-with-period: Check the text is ends with period mark.">azu/check-ends-with-period: Check the text is ends with period mark.</a></li>
<li><a href="https://github.com/azu/english-article-classifier" title="azu/english-article-classifier: Classifier english article(a, an).">azu/english-article-classifier: Classifier english article(a, an).</a></li>
</ul>

<p>関連</p>

<ul>
<li><a href="https://github.com/textlint-ja/technological-book-corpus-ja" title="textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス">textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス</a>

<ul>
<li>コーパス</li>
</ul></li>
<li><a href="https://github.com/azu/textlint-reviewdog-example" title="azu/textlint-reviewdog-example: textlint + reviewdog example project">azu/textlint-reviewdog-example: textlint + reviewdog example project</a>

<ul>
<li><a href="https://qiita.com/azu/items/c563da0b5455a1b1dca2" title="reviewdogを使ってtextlintの結果をPull Requestに書き込む方法 - Qiita">reviewdogを使ってtextlintの結果をPull Requestに書き込む方法 - Qiita</a>のサンプル</li>
</ul></li>
</ul>

<h2 id="javascript入門本"><a href="https://asciidwango.github.io/js-primer/">JavaScript入門本</a></h2>

<p><a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>というJavaScriptの入門書を書いています。書く部分自体については殆ど決まっていて、書く項目をあと少しになってきました。来年中にはなんとかなるはず。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/" title="この書籍について · JavaScriptの入門書 #jsprimer">この書籍について · JavaScriptの入門書 #jsprimer</a></li>
</ul>

<p>既にウェブで見られるので、おかしなところは気軽にIssue登録とかPR出してみてください。</p>

<h2 id="その他">その他</h2>

<h3 id="sc22-ecmascript-ad-hoc委員会"><a href="http://azu.github.io/slide/2016/jser5years/sc22-ecmascript-ahodc.html" title="SC22 ECMAScript Ad hoc委員会">SC22 ECMAScript Ad hoc委員会</a></h3>

<p><a href="http://azu.github.io/slide/2016/jser5years/sc22-ecmascript-ahodc.html" title="SC22 ECMAScript Ad hoc委員会">SC22 ECMAScript Ad hoc委員会</a>の活動としてECMA 404やECMA 414のISO標準化のレビューをした。</p>

<ul>
<li><a href="http://efcl.info/2017/02/27/ecma-414/" title="ECMA-414 ECMAScript Specification Suiteについて | Web Scratch">ECMA-414 ECMAScript Specification Suiteについて | Web Scratch</a></li>
<li><a href="https://dev.to/azu/ecma-404json-and-ecmascript-will-be-iso-standards-9g3" title="ECMA 404(JSON) and ECMAScript will be ISO standards">ECMA 404(JSON) and ECMAScript will be ISO standards</a></li>
<li><a href="http://efcl.info/2017/04/24/node-25/" title="Node学園 25時限目でECMAScriptの国際標準化の話をした | Web Scratch">Node学園 25時限目でECMAScriptの国際標準化の話をした | Web Scratch</a></li>
</ul>

<h3 id="jser-info"><a href="https://jser.info/" title="JSer.info">JSer.info</a></h3>

<p>今年の初めに<a href="https://jser.info/2017/01/15/jser-info-6years/" title="JSer.info 6周年記念イベントを開催しました - JSer.info">JSer.info 6周年記念イベントを開催しました - JSer.info</a>をやった。来年の1月で7周年だけど、ちょっと時期的に7周年イベントはできなさそう。</p>

<p><a href="https://github.com/jser/podcast" title="jser/podcast: JSer.info podcast creator">jser/podcast: JSer.info podcast creator</a>とか新しいことにもちゃんと挑戦していきたい。</p>

<h2 id="書けなかった">書けなかった</h2>

<ul>
<li><a href="https://github.com/azu/technical-writing-tips" title="azu/technical-writing-tips">azu/technical-writing-tips</a></li>
<li><a href="https://github.com/azu/information-technology" title="azu/information-technology: 情報の読み方と伝え方">azu/information-technology: 情報の読み方と伝え方</a></li>
</ul>

<h2 id="まとめ">まとめ</h2>

<p>完全に新規で作ってるものがちょっと減っている気がする。
この辺はリソース配分の問題もあるけど、ちゃんと作っていきたい。</p>

<p>後、手をつけようとしてちゃんと終わりまで持っていけてないものがちょこちょこ出てきているので、その辺をどうやれば進められるかを考えていきたい。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>文中に制御文字が混じっているのを見つけて自動修正するtextlintルール</title>
   <link href="http://efcl.info/2017/12/29/textlint-rule-no-invalid-control-character/"/>
   <updated>2017-12-29T12:33:00+09:00</updated>
   <id>http://efcl.info/2017/12/29/textlint-rule-no-invalid-control-character</id>
   <content type="html"><![CDATA[ <p><a href="https://ja.wikipedia.org/wiki/%E5%88%B6%E5%BE%A1%E6%96%87%E5%AD%97" title="制御文字">制御文字</a>は色々ありますが、通常の文中に出てくる制御文字は復帰(<code>r</code>)、改行(<code>\n</code>)、タブ(<code>\t</code>)など限られたものだけだと思います。それ以外の制御文字は文中に入ると文字化けしたりします。</p>

<p><img src="https://monosnap.com/file/UjfDjfC7pmKgAJtz52Eot0DQn3MSP1.png" alt="cc"></p>

<p>次の記事では文中に制御文字が入った場合の問題を紹介しています。</p>

<ul>
<li><a href="https://dev.classmethod.jp/non-programming/texteditor_garbled_letter/" title="テキストエディタ内の「見えない何か」を見つける #atom #sublime ｜ Developers.IO">テキストエディタ内の「見えない何か」を見つける #atom #sublime ｜ Developers.IO</a></li>
</ul>

<p>最近、Slackアプリでバックスペースがおかしな文字が入っていたのも同じような原因です。</p>

<ul>
<li><a href="http://fortkle.hatenablog.com/entry/2017/05/24/104014" title="【10/2 追記 】MacのSlack.appで日本語入力すると変なスペースが入る問題への対応 - Today Fortkle Learned.">【10/2 追記 】MacのSlack.appで日本語入力すると変なスペースが入る問題への対応 - Today Fortkle Learned.</a></li>
</ul>

<p>これらを見つける<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>ルールとして<a href="https://github.com/textlint-rule/textlint-rule-no-invalid-control-character" title="@textlint-rule/textlint-rule-no-invalid-control-character">@textlint-rule/textlint-rule-no-invalid-control-character</a>を作りました。</p>

<p>すべての制御文字を禁止すると改行すら出来なくなってしまうので次の制御文字は許可されています。
また、チェックするのはただの文字列中に制御文字が混じってる場合のみで、CodeBlockの中などはチェックしないので問題ありません。</p>

<h3 id="許可されている制御文字">許可されている制御文字</h3>

<ul>
<li><code>\r</code></li>
<li><code>\n</code></li>
<li><code>\t</code></li>
</ul>

<h3 id="許可されていない制御文字">許可されていない制御文字</h3>

<p>その他の<a href="https://en.wikipedia.org/wiki/Control_character" title="Control character">Control character</a>であるもの</p>

<ul>
<li><code></code>(<code>\u0010</code> DATA LINK ESCAPE)</li>
<li><code></code>(<code>\u0019</code> ND OF MEDIUM)</li>
<li>etc...</li>
</ul>

<h2 id="インストール">インストール</h2>

<p><a href="https://github.com/textlint-rule/textlint-rule-no-invalid-control-character" title="@textlint-rule/textlint-rule-no-invalid-control-character">@textlint-rule/textlint-rule-no-invalid-control-character</a>はnpmでインストールできます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install @textlint-rule/textlint-rule-no-invalid-control-character
</code></pre></div>
<h2 id="使い方">使い方</h2>

<p><code>.textlintrc</code>に設定するだけです。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;@textlint-rule/no-invalid-control-character&quot;</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="オプション">オプション</h2>

<ul>
<li><code>allow</code>: <code>string[]</code>

<ul>
<li>例外として許可したい制御文字を指定</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;@textlint-rule/no-invalid-control-character&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;allow&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="s2">&quot;\v&quot;</span>
            <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="おわりに">おわりに</h2>

<p><code>\u0019</code>などの制御文字が文中に入るのはIMのバグとか何らかの問題がある場合が殆どだと思うので、デフォルトで弾くのが良い気がします。</p>

<p><a href="https://github.com/textlint-rule/textlint-rule-no-invalid-control-character" title="@textlint-rule/textlint-rule-no-invalid-control-character">@textlint-rule/textlint-rule-no-invalid-control-character</a>に似たルールとして、Macでコピペすると濁点が分離する問題を見つける<a href="https://github.com/azu/textlint-rule-no-nfd" title="textlint-rule-no-nfd">textlint-rule-no-nfd</a>などがあります。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>AlminのサイトをOSSドキュメントツールのdocusaurusで作り直した</title>
   <link href="http://efcl.info/2017/12/26/docusaurus-almin/"/>
   <updated>2017-12-26T09:48:00+09:00</updated>
   <id>http://efcl.info/2017/12/26/docusaurus-almin</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/almin/almin" title="Almin">Almin</a>では元々GitBookを使ったドキュメントサイトを<a href="https://almin.js.org/">https://almin.js.org/</a>で公開していました。
最近、OSS向けのドキュメントサイト作成ツールである<a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>が公開されたのを受けて、<a href="https://www.gitbook.com/">GitBook</a>から<a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>に移行しました。</p>

<ul>
<li>Alminのサイト: <a href="https://almin.js.org/" title="Almin · Flux/CQRS patterns for JavaScript application.">Almin · Flux/CQRS patterns for JavaScript application.</a>

<ul>
<li><a href="https://github.com/almin/almin">https://github.com/almin/almin</a></li>
</ul></li>
</ul>

<p><a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>は<q>Easy to Maintain Open Source Documentation Websites</q>とあるようにOSSのライブラリやプロダクト向けのドキュメントサイトを作る一種の静的サイトジェネレーターです。</p>

<p><a href="https://docusaurus.io/"><img src="http://efcl.info/wp-content/uploads/2017/12/26-1514286444.png" alt="Docusaurus"></a></p>

<p>Facebookから公開されていることからも分かるように、<a href="http://facebook.github.io/jest/" title="Jest">Jest</a>や<a href="https://prettier.io/" title="Prettier">Prettier</a>(Facebookプロダクトではないけど中にFacebookの<a href="https://github.com/vjeux" title="vjeux">vjeux</a>さんがいる)などが利用しています。</p>

<p>特徴としてはMarkdownでドキュメントと目次を書いてドキュメントサイトを作ることができます。
また、Reactを使ったカスタマイズ、バージョニングへの対応、<a href="https://crowdin.com/" title="Crowdin">Crowdin</a>を使った翻訳への対応、ブログ機能やalgoliaを使った検索などライブラリサイト向けの機能を持っています。</p>

<p>ライブラリなどはバージョンで大きく変わったときに旧バージョンのドキュメントを残す仕組みがあると便利です。またリリースノートを書く際に簡単なブログがあると置き場所に困らないので便利です。
(Organizationのコミュニティとして利用できる仕組みを持ったもとしては<a href="https://dev.to/">dev.to</a>などがあります)</p>

<p>また、ReactやESLintのサイトなどでも見かける<a href="https://community.algolia.com/docsearch/" title="DocSearch">Algolia DocSearch</a>との検索連携もオプションも簡単にできます。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Get search feature🔎<a href="https://t.co/5ArxMldalw">https://t.co/5ArxMldalw</a><br><br>Thanks to <a href="https://twitter.com/algolia?ref_src=twsrc%5Etfw">@algolia</a> DocSearch <a href="https://t.co/0Ort7svZdf">pic.twitter.com/0Ort7svZdf</a></p>&mdash; alminjs (@alminjs) <a href="https://twitter.com/alminjs/status/943113112193941504?ref_src=twsrc%5Etfw">December 19, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>そのほかの概要については次の記事で紹介されていますが、Jekyllをドキュメントサイト向けに特化したというのが近い感触です。</p>

<ul>
<li><a href="https://docusaurus.io/blog/2017/12/14/introducing-docusaurus.html" title="Introducing Docusaurus · Docusaurus">Introducing Docusaurus · Docusaurus</a></li>
</ul>

<h2 id="gitbookからdocusaurusへの移行">GitBookからDocusaurusへの移行</h2>

<p><a href="https://almin.js.org/">https://almin.js.org/</a>は元々GitBookで動いていましたが、<a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>に移行しています。
GitBookは便利で<a href="https://github.com/asciidwango/js-primer">JavaScriptの入門書</a>や<a href="https://github.com/azu/JavaScript-Plugin-Architecture" title="JavaScriptプラグインアーキテクチャの本">JavaScriptプラグインアーキテクチャの本</a>でも使っていますが、ドキュメントサイト向けかというとそうでもない気がします。またファイル数が多くなると<code>gitbook serve</code>が異常なほど重くなる問題があります。
<a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>のサイトを見ていて、移行できそうと思ったのとブログ機能なども欲しかったので試しに移行してみました。</p>

<p>詳細は次のPRでまるっと移行しました。
合わせて<a href="https://www.netlify.com/" title="Netlify">Netlify</a>のPRプレビュー機能を使って、PRを出したら<a href="https://deploy-preview-304--almin.netlify.com/">https://deploy-preview-304--almin.netlify.com/</a>という感じでプレビューできるようにして進めました。</p>

<ul>
<li>PR: <a href="https://github.com/almin/almin/pull/304" title="docs(website): use docusaurus instead of GitBook by azu · Pull Request #304 · almin/almin">docs(website): use docusaurus instead of GitBook by azu · Pull Request #304 · almin/almin</a></li>
</ul>

<p>GitBookからDocusaurusへの移行に関するマイグレーションツールは特にありませんが、どちらも次の点が共通しています。</p>

<ul>
<li>ページをMarkdownで書く

<ul>
<li>YAMLなヘッダ + Markdown本体でほぼおなじ</li>
</ul></li>
<li>目次からページへのリンクを貼る

<ul>
<li>GitBookは<code>SUMMARY.md</code>からのリンク</li>
<li>Docusaurusはページに<code>id</code>を振って、<a href="https://github.com/almin/almin/blob/master/website/sidebars.json" title="sidebars.json">sidebars.json</a>から<code>id</code>の一覧をまとめる</li>
</ul></li>
</ul>

<p><a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>は<a href="https://docusaurus.io/docs/en/installation.html" title="Installation · Docusaurus">Installation · Docusaurus</a>にあるように、<code>docusaurus-init</code>をインストールして実行するとサイトのテンプレートを作ってくれます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install --global docusaurus-init
docusaurus-init
</code></pre></div>
<p>テンプレを生成したら、後は地道にリネームして移行しました。</p>

<ul>
<li><code>docs/</code> にMarkdownファイルをフラットに配置する

<ul>
<li>それぞれのMarkdownのYAMLヘッダに<code>id</code>と<code>title</code>を振る</li>
</ul></li>
<li><code>sidebar.json</code> に <code>id</code> をグループごとにまとめる。</li>
<li><a href="https://github.com/almin/almin/blob/master/website/siteConfig.js" title="siteConfig.js">siteConfig.js</a>にサイトタイトルとかを設定する

<ul>
<li>タイトルとかアイコンとかURLとかヘッダとか検索機能の有無、ブログの有無とか</li>
</ul></li>
<li>サイトデザインはGridコンポーネントなどよくあるパターンが用意されている

<ul>
<li>CSSは10行もかかないでいい感じになる</li>
</ul></li>
</ul>

<p><code>docs/</code>(このディレクトリ自体は変更できる)以下のフラットにMarkdownファイルを置かないと行けないのは制約のようです。</p>

<blockquote>
<p>Note that all of your documentation .md files must still reside in a flat hierarchy. You cannot have your documents in nested directories.<br>
<a href="https://docusaurus.io/docs/en/site-config.html#optional-fields" title="siteConfig.js · Docusaurus">siteConfig.js · Docusaurus</a></p>
</blockquote>

<p>Alminではフラットにしてかつファイル名を大文字小文字にするようにしました。
URLは<code>id</code>によって決定されるため、ファイル名とは別で管理できます。</p>

<ul>
<li><a href="https://github.com/almin/almin/tree/master/docs" title="almin/docs/">almin/docs/</a></li>
</ul>

<p><img src="http://efcl.info/wp-content/uploads/2017/12/26-1514284267.png" alt="dicrectory"></p>

<p>こうしたできたのが次のサイトです。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Almin get new website!<a href="https://t.co/5ArxMldalw">https://t.co/5ArxMldalw</a><br><br>Thanks to <a href="https://twitter.com/docusaurus?ref_src=twsrc%5Etfw">@docusaurus</a> <a href="https://t.co/OmrXn9SI8d">pic.twitter.com/OmrXn9SI8d</a></p>&mdash; alminjs (@alminjs) <a href="https://twitter.com/alminjs/status/942068484560715776?ref_src=twsrc%5Etfw">December 16, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>次の記事でも使い方を解説されてるので併せてみるといいかもしれません。</p>

<ul>
<li><a href="https://qiita.com/takeyuichi/items/835f2f5a882e3144e759" title="(OSS向け)ドキュメントツールDocusaurus - Qiita">(OSS向け)ドキュメントツールDocusaurus - Qiita</a></li>
</ul>

<h3 id="algolia-docsearchでの全文検索"><a href="https://community.algolia.com/docsearch/" title="DocSearch">Algolia DocSearch</a>での全文検索</h3>

<p>Docusaurusは<a href="https://community.algolia.com/docsearch/" title="DocSearch">DocSearch</a>での検索連携ができます。
<a href="https://community.algolia.com/docsearch/" title="DocSearch">DocSearch</a>はクロールしていい感じの検索結果とUIを提供してくれるサービです。(OSS向けで無料でやってくれる)</p>

<p><a href="https://eslint.org/">ESLint</a>や<a href="vuejs.org/guide/">Vue</a>、<a href="https://reactjs.org/">React</a>など最近の有名なツールでドキュメントがしっかりとあるものは、使ってることが多いので見たことがある人も多いかもしれません。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/12/26-1514284622.png" alt="eslint"></p>

<p>とても便利なのですが、この申請フローがなぜかマニュアルだったので有効化の仕方をメモって置きます。</p>

<ol>
<li><a href="https://community.algolia.com/docsearch/" title="DocSearch">DocSearch</a>のサイトでURLとメールアドレスを入れて申請する</li>
<li>このサイトのOwnerですかって確認メールがくる

<ul>
<li>このOrganizationのOwner権限を持ってて、このリポジトリで管理してるサイトだよって伝えた</li>
<li>後Docusaurusを使ってるサイトだよって書いた</li>
</ul></li>
<li>有効化したよってメール来る

<ul>
<li><a href="https://github.com/algolia/docsearch-configs/blob/master/configs/almin_js.json" title="docsearch-configs/almin_js.json at master · algolia/docsearch-configs">docsearch-configs/almin_js.json at master · algolia/docsearch-configs</a>が配置される</li>
</ul></li>
</ol>

<p>さすがにそのうち自動化される気がしますが、<a href="https://github.com/algolia/docsearch-configs/blob/master/configs/almin_js.json" title="docsearch-configs/almin_js.json at master · algolia/docsearch-configs">docsearch-configs/almin_js.json at master · algolia/docsearch-configs</a>を見る感じだとクロールする設定を追加したら有効化されるようです(申請から2-3日かかります)</p>

<h2 id="おわりに">おわりに</h2>

<p><a href="https://docusaurus.io/" title="Docusaurus">Docusaurus</a>はまだ公開されたばかりで、おかしなところはいくつかありますが、よくできていてドキュメントに必要な機能が大体あって便利です。
(<a href="https://github.com/azu/gitbook-plugin-include-codeblock" title="gitbook-plugin-include-codeblock">gitbook-plugin-include-codeblock</a>みたいなコードインポート機能は欲しいけど、プラグインの仕組みがあるので何とかできそう)</p>

<p>オープンソースで公開されているので、色々コントビュートしていきたいなという感じです。</p>

<ul>
<li><a href="https://github.com/facebook/Docusaurus" title="facebook/Docusaurus: Easy to maintain open source documentation websites.">facebook/Docusaurus: Easy to maintain open source documentation websites.</a></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ドキュメントツール なんか個性的なデザインをつくれる柔軟性よりも、簡単に作れるとかなんとなくいい感じになるが求められてる感じ</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/944196537126567937?ref_src=twsrc%5Etfw">December 22, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Docusaurusはこんなツールです。(GitBookもそうではあった)</p>

<p><a href="https://almin.js.org/">https://almin.js.org/</a> はDocusaurusが公開された翌日にDocusaurus化したので、Facebook関係以外で初めて<a href="docusaurus.io/en/users.html">Docusaurus User</a>に載せてもらいました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://t.co/x6IYfCujya">https://t.co/x6IYfCujya</a><br><br>Almin is new user of docusaurus! <a href="https://t.co/r6XHhUvEHK">pic.twitter.com/r6XHhUvEHK</a></p>&mdash; alminjs (@alminjs) <a href="https://twitter.com/alminjs/status/942896757024866304?ref_src=twsrc%5Etfw">December 18, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
 ]]></content>
 </entry>
 
 <entry>
   <title>textlint 10.0.0 リリース</title>
   <link href="http://efcl.info/2017/12/18/textlint-10.0.0/"/>
   <updated>2017-12-18T19:54:00+09:00</updated>
   <id>http://efcl.info/2017/12/18/textlint-10.0.0</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/textlint/textlint/tree/master/packages/textlint" title="textlint">textlint</a> 10.0.0をリリースしました。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/releases/tag/textlint%4010.0.0" title="Release textlint 10.0.0 · textlint/textlint">Release textlint 10.0.0 · textlint/textlint</a></li>
</ul>

<h2 id="変更点">変更点</h2>

<p><a href="https://github.com/textlint/textlint/releases/tag/textlint%4010.0.0" title="textlint 10.0.0">textlint 10.0.0</a>の主な変更点です。</p>

<h2 id="🆕-features">🆕 Features</h2>

<h3 id="textlint-ast-node-typesがtxtnodeの型定義を持つように">@textlint/ast-node-typesが<code>TxtNode</code>の型定義を持つように</h3>

<p><a href="https://github.com/textlint/textlint/tree/master/packages/%40textlint/ast-node-types" title="@textlint/ast-node-types">@textlint/ast-node-types</a>という内部的に使ってるものがtextlintのパーサが作る<code>TxtNode</code>の型定義を持つようになりました。<a href="https://github.com/textlint/textlint/issues/358">#358</a> </p>

<p>textlintのASTを扱いたいTypeScriptユーザーはこれを利用できるので、textlint pluginを作りたいとかしたい人は便利かもしれません。</p>

<p>詳しくは<a href="https://github.com/textlint/textlint/blob/master/docs/txtnode.md">TxtNodeのドキュメント</a>を見てください</p>

<h3 id="textlintがtypescriptで扱えるように-248">textlintがTypeScriptで扱えるように <a href="https://github.com/textlint/textlint/issues/248">#248</a></h3>

<p>以前の9.0.0のリリースでtextlintのコアエンジンである<a href="https://github.com/textlint/textlint/tree/master/packages/%40textlint/kernel" title="@textlint/kernel">@textlint/kernel</a>をTypeScript化しました。</p>

<ul>
<li><a href="http://efcl.info/2017/11/06/textlint-core-refactoring/" title="textlintのコアをTypeScriptで書き直した、textlintの今後について | Web Scratch">textlintのコアをTypeScriptで書き直した、textlintの今後について | Web Scratch</a></li>
</ul>

<p>今回の10.0.0で<a href="https://github.com/textlint/textlint/tree/master/packages/%40textlint/kernel" title="@textlint/kernel">@textlint/kernel</a>と<a href="https://github.com/textlint/textlint/tree/master/packages/textlint" title="textlint">textlint</a>(CLIも含む)がどちらもTypeScript化しました。
これによりTypeScriptからtextlintが扱いやすくなりました。</p>
<div class="highlight"><pre><code class="language-ts" data-lang="ts"><span class="c1">// Types</span>
<span class="kr">import</span> <span class="p">{</span>
    <span class="nx">TextlintResult</span><span class="p">,</span>
    <span class="nx">TextlintFixResult</span><span class="p">,</span>
    <span class="nx">TextlintFixCommand</span><span class="p">,</span>
    <span class="nx">TextlintMessage</span><span class="p">,</span>
    <span class="c1">// Kernel rule/filter/plugin format</span>
    <span class="nx">TextlintKernelRule</span><span class="p">,</span>
    <span class="nx">TextlintKernelFilterRule</span><span class="p">,</span>
    <span class="nx">TextlintKernelPlugin</span><span class="p">,</span>
    <span class="c1">// Notes: Following interface will be separated module in the future.</span>
    <span class="c1">// textlint rule interface</span>
    <span class="nx">TextlintRuleCreator</span><span class="p">,</span>
    <span class="nx">TextlintRuleOptions</span><span class="p">,</span>
    <span class="c1">// textlint filter rule interface</span>
    <span class="nx">TextlintFilterRuleCreator</span><span class="p">,</span>
    <span class="nx">TextlintFilterRuleOptions</span><span class="p">,</span>
    <span class="c1">// textlint plugin interface</span>
    <span class="nx">TextlintPluginCreator</span><span class="p">,</span>
    <span class="nx">TextlintPluginOptions</span><span class="p">,</span>
    <span class="nx">TextlintPluginProcessor</span><span class="p">,</span>
    <span class="nx">TextlintPluginProcessorConstructor</span>
<span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;@textlint/kernel&quot;</span><span class="p">;</span>
</code></pre></div>
<p>また、まだちょっとPublic APIの型定義が曖昧になっている(大抵はJSDocが正しい)ので、以下のIssueでPublic APIに対するテストの変換を行っています。
本体のソースコードはTypeScript化されていますが、テストコードはまだJavaScriptのままであるため、そこを徐々に変換していく予定です。(この変換する際に型がおかしいなら一緒に直す必要がある)</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/369" title="Convert tests to TypeScript https://github.com/textlint/textlint/issues/369">Convert tests to TypeScript #369</a></li>
</ul>

<p>Reactのインフラ整備でもPublic APIに対するテスト重要性が語られていますが、まさにこういう移行時にはPublic APIへのテストを良くしていくと安定性が向上する感じです。</p>

<p><a href="https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html" title="Behind the Scenes: Improving the Repository Infrastructure - React Blog">Behind the Scenes: Improving the Repository Infrastructure - React Blog</a></p>

<p>一緒に手伝ってくれる人は、いつでも募集しているのでTypeScript周りを改善したい人は上のIssueを見てみてください。(個人的には<a href="https://github.com/textlint/textlint/tree/master/packages/%40textlint/kernel" title="@textlint/kernel">@textlint/kernel</a>のPublic APIのテストがまだ足りていない印象です)</p>

<h2 id="🔥-breaking-change">🔥 Breaking Change</h2>

<p>10.0.0なのでいくつか破壊的な変更がありますが、textlintをCLIとして使う一般的なユーザーには殆ど影響はほぼありません。
主にtextlintを<code>require(&quot;textlint&quot;)</code>のようにモジュールとして使っている人は影響があるかもれません。</p>

<h3 id="textlint-export-as-es-module-337-344">textlint: Export as ES module <a href="https://github.com/textlint/textlint/issues/337">#337</a> <a href="https://github.com/textlint/textlint/issues/344">#344</a></h3>

<p>CommonJSとして出力していたものが、ES Modulesとして出力するように変更されました。</p>

<h4 id="before">Before</h4>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">textlint</span><span class="p">,</span>
  <span class="nx">TextLintEngine</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="after">After</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="p">{</span> 
  <span class="nx">textlint</span><span class="p">,</span>
  <span class="nx">TextLintEngine</span>
<span class="p">}</span>
</code></pre></div>
<p>これによってimportの仕方によっては影響があるかもしれません。
以前からnamed importしていた人には影響がないと思います。</p>

<p>次のような形で利用できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">textlint</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;textlint&quot;</span>
</code></pre></div>
<p>or </p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">textlint</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;textlint&quot;</span><span class="p">).</span><span class="nx">textlint</span>
</code></pre></div>
<h3 id="stop-to-export-unused-name-344">Stop to export unused name <a href="https://github.com/textlint/textlint/issues/344">#344</a></h3>

<p>次の使われてない値をexportしないようにしました。</p>

<ul>
<li><code>TextLintNodeType</code></li>
<li><code>TextLintMessageSeverityLevel</code></li>
<li><code>TextLintMessageType</code>

<ul>
<li>Use <code>@textlint/ast-node-types</code> insteadof it</li>
</ul></li>
</ul>

<h2 id="📝-documentaion">📝 Documentaion</h2>

<h3 id="improve-contributing-guide">Improve <a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>.</h3>

<p>Issues/PR: <a href="https://github.com/textlint/textlint/issues/380">#380</a> <a href="https://github.com/textlint/textlint/issues/379">#379</a> <a href="https://github.com/textlint/textlint/issues/355">#355</a> <a href="https://github.com/textlint/textlint/issues/352">#352</a> <a href="https://github.com/textlint/textlint/issues/353">#353</a> <a href="https://github.com/textlint/textlint/issues/341">#341</a> by <a href="https://github.com/leko">@Leko</a> and <a href="https://github.com/0x6b">@0x6b</a></p>

<p><a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>が色々と改善されました。
textlintにコミットしてみたいという人は、ここを読むとどうやってテストするかや直す場所に見つけ方などが分かります。</p>

<p>次の記事などにも書いていますが、textlintのコントビュートは歓迎です。
1つのテストを追加/変換、typoの修正、ドキュメントの追加、機能の追加/修正など色々とできることはあります。</p>

<p>簡単で手が出しやすいIssueには<a href="https://github.com/textlint/textlint/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>good first issue</code></a>というラベルを付けているので、まずはそこから見てみると良いかもしれません。</p>

<ul>
<li><a href="http://efcl.info/2017/11/06/textlint-core-refactoring/">textlintのコアをTypeScriptで書き直した、textlintの今後について | Web Scratch</a></li>
<li><a href="https://gist.github.com/azu/2b482e8e2aa636970f5f6110f6488719">textlintの直し方</a></li>
</ul>

<h2 id="♻️-polish">♻️ Polish</h2>

<h3 id="monorepo-270">Monorepo <a href="https://github.com/textlint/textlint/issues/270">#270</a></h3>

<p><a href="https://github.com/leko">@Leko</a>さんによって、次のモジュールは<a href="https://github.com/textlint/textlint">textlint</a>のmonorepoに追加されました。</p>

<ul>
<li>textlint-formatter <a href="https://github.com/textlint/textlint/issues/359">#359</a></li>
<li>textlint-ast-test <a href="https://github.com/textlint/textlint/issues/357">#357</a></li>
<li>txt-ast-traverse <a href="https://github.com/textlint/textlint/issues/356">#356</a> </li>
<li>textlint-fixer-formatter <a href="https://github.com/textlint/textlint/issues/347">#347</a> </li>
</ul>

<p><code>textlint-plugin-html</code>をmonorepoに入れるべきかという議論があり、まだこれだけimportできていません。
主に自分がhtmlでチェックする対象を持っていないため、コアメンテナがいない状態でmonorepoに入れるのは良くないためです。
もし、textlintのHTMLプラグインに興味があり、もっと良くしていきたいという人は次のIssueに見てください。
コアにメンテをできる人がいるならばmonorepoに取り入れて改善するべきだと思います。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/pull/364" title="Import textlint-plugin-html to monorepo by Leko · Pull Request #364 · textlint/textlint">Import textlint-plugin-html to monorepo by Leko · Pull Request #364 · textlint/textlint</a></li>
</ul>

<h2 id="🎉-new-contributors">🎉 New Contributors</h2>

<ul>
<li><a href="https://github.com/leko">@Leko</a> – リファクタリングやバグ修正、monorepo化などを手伝ってくれました</li>
<li><a href="https://github.com/0x6b">@0x6b</a> - <a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>の改善などを手伝ってくれました</li>
</ul>

<p>何度も書いてますがコントビュートはいつでも歓迎です。</p>

<ul>
<li><a href="https://gist.github.com/azu/2b482e8e2aa636970f5f6110f6488719">textlintの直し方</a></li>
</ul>

<p>例えばルールを書くのもコントビュートの一種です。
textlintでは<a href="https://github.com/textlint-rule/organization" title="textlint-rule/organization">textlint-rule/organization</a>(ルール全般)や<a href="https://github.com/textlint-ja/textlint-ja" title="textlint-ja/textlint-ja">textlint-ja/textlint-ja</a>(日本語に特化したルール)を扱うOrganizationがあります。
人依存よりもメンテナンス性が上る可能性があるので、Organizationにルールを置きたい場合は何かしらの方法でmentionしてください。</p>

<ul>
<li>上記のリポジトリにIssueを立てるか</li>
<li>Gitterでmentionする <a href="https://gitter.im/textlint-ja/textlint-ja?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/textlint-ja/textlint-ja.svg" alt="Gitter"></a></li>
<li>Twitterで<a href="https://twitter.com/azu_re">@azu_re</a>や<code>#textlint</code>などに書き込む</li>
</ul>

<h2 id="その他">その他</h2>

<p>英語圏でも使われるようになってきたので、英語系のルールも増えてきています。</p>

<ul>
<li><a href="https://github.com/sapegin/textlint-rule-apostrophe">sapegin/textlint-rule-apostrophe: Textlint rule to check correct apostrophe usage</a></li>
<li><a href="https://github.com/sapegin/textlint-rule-title-case">sapegin/textlint-rule-title-case: Textlint rule to ensure that titles are using AP/APA style</a></li>
<li><a href="https://github.com/sapegin/textlint-rule-diacritics" title="sapegin/textlint-rule-diacritics: Textlint rule to check correct usage of diacritics">sapegin/textlint-rule-diacritics: Textlint rule to check correct usage of diacritics</a></li>
</ul>

<p>またtextlintのラッパーで設定なしで<a href="https://github.com/andrepolischuk/docslint" title="docslint">docslint</a>というツールも登場しました。
ESLintのXOやstandardに近いかな?</p>

<h2 id="⏭️-next">⏭️ Next</h2>

<p>ロジックを扱う<a href="https://github.com/textlint/textlint/tree/master/packages/%40textlint/kernel" title="@textlint/kernel">@textlint/kernel</a>や<a href="https://github.com/textlint/textlint/tree/master/packages/textlint" title="textlint">textlint</a>などがTypeScript化できたことでモジュールとして扱いやすくなる基盤ができてきていると思います。</p>

<p>そのため、次にやるのはtextlintのもう一つの本体であるルールの改善をやっていきます。
最近、Google Developer Documentation Style Guideのtextlintルールである<a href="https://github.com/textlint-rule/textlint-rule-preset-google" title="textlint-rule-preset-google">textlint-rule-preset-google</a>を作っていますが、文章を真面目に扱うと&quot;センテンス&quot;や&quot;セクション&quot;といった構造的な文脈を扱うのは避けられません。</p>

<p>次のキャピタライズを扱うルールは、ちゃんとセンテンスを扱えないことからくるバグがあります。</p>

<ul>
<li><a href="https://github.com/textlint-rule/textlint-rule-en-capitalization/issues/2" title="Complains about file names in text · Issue #2 · textlint-rule/textlint-rule-en-capitalization">Complains about file names in text · Issue #2 · textlint-rule/textlint-rule-en-capitalization</a></li>
</ul>

<p><code>textlint</code>のASTである<a href="https://github.com/textlint/textlint/blob/master/docs/txtnode.md" title="TxtAST">TxtAST</a>では<code>Paragraph</code>や<code>Link</code>と行ったNodeはありますが、意味論的な<code>Sentence</code>や<code>Section</code>といった概念はありません。
これらは言語によって扱いが異なり、言語に依存するものごとはtextlintのコアには含めることができないためです。(HTMLの<code>&lt;section&gt;</code>要素のようなものはマークアップにアレばいいけどそれがない場合は言語やコンテキストで推測するしかない)</p>

<p>この辺は<a href="http://redpen.cc/" title="RedPen">RedPen</a>だと<code>Section</code>という概念を持っていたりするように、なんとなくのルールは大体あるような気がしています。</p>

<ul>
<li><a href="http://redpen.cc/docs/latest/index.html#model-structure" title="RedPen 1.10 Documentation">RedPen 1.10 Documentation</a></li>
</ul>

<p>この辺のギャップからくるルールの書きにくさを解消するため、コアが持つUtilityライブラリを整備していく予定です。適当に文字列に変換してから&quot;Sentence&quot;などいった塊を作るとASTに比べて情報が欠落してしまって問題があるという経験則があるため、ASTレベルのUtilを拡充していく形です。</p>

<p>主に<code>Section</code>、<code>Sentence</code>、CSTをどうにかしていきたいです。</p>

<ul>
<li>⬆️  <code>Section</code> node は <code>Paragraph</code> nodes の集合から作る

<ul>
<li>Related: <a href="https://github.com/azu/text-testing/tree/master/packages/select-section" title="select-section">select-section</a></li>
</ul></li>
<li>⬇️  <code>Sentence</code> nodes は <code>Paragraph</code> nodes から分解して作る

<ul>
<li>Related: <a href="https://github.com/azu/sentence-splitter" title="sentence-splitter">sentence-splitter</a></li>
</ul></li>
<li>↔️ <a href="https://github.com/syntax-tree/nlcst" title="NLCST">NLCST</a>のようにASTとCSTを相互にやり取りする仕組み

<ul>
<li>Related: <a href="https://github.com/wooorm/parse-english" title="parse-english">parse-english</a>, <a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-english" title="nlcst-parse-english">nlcst-parse-english</a> and <a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-japanese" title="nlcst-parse-japanese">nlcst-parse-japanese</a></li>
</ul></li>
</ul>

<p>次のIssueに詳細があるので興味がある人は見てください。
また、合わせてtextlintルールのテストライブラリである<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-tester" title="textlint-tester">textlint-tester</a>も改善していきたいと思います。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/366">Core rule utility · Issue #366 · textlint/textlint</a></li>
<li><a href="https://github.com/textlint/textlint/issues/396">textlint-tester: to TypeScript · Issue #396 · textlint/textlint</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>ページ上でずっと動いているsetTimeout、setInterval、requestAnimationFrameを見つけてパフォーマンス改善する</title>
   <link href="http://efcl.info/2017/12/07/capture-living-timer/"/>
   <updated>2017-12-07T10:25:00+09:00</updated>
   <id>http://efcl.info/2017/12/07/capture-living-timer</id>
   <content type="html"><![CDATA[ <p>複雑なウェブアプリケーションになってくると、1つのページで複数のTimerなどを回すことがあります。</p>

<p>例えば、Twitterのようなアプリならば、ポーリングで更新するために<code>setInverval</code>のようなタイマーを回します。
また、ゲームなどCanvasで描画を行うアプリケーションならば、メインループを<code>requestAnimationFrame</code>で回します。</p>

<p>このように色々なタイマー系がありますが、アプリが多機能になっていくと色々なタイマーが同時に動くようになっていきます。
特に問題がなりやすいのが表示中だけタイマーを回すコンポーネントです。</p>

<p>よくあるのが次のようなmount時にtimerを開始して、unmount時にtimerを停止するコンポーネントです。
この実装はunmount時に止めているので問題ありませんが、<code>componentWillUnmount</code>の実装を忘れるとそのタイマーはコンポーネントが消えた後も回り続けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">TimerComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>

    <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">startTimer</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stopTimer</span><span class="p">();</span> <span class="c1">// &lt;= これを止め忘れるとTimerリーク</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このような意図しないで動いてるタイマーなどを見つけるspyスクリプトを書きました</p>

<ul>
<li><a href="https://gist.github.com/azu/d7942102dc5282b0eca859149791c3f0" title="Logging Timer and requestAnimationFrame">Logging Timer and requestAnimationFrame</a></li>
</ul>

<h2 id="使い方">使い方</h2>

<ol>
<li>次のスクリプトをページに読み込ませる<br>

<ul>
<li>コンソールにコピペして実行しても大丈夫</li>
<li>Non strict modeじゃないと動かないことやってるで混ぜる場合は注意</li>
</ul></li>
<li>結果を取りたくなったら <code>window.getContexualLogResult()</code>を叩く</li>
</ol>

<p>&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;の実行元の関数毎に呼ばれた回数をまとめて表示してくれます。
またスタックトレースも無理やり入れているので、意図しない呼び出しが頻発しているならその部分のコードを直す目安となります。</p>

<script src="https://gist.github.com/azu/d7942102dc5282b0eca859149791c3f0.js"></script>

<p>例えば、twtter.comでこれを実行してみると<code>setInterval</code>と<code>requestAnimationFrame</code>が回っていることが分かります。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/12/07-1512611803.png" alt="image"></p>

<p>これは定期的な更新をするために呼び出していることがわかります。</p>

<p>タイムラインツールでも記録はできるのですが、呼び出し元毎のグルーピングやフィルタリングが難しいです。(良い方法があるなら知りたい)
&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;を乗っ取ってログを取ることで実装しています。</p>

<p>一回のタイマー発火ごとの処理は小さくても、スペック弱いデバイスではネックとなることがあるのでそのような無駄な処理を発見する目的で作りました。
(Chromeの<a href="https://umaar.com/dev-tips/88-cpu-throttling/" title="CPU Throttling - Chrome DevTools - Dev Tips">CPU Throttling</a>などでシミュレートすると問題を見つけやすいです)</p>

<p>最近は、分かりやすい指標が既にある起動時間のパフォーマンスではなく、アプリを起動後のパフォーマンスを改善しています。</p>

<p>次の記事で作ってたものはそういうところを改善する目安を探すためのツールです。</p>

<ul>
<li><a href="http://efcl.info/2017/11/15/performance.mark-metadata/" title="performance.markにメタデータを紐付けできるライブラリを書いた | Web Scratch">performance.markにメタデータを紐付けできるライブラリを書いた | Web Scratch</a></li>
<li><a href="https://dev.to/azu/performancemark-with-medata-is-useful-for-real-user-monitoring-54p" title="`performance.mark` with metadata is useful for Real user monitoring"><code>performance.mark</code> with metadata is useful for Real user monitoring</a></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これのFB Flux版を実装してたけど、やっぱりこういうの必要だと思う。ボトルネックが可視化されるので特殊な技能がなくてもパフォーマンス悪いところが発見できる。 &quot;Almin + React/Vue.jsのパフォーマンスプロフ…&quot; <a href="https://t.co/9alBY5tnca">https://t.co/9alBY5tnca</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/933888717101588480?ref_src=twsrc%5Etfw">November 24, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アプリの起動後の指標として、何かした時に反応が100ms以内、アニメーションが10ms以内、アイドル時の処理は50ms以上以内のブロックにする(long task)、Loadは1000ms以内などを指標を定めた<a href="https://developers.google.com/web/fundamentals/performance/rail?hl=ja" title="RAIL">RAIL</a>モデルなどがあります。</p>

<p>これらはマイクロなベンチマークを取ってからそれを改善していくという積み重ねをしています。
この記事で書いたspyスクリプトも、無駄に動くタイマーが減ればその分処理が減ったということが明確であるため、それを検出するために作りました。</p>

<p>また、アプリ起動後は何もしてないときも体感が良いということも必要になります。
例えばユーザー操作がないけど、タイムラインがスムーズに更新される、映像がスムーズに流れる、放置ゲームを眺めててつっかかりがないとか、リアルタイムにデータを受信してて止まらないなどがこれにあたります。</p>

<p>これらの放置時の更新は大体裏では&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;などを使っていることが多いです。
(WebRTCやWebSocketなどもありますが、それらが止まってないかを定期的にチェックする仕組みなどにも関係します)</p>

<p>タイマー系は意図しないタイミングで他の処理と重なるとUIを固めたりするので、<a href="https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback" title="requestIdleCallback">requestIdleCallback</a>と組み合わせるなどの工夫が必要になるかもしれません。</p>

<ul>
<li><a href="https://github.com/azu/faao/blob/f52920656db792a0e24fc8bcbbc555c33b02b623/src/infra/time-sheduler/TimeScheduler.ts">https://github.com/azu/faao/blob/f52920656db792a0e24fc8bcbbc555c33b02b623/src/infra/time-sheduler/TimeScheduler.ts</a></li>
</ul>

<p>その他</p>

<ul>
<li><a href="https://havelog.ayumusato.com/develop/javascript/e725-timer_vs_raf.html" title="requestAnimationFrame とタイマーの今更な比較とデモ ::ハブろぐ">requestAnimationFrame とタイマーの今更な比較とデモ ::ハブろぐ</a></li>
</ul>
 ]]></content>
 </entry>
 

</feed>
