<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Web Scratch</title>
 <link href="http://efcl.info/feed/" rel="self"/>
 <link href="http://efcl.info"/>
 <updated>2017-12-07T12:34:54+09:00</updated>
 <id>http://efcl.info/</id>
 
 <author>
   <name>azu</name>
   
 </author>
 

 
 <entry>
   <title>ページ上でずっと動いているsetTimeout、setInterval、requestAnimationFrameを見つけてパフォーマンス改善する</title>
   <link href="http://efcl.info/2017/12/07/capture-living-timer/"/>
   <updated>2017-12-07T10:25:00+09:00</updated>
   <id>http://efcl.info/2017/12/07/capture-living-timer</id>
   <content type="html"><![CDATA[ <p>複雑なウェブアプリケーションになってくると、1つのページで複数のTimerなどを回すことがあります。</p>

<p>例えば、Twitterのようなアプリならば、ポーリングで更新するために<code>setInverval</code>のようなタイマーを回します。
また、ゲームなどCanvasで描画を行うアプリケーションならば、メインループを<code>requestAnimationFrame</code>で回します。</p>

<p>このように色々なタイマー系が一つのアプリで動くことが多いですが、特に問題がなりやすいのが表示中だけタイマーを回すようなコンポーネントがあるケースです。</p>

<p>よくあるのが次のようなmount時にtimerを開始して、unmount時にtimerを停止するコンポーネントです。この実装はunmount時に止めているので問題ありませんが、<code>componentWillUnmount</code>の実装を忘れるとそのタイマーはコンポーネントが消えた後も周り続けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">TimerComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>

    <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">startTimer</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">stopTimer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このような意図しないで動いてるタイマーなどを見つけるspyスクリプトを書きました</p>

<ul>
<li><a href="https://gist.github.com/azu/d7942102dc5282b0eca859149791c3f0" title="Logging Timer and requestAnimationFrame">Logging Timer and requestAnimationFrame</a></li>
</ul>

<h2 id="使い方">使い方</h2>

<ol>
<li>次のスクリプトをページに読み込ませる<br>

<ul>
<li>コンソールにコピペして実行しても大丈夫</li>
<li>Non strict modeじゃないと動かないことやってるで混ぜる場合は注意</li>
</ul></li>
<li>結果を取りたくなったら <code>window.getContexualLogResult()</code>を叩く</li>
</ol>

<p>&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;の実行元の関数毎に呼ばれた回数をまとめて表示してくれます。
またスタックトレースも無理やり入れているので、意図しない呼び出しが頻発しているならその部分のコードを直す目安となります。</p>

<script src="https://gist.github.com/azu/d7942102dc5282b0eca859149791c3f0.js"></script>

<p>例えば、twtter.comでこれを実行してみると<code>setInterval</code>と<code>requestAnimationFrame</code>が回っていることが分かります。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/12/07-1512611803.png" alt="image"></p>

<p>これは定期的な更新をするために呼び出していることがわかります。</p>

<p>タイムラインツールでも記録はできるのですが、呼び出し元毎のグルーピングやフィルタリングが難しいです。(良い方法があるなら知りたい)
&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;を乗っ取ってログを取ることで実装しています。</p>

<p>一回のタイマー発火ごとの処理は小さくても、スペック弱いデバイスではネックとなることがあるのでそのような無駄な処理を発見する目的で作りました。
(Chromeの<a href="https://umaar.com/dev-tips/88-cpu-throttling/" title="CPU Throttling - Chrome DevTools - Dev Tips">CPU Throttling</a>などでシミュレートすると問題を見つけやすいです)</p>

<p>最近は、分かりやすい指標が既にある起動時間のパフォーマンスではなく、アプリを起動後のパフォーマンスを改善しています。</p>

<p>次の記事で作ってたものはそういうところを改善する目安を探すためのツールです。</p>

<ul>
<li><a href="http://efcl.info/2017/11/15/performance.mark-metadata/" title="performance.markにメタデータを紐付けできるライブラリを書いた | Web Scratch">performance.markにメタデータを紐付けできるライブラリを書いた | Web Scratch</a></li>
<li><a href="https://dev.to/azu/performancemark-with-medata-is-useful-for-real-user-monitoring-54p" title="`performance.mark` with metadata is useful for Real user monitoring"><code>performance.mark</code> with metadata is useful for Real user monitoring</a></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これのFB Flux版を実装してたけど、やっぱりこういうの必要だと思う。ボトルネックが可視化されるので特殊な技能がなくてもパフォーマンス悪いところが発見できる。 &quot;Almin + React/Vue.jsのパフォーマンスプロフ…&quot; <a href="https://t.co/9alBY5tnca">https://t.co/9alBY5tnca</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/933888717101588480?ref_src=twsrc%5Etfw">November 24, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アプリの起動後の指標として、何かした時に反応が100ms以内、アニメーションが10ms以内、アイドル時の処理は50ms以上以内のブロックにする(long task)、Loadは1000ms以内などを指標を定めた<a href="https://developers.google.com/web/fundamentals/performance/rail?hl=ja" title="RAIL">RAIL</a>モデルなどがあります。</p>

<p>これらはマイクロなベンチマークを取ってからそれを改善していくという積み重ねをしています。
この記事で書いたspyスクリプトも、無駄に動くタイマーが減ればその分処理が減ったということが明確であるため、それを検出するために作りました。</p>

<p>また、アプリ起動後は何もしてないときも体感が良いということも必要になります。
例えばユーザー操作がないけど、タイムラインがスムーズに更新される、映像がスムーズに流れる、放置ゲームを眺めててつっかかりがないとか、リアルタイムにデータを受信してて止まらないなどがこれにあたります。</p>

<p>これらの放置時の更新は大体裏では&quot;setTimeout&quot;, &quot;setInterval&quot;, &quot;requestAnimationFrame&quot;などを使っていることが多いです。
(WebRTCやWebSocketなどもありますが、それらが止まってないかを定期的にチェックする仕組みなどにも関係します)</p>

<p>タイマー系は意図しないタイミングで他の処理と重なるとUIを固めたりするので、<a href="https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback" title="requestIdleCallback">requestIdleCallback</a>と組み合わせるなどの工夫がひつようになるかもしれません。</p>

<ul>
<li><a href="https://github.com/azu/faao/blob/f52920656db792a0e24fc8bcbbc555c33b02b623/src/infra/time-sheduler/TimeScheduler.ts">https://github.com/azu/faao/blob/f52920656db792a0e24fc8bcbbc555c33b02b623/src/infra/time-sheduler/TimeScheduler.ts</a></li>
</ul>

<p>その他</p>

<ul>
<li><a href="https://havelog.ayumusato.com/develop/javascript/e725-timer_vs_raf.html" title="requestAnimationFrame とタイマーの今更な比較とデモ ::ハブろぐ">requestAnimationFrame とタイマーの今更な比較とデモ ::ハブろぐ</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>shallow-equal for Object/React props</title>
   <link href="http://efcl.info/2017/11/30/shallow-equal/"/>
   <updated>2017-11-30T10:12:00+09:00</updated>
   <id>http://efcl.info/2017/11/30/shallow-equal</id>
   <content type="html"><![CDATA[ <p>オブジェクトとReactのProps向けのShallow(浅い) equalライブラリを書きました。
Shallow Equalは対象のオブジェクトのプロパティをそれぞれ1段だけ比較することを言います。
ものすごく単純に書くならば次のようなことをするライブラリです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">targetObject</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kr">const</span> <span class="nx">isEqualed</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">object</span><span class="p">).</span><span class="nx">some</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">targetObject</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a></li>
<li><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a></li>
</ul>

<p>どちらもTypeScriptに対応していて、シンプルにオブジェクト同士を比較してbooleanを返すだけのライブラリです。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="p">{</span> <span class="nx">shallowEqual</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;shallow-equal-object&quot;</span><span class="p">);</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// =&gt; true</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">42</span> <span class="p">});</span> <span class="c1">// =&gt; false</span>
<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="p">});</span> <span class="c1">// =&gt; false</span>
</code></pre></div>
<p><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>は、値の比較関数をカスタマイズできます。
デフォルトの比較関数は<code>Object.is</code>メソッド相当の実装がつかわれています。
これは、Reactの<code>PureComponent</code>やECMAScriptのProposalとして提出されていた(現在は取り下げ)<a href="https://github.com/sebmarkbage/ecmascript-shallow-equal" title="ecmascript-shallow-equal">ecmascript-shallow-equal</a>と同じ比較となります。</p>

<p><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>は、この値の比較関数をReactのProps向けにしただけのバージョンです。
具体的には、<code>React.Element</code>同士の比較を考慮したバージョンなので、<code>props</code>(<code>children</code>も含む)に<code>React.Element</code>を使っていないなら大した違いはありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">customEqual</span><span class="o">:</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">typeof</span> <span class="nx">a</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">b</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span> <span class="c1">// =&gt; false</span>
</code></pre></div>
<p>どちらもデバッグモードに対応しています。
実際にshallowEqualしたことがある人はわかると思いますが、なぜそれが<code>false</code>になるのかは結構分かりにくいことが多いです。どのプロパティが異なるから<code>false</code>になったということをデバッグ時に知りたいがことが多々あります。</p>

<p>どちらのライブラリも <code>{ debug: true }</code> をオプションに渡すことでコンソールに、比較結果が<code>false</code>となった理由とオブジェクトを表示してくれます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">shallowEqual</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;objectA is not object.&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({},</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;objectB is not object.&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;object key length is not same&quot;</span>

<span class="nx">shallowEqual</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span>
    <span class="nx">debug</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="c1">// &quot;key:a is not equals between A and B.&quot;</span>
</code></pre></div>
<p>このShallow Equalがどのようなときに役立つかというと大きなオブジェクトの塊を比較するときに、オブジェクトの作り方次第では比較コストが大きく変わります。</p>

<p>ReactやReduxなどでよく言われる状態のオブジェクトのをImmutableにするのはこれに関連しています。</p>

<ul>
<li><a href="http://nekogata.hatenablog.com/entry/2013/06/15/013752" title="「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く">「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く</a></li>
</ul>

<p>実際にReactの例を見てみます。
次のサンプルは、恣意的な<code>JSON.stringify</code>でのDeepな比較の問題点を見るために作ったものです。
そのためDeepEqualが悪いという話ではありません。</p>

<h2 id="deep-equal-json-stringify-とshallow-equal">Deep Equal(<code>JSON.stringify</code>)とShallow Equal</h2>

<p>サンプルコードは次のリポジトリにあります。</p>

<ul>
<li><a href="https://github.com/azu/avoid-json-stringify-on-react" title="azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&amp;#39;s shouldComponentUpdate">azu/avoid-json-stringify-on-react: Deep equal vs. Shallow equal on React&#39;s shouldComponentUpdate</a></li>
</ul>

<p>このサンプルではDeep Equalの実装例として<code>JSON.stringify</code>した結果同士を比較するものを利用しています。最近、Reactのドキュメントにおいて<code>shouldComponentUpdate</code>の実装で<code>JSON.stringify</code>を使うべきではないということが追加されています。
これを検証する目的で作ったサンプルコードです。</p>

<blockquote>
<p>We do not recommend doing deep equality checks or using JSON.stringify() in shouldComponentUpdate(). It is very inefficient and will harm performance.
<a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">https://reactjs.org/docs/react-component.html#shouldcomponentupdate</a></p>
</blockquote>

<p><strong>関連するIssue</strong></p>

<ul>
<li><a href="https://github.com/erikras/redux-form/issues/3461">Performance issue (crash) in large apps when using Field with children in React v16 · Issue #3461 · erikras/redux-form</a></li>
<li><a href="https://github.com/reactjs/reactjs.org/issues/7">Document that deep equality checks and JSON.stringify() in shouldComponentUpdate() are a bad idea · Issue #7 · reactjs/reactjs.org</a></li>
</ul>

<p>このサンプルでは、すべてのコンポーネントは<code>BaseComponent</code>を継承しています。
<code>BaseComponent</code>はDeep Equal(<code>JSON.stringify</code>)とShallow Equalが切り替えできるようになっています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">shallowEqual</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;shallow-equal-object&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isDeepEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prevState</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">nextState</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">prevState</span><span class="p">)</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">nextState</span><span class="p">);</span>
<span class="p">};</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isShallowEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prevState</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">nextState</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">prevState</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">);</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isShallowEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>アプリの構造はシンプルで<code>&lt;A/&gt;</code>というネストが深い用途、でっかいリストを描画する<code>&lt;List /&gt;</code>があります。<code>&lt;button /&gt;</code>を押すたびに、<code>state.a</code>の中にある<code>count</code>が+1ずつ更新されるだけです。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/11/30-1512048718.png" alt="image"></p>

<p>ここで<code>&lt;List /&gt;</code>に渡す<code>state.largeList</code>は初回時に固定の10000コの値をもつ配列となります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">frozenLargeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
</code></pre></div>
<p>ボタン押しても<code>List</code>のpropsである<code>state.largeList</code>は変更されないので、<code>&lt;List/&gt;</code>は一度描画されたら更新する必要がありません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&quot;App&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">A</span> <span class="p">{...</span><span class="nx">state</span><span class="p">.</span><span class="nx">a</span><span class="p">}</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">}</span><span class="o">&gt;+</span><span class="mi">1</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
    <span class="o">&lt;</span><span class="nx">hr</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">List</span> <span class="nx">items</span><span class="o">=</span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">largeList</span><span class="p">}</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="err">/div&gt;</span>
</code></pre></div>
<p>この渡されたpropsが同じ値であるなら、更新しないというのをReactでは<code>BaseComponent</code>ででてきた<code>shouldComponentUpdate</code>メソッドの実装で解決できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>デフォルトの<code>shouldComponentUpdate</code>は常に<code>true</code>を返すので、常に新しい値が来たら更新することになります。
これを防止する方法として<code>this.props</code>(今のprops)と次にくる<code>nextProps</code>を比較して、同じなら<code>false</code>を返せば更新されないという寸法です。</p>

<p>今回はこの実装をDeep Equal(<code>JSON.stringify</code>)とShallow Equal(<a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>)で比較しています。(<code>React.PureComponent</code>はShallow Equalと同じ実装になります)</p>

<p><code>&lt;A /&gt;</code>は毎回新しいPropsを受け取るので更新されますが、<code>&lt;List items={state.largeList}/&gt;</code>は同じpropsを毎回受け取るので更新する必要がありません。</p>

<p>どちらもDeepもShallow(<code>state.largeList</code>の参照先は毎回同じ)も比較結果は<code>true</code>となり、つまりそれを反転して返せば更新されません。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="o">:</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isShallowEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p>この例ではわざわざ<a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>を使ってますが、Reactには<code>React.PureComponent</code>があるので、そちらを使えば実装は特にいらないです。
(<a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>は<a href="https://github.com/facebook/react/issues/8669">React.PureComponentとはChildrenとかのReact.Elementの扱い</a>が違いますが、大抵は<code>React.PureComponent</code>で十分です。この例ではこの違いは特に関係ないので省きます。)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">BaseComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PureComponent</span><span class="o">&lt;</span><span class="nx">P</span><span class="p">,</span> <span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p>ここで本題のDeep Equal(<code>JSON.stringify</code>)とShallow Equalの比較のコストの差の話がでてきます。このコストの差は<code>shouldComponentUpdate</code>の処理自体にどれぐらいかかっているかを調べれば比較できます。</p>

<p>React 15まではreact-addon-perfsで比較できましたが、React 16では<code>?react_perf</code>の<code>performance.mark</code>の結果を使うのが簡単です。</p>

<p>実行前に<code>PerformanceObserver</code>でReactが<code>performance.measure</code>した結果をコンソールログに出すように仕込んでおきます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="nb">window</span> <span class="nx">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">PerformanceObserver</span><span class="p">((</span><span class="nx">list</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">components</span><span class="o">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">totalDuration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">getEntries</span><span class="p">().</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">entry</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Display each reported measurement on console</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;shouldComponentUpdate&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
            <span class="nx">totalDuration</span> <span class="o">+=</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">duration</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Name: &quot;</span> <span class="o">+</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span>
                <span class="s2">&quot;, Duration: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">duration</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;\n&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Total</span> <span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">totalDuration</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Updated</span> <span class="nx">components</span><span class="o">:</span><span class="err">`</span><span class="p">,</span> <span class="nx">components</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">});</span>
<span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">({</span> <span class="nx">entryTypes</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;measure&#39;</span><span class="p">]</span> <span class="p">});</span>
</code></pre></div>
<p>このログには、それぞれのコンポーネントの<code>shouldComponentUpdate</code>の時間が出力されます。</p>

<p>次の環境で3回更新を更新を起こした時の<code>shouldComponentUpdate</code>の時間を計測しました。</p>

<ul>
<li>MacBookPro14,1</li>
<li>CPU: Intel Core i7, 2.5 GHz</li>
<li>Browser: Chrome – 6x CPU throttling</li>
</ul>

<h3 id="deep-equal-json-stringify-の結果">Deep Equal(<code>JSON.stringify</code>)の結果</h3>

<p>Deep Equal (<code>JSON.stringify(prevProps) === JSON.stringify(nextProps)</code>):</p>

<p><img src="https://user-images.githubusercontent.com/19714/33408570-7e4ff248-d5ba-11e7-8470-684413a8fb25.png" alt="image"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Name: ⚛ A.shouldComponentUpdate, Duration: 0.9350000000004002

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 1.1300000000001091

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.364999999999782

App.tsx:32 Total shouldComponentUpdate: 7.4650000000001455
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.014999999999417923

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.019999999999527063

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.770000000000437

App.tsx:32 Total shouldComponentUpdate: 5.81499999999869
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate


App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000001018634

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 5.154999999999745

App.tsx:32 Total shouldComponentUpdate: 5.190000000001419
App.tsx:33 Update components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate
</code></pre></div>
<h3 id="shallow-equal">Shallow Equal</h3>

<p>Shallow Equal(Use <a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a>)</p>

<p><img src="https://user-images.githubusercontent.com/19714/33408628-d3677756-d5ba-11e7-83a3-5113a2e09739.png" alt="image"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Name: ⚛ A.shouldComponentUpdate, Duration: 0.13999999999941792

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.010000000001127773

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.015000000000327418

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 1.125

App.tsx:32 Total shouldComponentUpdate: 1.305000000000291
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 0.009999999999308784

App.tsx:32 Total shouldComponentUpdate: 0.03999999999814463
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate

App.tsx:27 Name: ⚛ A.shouldComponentUpdate, Duration: 0.010000000000218279

App.tsx:27 Name: ⚛ B.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ C.shouldComponentUpdate, Duration: 0

App.tsx:27 Name: ⚛ D.shouldComponentUpdate, Duration: 0.004999999999199645

App.tsx:27 Name: ⚛ E.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:27 Name: ⚛ List.shouldComponentUpdate, Duration: 0.005000000000109139

App.tsx:32 Total shouldComponentUpdate: 0.029999999998835847
App.tsx:33 Updated components: ⚛ A.shouldComponentUpdate, ⚛ B.shouldComponentUpdate, ⚛ C.shouldComponentUpdate, ⚛ D.shouldComponentUpdate, ⚛ E.shouldComponentUpdate, ⚛ List.shouldComponentUpdate
</code></pre></div>
<h2 id="結果">結果</h2>

<p>Deep Equalは合計で5ms程度かかるのに対して、Shallow Equalは0.02ms程度で済んでいます。
200倍程度の違いがでていますが、これは複雑で巨大なpropsになるほどDeep Equalは不利になります。
(<code>JSON.stringify</code>の結果をキャッシュすれば時間は半分程度になります)</p>

<p>この例は恣意的な比較なので、十分に早いデバイスでそこまで大きくないオブジェクトなら目に見えるコストにはなりにくいです。</p>

<p><code>shouldComponentUpdate</code>はかなり高頻度で呼ばれる処理であるため、この比較処理自体が重いとコンポーネントを更新しなかったとしても重たいことになります。</p>

<p>また、<code>JSON.stringify</code>はReact.Elementなど正しくstringifyできないものが来た場合にも問題がでてくるため実際にはその判定も必要です。(propsにはReactElementが渡されることがある。Childrenとか普通に属性として)
<a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a>はReact Elementの比較も考慮したshallow equalの実装です。</p>

<p>BaseComponentなどでDeep Equalなどを使った<code>shouldComponentUpdate</code>は簡単でpropsが小さい間は効果的です。しかし、propsに巨大な配列などや循環参照しているもの、複雑なオブジェクトが入ってくると破綻しやすくなります。</p>

<p>Shallow Equalの場合はそのようなことはありませんが、参照する値の比較になるため状態をImmutableに作ったり、そのImmutableなツリーとして意識する必要がでてきます。</p>

<ul>
<li><a href="http://nekogata.hatenablog.com/entry/2013/06/15/013752" title="「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く">「オブジェクトをイミュータブルにしろ」って言うけど、それってたとえば状態が変わったらオブジェクト作り直すってことでしょ、ちょう非効率じゃん。って思ってたんだけど、 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く</a></li>
</ul>

<p>Mutableな方法でStateの更新処理を行う場合は、Shallow Equalでは更新したつもりが更新されていないと判定されてしまう場合があります。
よくあるのは配列の値を追加するときに<code>Array#push</code>で行った場合などです。</p>

<ul>
<li><a href="https://asciidwango.github.io/js-primer/basic/array/#mutable-immutable" title="配列 · JavaScriptの入門書 #jsprimer">配列 · JavaScriptの入門書 #jsprimer</a></li>
</ul>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">array</span><span class="o">:</span> <span class="p">[]</span>
<span class="p">};</span>
<span class="c1">// arrayの中身は更新されているけど、`state.array`の参照する配列オブジェクトは同じ</span>
<span class="c1">// Deep Equalでは異なるものとして判定できるけど、Shallow Equalでは同じオブジェクトとなる</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>これをImmutableな形で更新するには、<code>state.array</code>の参照する配列オブジェクトそのものを更新する必要があります。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">array</span><span class="o">:</span> <span class="p">[]</span>
<span class="p">};</span>
<span class="c1">// arrayの中身は更新し、かつ`state.array`の参照する配列オブジェクトも更新</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">array</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">array</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>このように、Shallow Equalが効果的に動くようにするためには、状態の管理の仕方も大事になってきます。</p>

<p>例えば、ステート管理ライブラリと言われてるものを見てみると、色々なパターンでこのShallow EqualができるようなStateを作りやすくなっています。</p>

<p><a href="https://redux.js.org/">Redux</a>のReducerで<code>state</code>を受け取り、その<code>state</code>が更新する必要ないなら、そのまま<code>state</code>を返すというパターンはImmutableな状態の実装パターンの一つです。</p>

<p><a href="https://github.com/mobxjs/mobx">MobX</a>の<a href="https://github.com/mobxjs/mobx-state-tree" title="mobx-state-tree">mobx-state-tree</a>は、mutableなmodelを持っておき、immutableなオブジェクトをスナップショットとして取得できます。</p>

<p><a href="https://almin.js.org/">Almin</a>のStoreでは、ReduxのようなパターンでImmutableなStateを更新したり、Repositoryに保存したドメインモデルから必要になったタイミングで新しいStateに変換して返すなどのパターンで実装します。</p>

<p>UIを持つ多くのアプリでは、状態を更新する回数よりも、状態を読み取りUIを作る回数の方が多くなりやすいです。そのため、更新のコストをちょっと払って(Immutableな更新)、状態からUIを更新するコストを小さくする(Shallow Equalにより判定処理自体を簡潔にする)ことがパフォーマンスにも効果がでます。また、更新範囲を抑えることが重要になるので、状態を作るときにある程度コントールしないと影響範囲を抑えるのは難しくなります。</p>

<h2 id="おわり">おわり</h2>

<p>世の中には既にいろんなShallow Equalのライブラリがあります。(大体実装は同じです)
今回はTypeScript対応がなかったのと、デバッグの仕組みを持っているものが見つからなかったのでライブラリを作りました。</p>

<ul>
<li><a href="https://github.com/azu/shallow-equal-object" title="shallow-equal-object">shallow-equal-object</a></li>
<li><a href="https://github.com/azu/shallow-equal-props" title="shallow-equal-props">shallow-equal-props</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>ローカルのPDFを全文検索するクライアント/サーバ/Electronアプリを書いた</title>
   <link href="http://efcl.info/2017/11/17/searchive/"/>
   <updated>2017-11-17T20:03:00+09:00</updated>
   <id>http://efcl.info/2017/11/17/searchive</id>
   <content type="html"><![CDATA[ <p>ローカルにあるPDFを全部検索して、その結果を一覧したいことがあります。
例えば、今、<a href="https://github.com/asciidwango/js-primer" title="js-primer">js-primer</a>という書籍を書いていて、ある用語が他の書籍ではどんな扱い/用語になっているのかを調べたいことがよくありました。</p>

<p>この手のアプリとしては論文管理の<a href="https://www.readcube.com/papers/mac/" title="Papers for Mac">Papers for Mac</a>などがありますが、検索したいだけなのに色々な機能がついていてまた、とりあえず作ってみることにしました。</p>

<p><a href="https://github.com/azu/searchive" title="searchive">searchive</a>というプロジェクト名にしてPDFからテキストを取り出す所やフロントエンドのElectronアプリ、PDFからテキストを取り出すのはブラウザでやるには遅いので、そこをサーバ側でやってくれる仕組みを作りました。</p>

<p>大体100冊ぐらいをインデックスに入れて検索していますが、数百ms以内に検索結果が出てるので意外と動くようです。</p>

<p><a href="http://www.giphy.com/gifs/3o6fIYo3aDtasisB2M"><img src="https://media.giphy.com/media/3o6fIYo3aDtasisB2M/giphy.gif" alt="App"></a></p>

<h2 id="インストール">インストール</h2>

<p><a href="https://github.com/azu/searchive/releases">Release page</a>からElectronアプリをダウンロードしてインストール出来ます。Electronアプリにはサーバの実装も入ってるので、アプリを入れるだけで動きます。</p>

<ul>
<li><a href="https://github.com/azu/searchive/releases/latest">Latest Release</a>からダウンロードしてインストール

<ul>
<li>署名してないので、右クリックの&quot;開く&quot;からじゃないと怒られる</li>
</ul></li>
</ul>

<p><a href="https://www.appveyor.com/" title="AppVeyor">AppVeyor</a>などのCIの設定が面倒だったので、Mac版のバイナリしか置いていませんが、<a href="https://github.com/azu/searchive/tree/master/packages/searchive-app" title="searchive-app">searchive-app</a>をビルドすればどのOSでも動くと思います。またはPR歓迎です。</p>

<h3 id="使い方">使い方</h3>

<p>起動したら最初にPDFのインデックスを作る必要があります。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/11/17-1510917382.png" alt="image"></p>

<p>メニューから設定を開くと、インデックスしたいファイルの場所を<a href="https://github.com/isaacs/node-glob" title="node-glob">glob</a>で指定できます。
保存するとPDFからテキストを取り出した<code>index.json</code>を作り出してくれます。(とても重いので放置しておくといいです)</p>

<p>ローディングバーが消えて終わったら後は検索するだけです。
検索結果をフィルターすることができるので、大雑把な検索をしてからフィルターする使い方を想定しています。(検索の単位はPDFのページ)</p>

<p><a href="http://www.giphy.com/gifs/3o6fIYo3aDtasisB2M"><img src="https://media.giphy.com/media/3o6fIYo3aDtasisB2M/giphy.gif" alt="App"></a></p>

<p>検索演算子はGitHubみたいなものが使えます。
ライブラリとしては<a href="https://github.com/azu/search-query-tester" title="search-query-tester">search-query-tester</a>を使っています。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/11/17-1510924048.png" alt="keyword operator"></p>

<h2 id="作り方">作り方</h2>

<p><a href="https://github.com/azu/searchive" title="searchive">searchive</a>はmonorepoのプロジェクトになっていて、細かい部品を独立したライブラリとして作っています。
それらを組み合わせて<a href="https://github.com/azu/searchive/tree/master/packages/searchive-app" title="searchive-app">searchive-app</a>というアプリが動いています。</p>

<p>それぞれの部品を順番に紹介していきます。</p>

<h3 id="pdf-to-json"><a href="https://github.com/azu/searchive/tree/master/packages/pdf-to-json"><code>pdf-to-json</code></a> <a href="https://www.npmjs.com/package/pdf-to-json"><img src="https://img.shields.io/npm/v/pdf-to-json.svg?style=flat-square" alt="npm"></a></h3>

<p><a href="https://github.com/mozilla/pdf.js" title="pdf.js">pdf.js</a>を使ってPDFからテキストを取り出してJSONにしてくれるライブラリです。ページごとのテキストをJSONにまとめてくれます。
実際にはpdf.jsのnpm版である<a href="https://github.com/mozilla/pdfjs-dist" title="pdfjs-dist">pdfjs-dist</a>を使います。</p>

<p>pdf.jsは使いにくいライブラリ(というアプリに近い)なので、日本語などもちゃんと扱えるようにするのは工夫が必要です。</p>

<ul>
<li><a href="http://efcl.info/2014/10/07/pdf-presentation/">pdf.jsを使いブラウザで見られるPDFスライド表示ツールを作った | Web Scratch</a></li>
<li><a href="http://efcl.info/2015/12/07/pdf.js-controller/" title="[pdf.js] テキスト選択出来るスライド表示ライブラリを書いた | Web Scratch">[pdf.js] テキスト選択出来るスライド表示ライブラリを書いた | Web Scratch</a></li>
</ul>

<p>cmapsというファイルをちゃんと読めないと日本語などが扱えません。
Node.jsで扱う公式のオプションはないので、テストコードを読んでURLをfsで代替するモック実装を使って読み込むことができました。</p>

<ul>
<li><a href="https://github.com/azu/searchive/blob/7ed276adfec3ec86ba421a9a2227e8333502e248/packages/pdf-to-json/src/pdf-to-json.ts#L15-L43">https://github.com/azu/searchive/blob/7ed276adfec3ec86ba421a9a2227e8333502e248/packages/pdf-to-json/src/pdf-to-json.ts#L15-L43</a></li>
</ul>

<h3 id="searchive-client"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-client"><code>searchive-client</code></a>  <a href="https://www.npmjs.com/package/searchive-client"><img src="https://img.shields.io/npm/v/searchive-client.svg?style=flat-square" alt="npm"></a></h3>

<p><a href="https://github.com/azu/searchive" title="searchive">searchive</a>の検索やインデックへの書き込みを扱う抽象レイヤーです。fsやブラウザAPIにも依存してないクリーンなJavaScriptとして動作する層です。</p>

<h3 id="searchive-create-index"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-create-index"><code>searchive-create-index</code></a>  <a href="https://www.npmjs.com/package/searchive-create-index"><img src="https://img.shields.io/npm/v/searchive-create-index.svg?style=flat-square" alt="npm"></a></h3>

<p><a href="https://github.com/azu/searchive/tree/master/packages/searchive-client"><code>searchive-client</code></a>と<a href="https://github.com/azu/searchive/tree/master/packages/pdf-to-json"><code>pdf-to-json</code></a>を使って、実際にインデックファイルを作るライブラリでうｓ。
ファイルを読み込んだり、書き込んだりするのでNode.jsに依存しています。</p>

<h3 id="searchive-cli"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-cli"><code>searchive-cli</code></a> <a href="https://www.npmjs.com/package/searchive-cli"><img src="https://img.shields.io/npm/v/searchive-cli.svg?style=flat-square" alt="npm"></a></h3>

<p>インデックを作ったり、実際に検索できるCLIです。
<a href="https://github.com/azu/searchive/tree/master/packages/searchive-client"><code>searchive-client</code></a>や<a href="https://github.com/azu/searchive/tree/master/packages/searchive-create-index"><code>searchive-create-index</code></a>が実装の殆どを持っているため数行ぐらいしかないCLIです。monorepoだとこういう切り離しがし易いのもメリットです。</p>

<p>テスト用に使ったりできます。</p>

<h3 id="searchive-server"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-server"><code>searchive-server</code></a> <a href="https://www.npmjs.com/package/searchive-server"><img src="https://img.shields.io/npm/v/searchive-server.svg?style=flat-square" alt="npm"></a></h3>

<p>Electronアプリはmain(Node.js)とrenderer(ブラウザ)のプロセスを両方持っていますが、こちらはNode.js側の実装です。
<a href="https://github.com/azu/searchive/tree/master/packages/searchive-create-index"><code>searchive-create-index</code></a>を使ってインデックス作るWeb APIや、インデックを検索して結果を返すWeb APIを実装しています。</p>

<p>REST APIの実装するサーバには<a href="https://github.com/restify/node-restify" title="restify">restify</a>を使っています。
また、インデックスを作る処理は時間がかかるためREST APIでは不向きでした。
そこでWeb Socketを使ったAPIを実装して、クライアント側とはWebSocketで進捗をやり取りしています。
サーバ側のWebSocketsは<a href="https://github.com/websockets/ws" title="ws">ws</a>を使い、クライアント側はブラウザネイティブの<code>WebSocket</code>を使っています。</p>

<h3 id="searchive-web-api-interface"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-web-api-interface"><code>searchive-web-api-interface</code></a> | <a href="https://www.npmjs.com/package/searchive-web-api-interface"><img src="https://img.shields.io/npm/v/searchive-web-api-interface.svg?style=flat-square" alt="npm"></a></h3>

<p>主にWebSocketが原因でできたパッケージです。
WebSocketはReduxとかのActionみたいなコマンドをやり取りする必要があります。
それらの定義はサーバとクライアントどちらも共有したいので、インターフェイスだけを定義したパッケージを定義してサーバとクライアントではこれを使っています。</p>

<p>サーバ側に定義してしまうと、クライアントがサーバに依存するという問題が起きてしまうための回避策です。</p>

<h3 id="searchive-app"><a href="https://github.com/azu/searchive/tree/master/packages/searchive-app" title="searchive-app"><code>searchive-app</code></a></h3>

<p>最後にElectronで書かれたアプリです。
Electronはmain(Node.js)とrenderer(ブラウザ)の両方を持っているので、mainで<a href="https://github.com/azu/searchive/tree/master/packages/searchive-server"><code>searchive-server</code></a>のサーバを動かして、rendererからAPIを叩いて使っています。</p>

<p>Electronのセットアップは毎回苦戦するので、今回はElectron版<code>create-react-app</code>のような<a href="https://github.com/electron-userland/electron-webpack/" title="electron-webpack">electron-webpack</a>を使っています。
これで<code>yarn run dev</code>するだけで開発が始めらます。mainのソースが変わった場合はアプリが起動し直され、rendererの場合はHot Reloadingができる構成なので、面倒なwebpackを触れなくてよくて便利です。</p>

<p><a href="http://typescriptlang.org/">TypeScript</a>の対応も<a href="https://webpack.electron.build/add-ons" title="Add-ons · electron-webpack">Add-ons · electron-webpack</a>を入れるだけで解決するので楽でした。</p>

<p>一方問題もあって、webpack-dev-serverを開発中は使って、buildした場合はhtmlになるので、<code>file:///</code>だと特権で動く処理がdevelopment中は動かないことがあります。(webviewの中でfileなコンテンツを表示するなどがhttpのページ上ではできない)</p>

<p>次の記事でも同様の構成について触れています。</p>

<ul>
<li><a href="https://qiita.com/azu/items/a149501ca1b5864000a3" title="React + TypeScript (+ Electron)でアプリを書き始めるときにやってること - Qiita">React + TypeScript (+ Electron)でアプリを書き始めるときにやってること - Qiita</a></li>
</ul>

<p>Viewには<a href="https://reactjs.org/">React</a>を使っていて、UIコンポーネントとしてMSの<a href="https://developer.microsoft.com/en-us/fabric" title="Office UI Fabric">Office UI Fabric</a>を使っています。<a href="https://developer.microsoft.com/en-us/fabric" title="Office UI Fabric">Office UI Fabric</a>はこういうアプリを作るときに便利なメニューやコンテキストメニュー、パネルなどがあるのでよく使ってます。</p>

<p>State管理には、<a href="https://github.com/almin/almin" title="almin">Almin</a>を使っています。
基本的にやりたいことは次のようなことだけでした。</p>

<ul>
<li>(APIを叩いて)検索</li>
<li>(WebSocketを繋いで)インデックスを更新</li>
<li>フィルターを更新</li>
<li>設定パネルを開く/閉じる</li>
</ul>

<p>Alminでは、やりたいこと(ユースケース)を1ファイル1ユースケースで書いていきます。</p>

<ul>
<li><a href="http://azu.github.io/slide/2017/almin/concept-of-almin.html" title="The Concept of Almin">The Concept of Almin</a></li>
</ul>

<p>なので、このアプリでは次のようなユースケースを書きました。</p>

<p><img src="http://efcl.info/wp-content/uploads/2017/11/17-1510927384.png" alt="usecase図"></p>

<blockquote>
<p><a href="https://github.com/almin/almin-usecase-map-generator">https://github.com/almin/almin-usecase-map-generator</a>でユースケース図を生成</p>
</blockquote>

<p>このアプリではドメインとかそこまでちゃんとやっても旨味がない気がしたので、UseCaseでイベントをdispatchして、Storeでイベントを受け取ってStateを更新する感じにしました。
Reduxでよく見るような形になってると思います。</p>

<p><a href="https://github.com/azu/searchive/blob/master/packages/searchive-app/src/renderer/store/SearchIndexStore/SearchIndexStore.ts"><img src="http://efcl.info/wp-content/uploads/2017/11/17-1510923816.png" alt="Store"></a></p>

<p>後は、<a href="https://github.com/almin/almin/tree/master/packages/almin-react-container" title="almin-react-container">almin-react-container</a>を使えば、AlminのStoreとReactのViewが自動で繋がるので、Stateが更新されたViewを更新するだけです。</p>

<h4 id="todo">TODO</h4>

<ul>
<li>Electronのmainプロセスで重たい処理をすると、UIも固まるのでどうにかしたい

<ul>
<li>インデックスを作る処理が重たい</li>
</ul></li>
<li><a href="https://github.com/electron-userland/electron-webpack/" title="electron-webpack">electron-webpack</a>がdev serverを立てる制限で検索結果に実際にpdfを表示するプレビューがでてきてないのでどうにかしたい</li>
<li>PDF以外も原理的に対応できるのでテキストファイルも合わせて検索したい</li>
</ul>

<h2 id="おわり">おわり</h2>

<p>ローカルのPDFを全文検索する<a href="https://github.com/azu/searchive/tree/master/packages/searchive-app" title="searchive-app">searchive-app</a>の紹介とそのプロジェクト構造の解説をしました。</p>

<p>最初は<a href="https://github.com/weixsong/elasticlunr.js" title="elasticlunr.js">elasticlunr.js</a>とかを使った全文検索を実装していたのですが、単純にJSONを保存してその中身を単純にマッチしたほうが早かったので変更した経緯とかがあります。</p>

<p>勢いで自分用に書いたところが多いので、PRやIssueとかあったらよろしくお願いします。</p>

<ul>
<li><a href="https://github.com/azu/searchive" title="azu/searchive: Search All My Documents{PDF}.">azu/searchive: Search All My Documents{PDF}.</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>performance.markにメタデータを紐付けできるライブラリを書いた</title>
   <link href="http://efcl.info/2017/11/15/performance.mark-metadata/"/>
   <updated>2017-11-15T21:58:00+09:00</updated>
   <id>http://efcl.info/2017/11/15/performance.mark-metadata</id>
   <content type="html"><![CDATA[ <p><code>performance.mark</code>というパフォーマンス計測に役立つAPIがあります。
<code>performance.mark</code> APIを使うと、指定して処理をマーキングでき、その結果を開発者ツールでみれます。とても便利なのですが、そのマーキングとメタデータを紐付ける仕組みがありませんでした。</p>

<p><a href="https://github.com/almin/almin/releases/tag/almin%400.14.0"><img src="http://efcl.info/wp-content/uploads/2017/09/20-1505888631.png" alt="DevTool timeline"></a></p>

<ul>
<li><a href="http://efcl.info/2016/08/15/performance.mark/" title="performance.markでパフォーマンス計測する | Web Scratch">performance.markでパフォーマンス計測する | Web Scratch</a></li>
<li><a href="http://efcl.info/2017/09/20/almin-performance-profile-0.14.0/" title="Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように | Web Scratch">Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように | Web Scratch</a></li>
</ul>

<p>TPAC 2017の<a href="https://docs.google.com/presentation/d/1d64Y4rtLCxobGgljVySU2CJpMPK5ksaiZuv3ka1dCVA/edit#slide=id.p" title="User Timing L3 - Google スライド">User Timing L3 - Google スライド</a>では、<code>performance.mark</code> APIでメタデータ(<code>details</code>)を紐付けできる仕組みが提案されています。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">performance</span><span class="p">.</span><span class="nx">mark</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">startTime</span><span class="p">,</span> <span class="nx">details</span><span class="p">)</span>
</code></pre></div>
<p>これを使うと「Aという処理でデータを取得」を<code>performance.mark</code>でマーキングする際に、実際に取得したデータをとマーキングをメタデータ(<code>details</code>)によって紐付けられます。</p>

<p>これを速く使いたかったので<code>performance.mark</code>にメタデータを紐付けできる<a href="https://github.com/azu/performance-mark-metadata" title="performance-mark-metadata">performance-mark-metadata</a>というライブラリを書きました。</p>

<ul>
<li><a href="https://github.com/azu/performance-mark-metadata" title="azu/performance-mark-metadata: `performance.mark` with custom meta data.">azu/performance-mark-metadata: <code>performance.mark</code> with custom meta data.</a></li>
</ul>

<h2 id="サポート環境">サポート環境</h2>

<ul>
<li>モダンブラウザ と Node.js &gt;= 8.5.0をサポートしています。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" title="Performance.mark()">Performance.mark()</a> APIが使える環境ならOKです</li>
<li>Node.jsも8.5.0で<code>perf_hooks</code>が追加されています。</li>
<li><a href="https://nodejs.org/api/perf_hooks.html" title="Performance Timing API | Node.js v9.2.0 Documentation">Performance Timing API | Node.js v9.2.0 Documentation</a></li>
</ul>

<p>それ以外の環境では<code>Performance.mark()</code>のpolyfillが必要です。</p>

<ul>
<li><a href="https://github.com/nicjansma/usertiming.js" title="nicjansma/usertiming.js: UserTiming polyfill">nicjansma/usertiming.js: UserTiming polyfill</a></li>
</ul>

<h2 id="インストール">インストール</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install performance-mark-metadata
</code></pre></div>
<h2 id="使い方">使い方</h2>

<p>使い方は単純で<code>performance.mark</code>のProposalとよく似た形です。
<code>marker.mark(name, metadata)</code> を渡すようにしています。(全く同じにしなかったのは仕様変更の可能性もあるため)</p>

<p>メタデータを取り出すときは<code>marker.getEntryMetadata(entry)</code>で<code>entry</code>に紐づく<code>metadata</code>を取り出せます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">PerformanceMetadataMarker</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;performance-mark-metadata&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PerformanceMetadataMarker</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">metadata</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">details</span><span class="o">:</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="s2">&quot;value&quot;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kr">const</span> <span class="nx">markerName</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">;</span>
<span class="c1">// mark with metadata</span>
<span class="nx">marker</span><span class="p">.</span><span class="nx">mark</span><span class="p">(</span><span class="nx">markerName</span><span class="p">,</span> <span class="nx">metadata</span><span class="p">);</span>
<span class="nx">performance</span><span class="p">.</span><span class="nx">getEntriesByName</span><span class="p">(</span><span class="nx">markerName</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">entry</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">marker</span><span class="p">.</span><span class="nx">getEntryMetadata</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
    <span class="cm">/*</span>
<span class="cm">    {</span>
<span class="cm">        details: { key: &quot;value&quot; }</span>
<span class="cm">    };</span>
<span class="cm">    */</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">metadata</span><span class="p">,</span> <span class="s2">&quot;should get same metadata&quot;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p><code>entry</code>オブジェクトは<code>performance.get*</code> APIで取得できます。</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries">Performance.getEntries() - Web APIs | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName">Performance.getEntriesByName() - Web APIs | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByType">Performance.getEntriesByType() - Web APIs | MDN</a></li>
</ul>

<h2 id="おわりに">おわりに</h2>

<p><code>performance.mark</code>はシンプルながら結構便利なAPIです。
<code>performance.now</code>を使うため負荷的に優しく、とりあえず必要なマーキングをしておき、後から取り出して細かく計測(<code>measure</code>)できます。</p>

<p>単純なパフォーマンスのロギングと違ってブラウザやNode.jsで使える共通の仕様であるため、<a href="http://efcl.info/2017/09/20/almin-performance-profile-0.14.0/" title="Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように | Web Scratch">Almin + React/Vue.jsのパフォーマンスプロファイルをタイムライン表示できるように | Web Scratch</a>のように他のライブラリと組み合わせ計測もできます。</p>

<p>今までは名前のみであったため処理時間しか取れるデータはありませんでしたが、<a href="https://github.com/azu/performance-mark-metadata" title="performance-mark-metadata">performance-mark-metadata</a>を使うことで任意のメタデータを乗せられるので幅が広がるのかなと思います。
将来的にUser Timing APIの方にこの仕組みが入ったらそちらに移行していくのがいいかなと思います。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>#html_modules_study アウトラインメモ</title>
   <link href="http://efcl.info/2017/11/15/html_module_study/"/>
   <updated>2017-11-15T20:56:00+09:00</updated>
   <id>http://efcl.info/2017/11/15/html_module_study</id>
   <content type="html"><![CDATA[ <h1 id="html_modules_study-connpass"><a href="https://web-study.connpass.com/event/70731/" title="html_modules_study - connpass">html_modules_study - connpass</a></h1>

<p><a href="https://web-study.connpass.com/event/70731/" title="html_modules_study - connpass">html_modules_study</a>に参加したのでメモ。</p>

<h2 id="webcomponents-updates-1000ch">WebComponents Updates - @1000ch</h2>

<blockquote>
<p>スライド: <a href="https://1000ch.github.io/slide/webcomponents-2017/#" title="Web Components Updates">Web Components Updates</a></p>
</blockquote>

<ul>
<li>Void or Self-closing Element

<ul>
<li>今は <code>&lt;x-button&gt;&lt;/x-button&gt;</code> なので省略したい</li>
<li><code>&lt;x-button&gt;</code></li>
</ul></li>
<li><code>assignedElements()</code>

<ul>
<li><code>assignedNodes()</code>はTextも含まれる</li>
<li>挿入された要素だけをShadom DOM内部で参照したい</li>
</ul></li>
<li>Custom Psuedo-elements

<ul>
<li>疑似要素を独自に定義出来るようにしたいPropsal</li>
<li><code>&lt;input paseudo=&quot;start-data&quot; type=&quot;data&quot;&gt;</code></li>
<li><code>data-range-selector::start-data</code></li>
</ul></li>
<li>CSS shadow Parts

<ul>
<li>Shadow Hostを<code>::part()</code>や<code>::theme()</code>で参照するCSSセレクタ</li>
</ul></li>
<li>HTML modules

<ul>
<li><code>import</code>、<code>export</code>でHTMLをロードしていいか</li>
<li>ESのシンタックスも拡張する必要がある?</li>
</ul></li>
<li>(個人の意見) HTML Importsが宣言的に使えば何でもいい</li>
<li>HTML Template Instantiation

<ul>
<li><a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md" title="webcomponents/Template-Instantiation.md at gh-pages · w3c/webcomponents">webcomponents/Template-Instantiation.md at gh-pages · w3c/webcomponents</a></li>
<li><code>&lt;template&gt;</code>の中でMustace的なテンプレート</li>
<li>記法とその振る舞いを定義</li>
</ul></li>
<li><code>&lt;link rel=&quot;modulepreload&quot;&gt;</code>

<ul>
<li><a href="https://github.com/whatwg/html/pull/2383">Add <link> rel=&quot;modulepreload&quot; by domenic · Pull Request #2383 · whatwg/html</a></li>
<li><a href="https://docs.google.com/document/d/1ds9EEkcDGnt-iR8SAN-_7nsOfw7gsMfhZjzZ_QAIyjM/edit">Loading Performance with (Many) Modules: Summary as of Oct 7, 2017 - Google ドキュメント</a></li>
<li>moduleの先までpreloadをしていくpreload</li>
</ul></li>
<li>rel=preloadとかas=moduleではだめ?

<ul>
<li>script要素のcredentialと一致する必要がある</li>
<li>パースする前にhtml moduleなのかスクリプトなのかわからないと問題に?</li>
<li>rel=preloadは専用のpreload cacheに保存してる V8</li>
<li>なので、module cache</li>
<li>なぜas=moduleではだめ?</li>
<li><a href="https://github.com/whatwg/fetch/issues/486" title="preload, destinations, and module scripts · Issue #486 · whatwg/fetch">preload, destinations, and module scripts · Issue #486 · whatwg/fetch</a></li>
</ul></li>
</ul>

<h2 id="template-instantiation-md-koba04">Template-Instantiation.md: @koba04</h2>

<blockquote>
<p>スライド: <a href="https://speakerdeck.com/koba04/template-instantiation" title="Template Instantiation // Speaker Deck">Template Instantiation // Speaker Deck</a></p>
</blockquote>

<ul>
<li><a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md" title="HTML Template Instantiation">HTML Template Instantiation</a></li>
<li>テンプレートであってコンポーネントではない

<ul>
<li>mustache syntax</li>
</ul></li>
<li>バックグラウンド

<ul>
<li>いろんなフレームワークが独自のテンプレートを定義していた</li>
<li>それぞれのテンプレートを組み合わせるのは難しい</li>
</ul></li>
<li>mustache syntax

<ul>
<li>シンプル</li>
<li>値を代入する所だけはmustache syntax</li>
<li>他はConfigurableにして柔軟性を作る</li>
</ul></li>
<li>Use Cases 9コ

<ul>
<li>テンプレートからDOM Treeを作れる</li>
<li>テンプレートの変数へ代入できる</li>
<li>テンプレートの変数は更新できる</li>
<li>テンプレートの変数処理には関数を挟むことができる</li>
<li>テンプレート -&gt; JavaScriptへ値を渡せる = 双方向なバンディング
ィング</li>
<li>属性を更新できる</li>
<li>デフォルトの値を指定できる</li>
<li>DOMの出し分けに対応する</li>
<li>ループ処理</li>
</ul></li>
<li>Template Parts

<ul>
<li><code>\{\{value\}\}</code> をPartsと呼ぶ</li>
<li>このpartsを更新することでCapitalizeとかの処理を実装できる</li>
<li>前後のNodeや親子のNodeの参照などを持つ</li>
</ul></li>
<li>Template Partsの中にTemplate Parts

<ul>
<li><code>InnterTemplatePart</code></li>
</ul></li>
<li>Template Process Callback

<ul>
<li>createとupdate時に呼ばれるcallbackを指定できる</li>
<li><code>createCallback</code></li>
<li><code>processCallback</code></li>
</ul></li>
<li>Other libraries

<ul>
<li><a href="https://github.com/PolymerLabs/lit-html" title="PolymerLabs/lit-html: HTML template literals in JavaScript">PolymerLabs/lit-html: HTML template literals in JavaScript</a>

<ul>
<li>JavaScriptの中にテンプレートを書く</li>
<li>Tagged Template</li>
</ul></li>
<li><a href="https://glimmerjs.com/" title="Glimmer">Glimmer</a>

<ul>
<li><a href="https://emberjs.com/blog/2017/10/10/glimmer-progress-report.html" title="Ember.js - Glimmer.js Progress Report">Ember.js - Glimmer.js Progress Report</a></li>
</ul></li>
</ul></li>
<li>出典

<ul>
<li><a href="https://github.com/whatwg/html/issues/2254" title="Standardize &amp;lt;template&amp;gt; variables and event handlers · Issue #2254 · whatwg/html">Standardize template variables and event handlers · Issue #2254 · whatwg/html</a></li>
</ul></li>
<li>FAQ

<ul>
<li><code>\{\{</code>の記号 は変えられない?</li>
</ul></li>
</ul>

<h2 id="html-modules-tkochi">HTML Modules -  @tkochi</h2>

<ul>
<li>Blinkやってる</li>
<li>Layout Tests</li>
<li>HTML5

<ul>
<li>progressとかいろんな要素が増えた</li>
<li>もっとプリミティブなAPIを定義したほうがいいのではというのがスタート</li>
</ul></li>
<li>HTML Imports

<ul>
<li><a href="https://www.polymer-project.org/blog/2017-08-22-npm-modules" title="Polymer 3.0 preview: npm and ES6 Modules - Polymer Project">Polymer 3.0 preview: npm and ES6 Modules - Polymer Project</a></li>
<li>PolymerでもHTML ImportsからES moduleに移行することになった</li>
</ul></li>
<li>そもそもHTML Importとは

<ul>
<li>コンポーネントの定義を一つにまとめてロードする仕組み</li>
<li><code>&lt;link rel=import href=my-button.html&gt;</code></li>
<li><code>HTMLLinkElement.import</code> (readonly)</li>
<li>後は使うだけ</li>
</ul></li>
<li>共通のImport

<ul>
<li>common.htmlを2回importした時</li>
<li>1度目は実行される、2度目は実行されない</li>
<li>import</li>
</ul></li>
<li>HTML Importのメリット

<ul>
<li><code>&lt;script&gt;</code>が実行できる</li>
<li>依存関係を解決しながらロードしてくれる

<ul>
<li>ES moduleはすべての依存をリンクしてから実行するモデル</li>
<li>HTML Importsならパイプライン処理できる</li>
</ul></li>
<li>テンプレート、スタイル、スクリプトを1つのファイルにかける

<ul>
<li>Vueの<code>.vue</code>とかと同じ</li>
</ul></li>
</ul></li>
<li>問題点

<ul>
<li>Chrome以外の実装がない</li>
<li><code>Document</code>のツリーができてしまう

<ul>
<li>しかし、HTML Importの<code>Document</code>は表示されない</li>
<li>Fragmentではない</li>
<li>Documentを持つ問題を引きずる

<ul>
<li><code>&lt;base&gt;</code>問題</li>
</ul></li>
<li>import先でも<code>document</code>を呼ぶとメインのドキュメントが返ってくる</li>
<li><code>document.currentScript.ownerDocument</code></li>
</ul></li>
<li><code>&lt;style&gt;</code>がメインドキュメントに適応される

<ul>
<li>HTML module待ち</li>
</ul></li>
<li>ESModulesと相互運用できない

<ul>
<li>ロードとか実行の順序を決めるとかをHTML ImportとES Module両方をそれぞれ書かないといけなくなる</li>
</ul></li>
</ul></li>
<li>HTML Modules

<ul>
<li><a href="https://github.com/w3c/webcomponents/issues/645">https://github.com/w3c/webcomponents/issues/645</a>

<ul>
<li>長いスレッド</li>
</ul></li>
<li>実際にユーザーに出すときにはコンパイルした何かになってる</li>
<li>そういうときにHTML Modulesみたいなそのまま出すものを作る意味がどれぐらいあるのか</li>
<li>スレッドのまとめ

<ul>
<li>HTML in JS、JS in HTML</li>
<li>importでJavaScript以外も <code>as Foo</code> で読めるようにするとか</li>
<li><code>Symbol.importer</code>みたいなhookを実装できるようにすればいいのではとか</li>
<li>論点がまとまってない</li>
</ul></li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">module</span><span class="nt">&gt;</span>
<span class="kr">import</span> <span class="nx">temp</span> <span class="nx">from</span> <span class="s2">&quot;my-template.html&quot;</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;#id&quot;</span><span class="p">).</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">importNode</span><span class="p">(</span><span class="nx">tmpl</span><span class="p">.</span><span class="nx">content</span><span class="p">));</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>実現例(イメージ)</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">module</span><span class="nt">&gt;</span>
<span class="kr">import</span> <span class="o">*</span> <span class="nx">from</span> <span class="s2">&quot;lgtm-button.html&quot;</span><span class="p">;</span>
<span class="c1">// registryはwindowにくっついている</span>
<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;lgtm-button&gt;&lt;/lgtm-button&gt;</span>
</code></pre></div>
<p>実装例(import/export)</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;template&gt;</span>
  <span class="nt">&lt;button&gt;</span>LGTM<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="kr">import</span> <span class="nx">MyButton</span> <span class="nx">from</span> <span class="s2">&quot;./my-button.html&quot;</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">LGTMButton</span> <span class="kr">extends</span> <span class="nx">MyButton</span><span class="p">{}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<ul>
<li><p>HTML moduileはHTMLとES両方の仕様を参照する</p>

<ul>
<li>ES側にhookの仕組み</li>
<li>HTML側に解釈の仕組み</li>
</ul></li>
<li><p>何がうれしいのか</p>

<ul>
<li><code>&lt;template&gt;</code>を読み込みたい</li>
<li>文字列からDOM生成じゃないので効率的?</li>
<li>ネイティブHTMLパーザーを使うと性能が出る?</li>
</ul></li>
<li><p>TAPC 2017の議論</p>

<ul>
<li>ES moduleベースのシステム</li>
<li>InertなHTMLがロードできる

<ul>
<li><a href="http://takenspc.hatenablog.com/entry/2013/09/26/232111" title="inertとは何だろう - Unreviewed">inertとは何だろう - Unreviewed</a></li>
</ul></li>
<li>ここまでは共通認識</li>
<li>single file component

<ul>
<li>html,js,cssを含んだコンポーネント</li>
</ul></li>
<li><code>&lt;script&gt;</code>が実行できる</li>
<li>DOMの一部をexportできる</li>
<li>他のモジュールをimportできる</li>
<li>Document or DocumentGragment</li>
<li>独立した空間

<ul>
<li>サードパーティなHTMLを独立した空間で実行出来る</li>
<li>いいねボタンとかを別の空間にする</li>
<li><a href="https://github.com/tc39/proposal-realms" title="tc39/proposal-realms: ECMAScript Proposal, specs, and reference implementation for Realms">tc39/proposal-realms: ECMAScript Proposal, specs, and reference implementation for Realms</a></li>
</ul></li>
<li>何も決まらなかった</li>
<li>具体的なユースケースで話をしようぜ</li>
</ul></li>
<li><p>FAQ</p>

<ul>
<li>Q. パッケージマネージャについて議論されてる?</li>
<li>A. 特になかった

<ul>
<li>Polymerの人もいるので一応考えているのでは</li>
<li><a href="https://github.com/package-community/discussions/issues/2" title="javascript: npm for web packages · Issue #2 · package-community/discussions">javascript: npm for web packages · Issue #2 · package-community/discussions</a></li>
</ul></li>
<li>Q. 文章のフォーマットなのに文章として実行できないもを定義する意味は?</li>
<li>A. Declarative Custom HTMLとかの議論はあった</li>
</ul></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>textlintのコアをTypeScriptで書き直した、textlintの今後について</title>
   <link href="http://efcl.info/2017/11/06/textlint-core-refactoring/"/>
   <updated>2017-11-06T10:43:00+09:00</updated>
   <id>http://efcl.info/2017/11/06/textlint-core-refactoring</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/textlint/textlint/releases/tag/textlint%409.0.0" title="textlint 9.0.0">textlint 9.0.0</a>をリリースしました。
textlint 9.0.0では<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel" title="@textlint/kernel">@textlint/kernel</a>という内部的に使うコアモジュールをTypeScriptで書き直したバージョンが使われています。</p>

<p>元々textlintはNode.jsで動くように作られたため、<code>fs</code>モジュールなどNode.jsに依存しています。
そのため、ブラウザなどで動かす場合などはビルド時に色々工夫しないと動きません。</p>

<ul>
<li><a href="http://io-monad.hatenablog.com/entry/2016/03/14/225800" title="文書校正ツール textlint の Chrome 拡張を作った - もなでぃっく">文書校正ツール textlint の Chrome 拡張を作った - もなでぃっく</a></li>
<li><a href="https://muunyblue.github.io/823b2d10224a6a29f91fc7c0f46f1b8e.html" title="LocalStorageで誰でも安全にMarkdownでスライドやメモ作れるサービス作ったよ">LocalStorageで誰でも安全にMarkdownでスライドやメモ作れるサービス作ったよ</a></li>
</ul>

<p>この問題をどうにかするためには、<code>textlint</code>というモジュールからロジックやLint処理部分だけをNode.jsなどに依存しない純粋なJavaScriptとして切り出す必要があります。</p>

<p>アドホックに対応するならブラウザ向けのbundleを<a href="https://qiita.com/shinout/items/911e024368e2cb29fd3d" title="browser field">browser field</a>などで提供すれば終わりですが、長期的なことを考えるとモジュールを分けたほうが建設的です。</p>

<p><a href="https://github.com/textlint" title="textlint">textlint organization</a>を見ると分かるように<a href="https://github.com/textlint" title="textlint">textlint</a>はMarkdownパーサやトラバーサ、フォーマッターなどがモジュールとして各リポジトリに分けられていました。部品となるモジュールとリポジトリを1対1で分けると、Aをアップデートすると、Aに依存するBやCを更新するといったアップデートの連鎖反応が起きる問題があります。
また、新しいモジュールを切り出す心理的なコストがありました。</p>

<p>そのため、まずは<code>textlint</code>を構成するモジュールを1つのリポジトリにまとめたmonorepo化をすることにしました。</p>

<h2 id="monorepo">monorepo</h2>

<p><a href="https://github.com/textlint" title="textlint">textlint</a>では<a href="https://github.com/lerna/lerna" title="lerna">lerna</a>を使ってmonorepo化しています。これにより、モジュール間の依存のアップデートが1つのPRにまとめられるなどアップデートの連鎖反応がある程度自動化できるメリットがあります。
また、新しいモジュールを追加するのも単純にディレクトリを切るだけなので心理的なコストは軽減されます。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/255">Setup monorepo · Issue #255 · textlint/textlint</a></li>
<li><a href="https://github.com/textlint/textlint/issues/270">Import * to monorepo · Issue #270 · textlint/textlint</a></li>
</ul>

<p>一方、CIにかかる時間やpublishする際のコストは増加する傾向があります。
また、まだmonorepoにおけるリリースノートの戦略がイマイチ決まっていないという問題もあります。
これは<a href="https://github.com/almin/almin" title="almin">almin</a>とか<a href="https://github.com/textlint-rule/textlint-rule-preset-google" title="textlint-rule-preset-google">textlint-rule-preset-google</a>など、他にもmonorepoをやっているのでいい方法を見出したいです。</p>

<ul>
<li><a href="https://qiita.com/azu/items/4b9fc8d4df78f2216901" title="Lerna(monorepo)とCHANGELOG(リリースノート) - Qiita">Lerna(monorepo)とCHANGELOG(リリースノート) - Qiita</a></li>
</ul>

<h2 id="textlint-kernel"><a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a></h2>

<p>monorepo化がひとまずできたので、<a href="https://github.com/textlint/textlint/releases/tag/textlint%408.1.0" title="textlint@8.1.0">textlint 8.1.0</a>で<code>textlint</code>モジュールから<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>というコアモジュールを切り出しました。(Coreという名前じゃないのは既にCoreという名前を使ったものがあったため)
<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>は<code>fs</code>などNode.js特有のものに依存してないような作りになっているので普通にwebpackやbrowserifyなどでビルドすれば動作します。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/pull/292" title="Carve out textlint core logic into @textlint/kernel by azu · Pull Request #292 · textlint/textlint">Carve out textlint core logic into @textlint/kernel by azu · Pull Request #292 · textlint/textlint</a></li>
</ul>

<p>今回の<a href="https://github.com/textlint/textlint/releases/tag/textlint%409.0.0" title="textlint 9.0.0">textlint 9.0.0</a>ではさらにこの<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel" title="@textlint/kernel">@textlint/kernel</a>をTypeScriptに書き換えました。理由としては<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>はロジックの塊であることと今後のリファクタリングのしやすさを考えたためです。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/pull/301" title="refactor(textlint-kernel): Convert JavaScript to TypeScript by azu · Pull Request #301 · textlint/textlint">refactor(textlint-kernel): Convert JavaScript to TypeScript by azu · Pull Request #301 · textlint/textlint</a></li>
</ul>

<blockquote>
<p>TL;DR: both Flow and TypeScript are pretty good, and conservatively either of them can prevent about 15% of the bugs that end up in committed code.<br>
<a href="https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/">https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/</a></p>
</blockquote>

<p>JavaScriptに型注釈を加えることで15%程度バグを減らすことができるという話もありますが、IDEなどでリファクタリングがしやすくなるメリットは大きいです。(名前に依存した壊れたリファクタリングが発生しにくい)</p>

<p>JavaScriptからTypeScriptへの移行方法は次の記事で書いてるような手法を取っています。</p>

<ul>
<li><a href="http://efcl.info/2017/07/17/JavaScript-to-TypeScript/" title="JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch">JavaScriptのライブラリを徐々にTypeScriptに移行する | Web Scratch</a></li>
</ul>

<p>まだ単に型を付けただけであったり、テストはTypeScriptになってなかったりします。
本体の<code>textlint</code>の方もTypeScript化したいので興味がある人は次のIssueを参照してください。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/248" title="Use with TypeScript · Issue #248 · textlint/textlint">Use with TypeScript · Issue #248 · textlint/textlint</a></li>
</ul>

<p>また、まだルール側をTypeScriptで書きやすくなってはいないのでその辺もどうにかしたいですね。</p>

<h2 id="今後">今後</h2>

<p>textlintはルールを気軽に作れるようにする土台を作ることが目的です。</p>

<ul>
<li><a href="http://efcl.info/2014/12/30/textlint/" title="JavaScriptでルールを書けるテキスト/Markdownの校正ツール textlint を作った | Web Scratch">JavaScriptでルールを書けるテキスト/Markdownの校正ツール textlint を作った | Web Scratch</a></li>
</ul>

<p>今回色々リファクタリングして、<a href="https://github.com/textlint/textlint/tree/master/packages/textlint-kernel">@textlint/kernel</a>の分離でLint以外への発展も少し見えてきています。Lintは入力に対して解答(正否)を出さないと行けないですが、<a href="https://github.com/azu/textstat" title="textstat">textstat</a>のように統計データを出したり、<a href="http://www.academia.edu/154001/Glosser_Enhanced_Feedback_for_Student_Writing_Tasks" title="Glosser">Glosser</a>のようなフィードバックエンジンを作ってみたいです。</p>

<p>また、現在textlintに関係する<a href="https://github.com/search?utf8=%E2%9C%93&amp;q=textlint">リポジトリは200以上</a>、textlint<a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule">ルールは100以上</a>あります。
ただ、半分以上は自分が関連しているものなので、もっと属人性を解消して安定させたいです。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr">textlint 200 repositories. <a href="https://t.co/ZpF7DeuSLr">pic.twitter.com/ZpF7DeuSLr</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/924671458898358272?ref_src=twsrc%5Etfw">October 29, 2017</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>もっと安定して良くしていくために、textlint organizationのコラボレーターを募集しています。最初からコラボレーター(リリース権限とかもてる人)というのも互いに変ではあるので、まずはコントビューションしてくれる人を募集しています。</p>

<p>textlintではどういうところが足りてない、直せるのかなどについて簡単にまとめてみます。</p>

<h2 id="textlintへのコントビューション"><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>へのコントビューション</h2>

<p>相談したいことがある場合はGitterに日本語のchatがあるのでそちらを使ってみてください。
(これどうやって直せばいいのとか？)</p>

<p><a href="https://gitter.im/textlint-ja/textlint-ja?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/textlint-ja/textlint-ja.svg" alt="Gitter"></a></p>

<h2 id="textlintを直す">textlintを直す</h2>

<p><a href="https://github.com/textlint/textlint/blob/master/.github/CONTRIBUTING.md" title="Contributing Guide">Contributing Guide</a>にコミット方法やテスト方法など一通りのやり方は書いてあります。</p>

<h3 id="ドキュメントを直す">ドキュメントを直す</h3>

<ul>
<li>適当な英語が多いので修正歓迎</li>
</ul>

<h3 id="ドキュメントを追加する">ドキュメントを追加する</h3>

<ul>
<li>ルールの作り方とかもっと具体例のドキュメント増やしたい</li>
<li>こういうのがわからないというIssueを立てるでもよさそう</li>
</ul>

<h3 id="コアを直す">コアを直す</h3>

<ul>
<li>textlintはmonorepoになっているので<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>に色々なパッケージが入っています。

<ul>
<li>monorepoへの移行が完璧ではないのでそれをなおすのも歓迎です</li>
<li><a href="https://github.com/textlint/textlint/issues/270" title="Import * to monorepo #270">Import * to monorepo #270</a></li>
</ul></li>
</ul>

<p><a href="https://github.com/textlint/textlint/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>label:&quot;good first issue</code></a>というラベルが付いてるものは、比較的やることがはっきりしています。
そのため最初のコントビューションとして手が出しやすいかもしれません。</p>

<p>また、textlintはあまりパフォーマンスの最適化がまだ行われていません。<a href="https://github.com/textlint/textlint/blob/master/packages/markdown-to-ast/src/markdown-parser.js" title="markdown-parser">markdown-parser</a>など明らかに無駄な処理をしている部分があります。
一方、500以上のユニットテストや典型的なユースケースの<a href="http://efcl.info/2015/07/29/example-test-on-npm/" title="Exampleテスト">Exampleテスト</a>、実際の文章を使った<a href="https://github.com/textlint/textlint/tree/master/test/integration-test" title="Integration test">Integration test</a>などが書かれています。
そのため、壊れるとテストが落ちるはずなのでパフォーマンスの改善やリファクタリングなどはある程度し易いかもしれません。</p>

<p>TypeScriptで書きたいという人は、textlint本体もTypeScript化したり、型定義を整理したりすると良いかもしれません。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/248" title="Use with TypeScript #248">Use with TypeScript #248</a></li>
</ul>

<p>また、textlintをブラウザでもっと簡単に上手く動かしたいという人は次のIssueにどういうものがあると便利なのかやPOCを作ってみると良いかもしれません。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/issues/299" title="@textlint/browser · Issue #299 · textlint/textlint">@textlint/browser · Issue #299 · textlint/textlint</a></li>
</ul>

<h2 id="ルールを直す">ルールを直す</h2>

<ul>
<li>textlintはデフォルトでルールをもっていません</li>
<li>そのためすべてのルールはプラグイン扱いです</li>
<li>ルール一覧は<a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule" title="Collection of textlint rule · textlint/textlint Wiki">Collection of textlint rule · textlint/textlint Wiki</a>にあります</li>
<li>各ルールにPull RequestやIssueを立てるのがよさそうです</li>
<li><a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a>で管理している日本語専用のルールは、日本語が分かる人じゃないと使わないので、Issueなどは日本語で問題ないです</li>
</ul>

<h2 id="ルールを追加する">ルールを追加する</h2>

<p>textlintのルールを置く場所には特に制限はありません。また自由にルールを書けます。</p>

<ul>
<li>ルールの作り方: <a href="https://github.com/textlint/textlint/blob/master/docs/rule.md" title="Creating Rules">Creating Rules</a></li>
</ul>

<p>ただ一度作ったルールがメンテナンスされなくなってしまうのはもったないので、<a href="https://github.com/textlint-rule/" title="textlint-rule">textlint-rule</a>と<a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a>は<a href="https://maintenance-guidelines-for-organization.github.io/" title="Maintenance Guidelines for Organization">Maintenance Guidelines for Organization</a>というガイドラインの元にしています。</p>

<p>人がボトルネックになることを避けるため、人が正しいことをできるように信用することという原則を元にしてリポジトリやnpmパッケージの権限を共有できるようにするという方針です。
そのため、textlintルールを作ったはいいけど置き場所や管理が不安というは、Organizationに参加してみるといいかもしれません。</p>

<p>それぞれoranizationも用意してあるので興味がある人は、<a href="https://twitter.com/azu_re">@azu_re</a>か<a href="https://gitter.im/textlint-ja/textlint-ja">Gitter</a>で言ってもらえれば inviteします。</p>

<ul>
<li>日本語専用のルール: <a href="https://github.com/textlint-ja" title="textlint-ja">textlint-ja</a></li>
<li>その他のルール: <a href="https://github.com/textlint-rule/" title="textlint-rule">textlint-rule</a></li>
</ul>

<p><a href="https://github.com/textlint/textlint/releases/tag/textlint%409.1.1" title="textlint@9.1.1">textlint@9.1.1</a>でscoped moduleのサポートを拡張したのもこういったOrganizationでのルール管理のしやすさを改善するためでもあります。</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&quot;rules&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;@textlint-rule/preset-google&quot;</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="ルールを紹介する">ルールを紹介する</h2>

<p>自分が使っているルールや設定をブログなどで紹介するのも貢献です。</p>

<h2 id="ツールを良くする">ツールを良くする</h2>

<p>textlintのElectronアプリがありますがそこまで作り込まれてません。</p>

<ul>
<li><a href="http://efcl.info/2017/05/12/textlint-app/">textlintのElectronアプリを作った | Web Scratch</a></li>
<li><a href="https://github.com/textlint/textlint-app">textlint/textlint-app: textlint standalone application top on Electron.</a></li>
</ul>

<p>textlintのルールをコマンド一発で作り始めることができるツールがあります。
コーパスを使ってルールをチェックしやすくするなどもっと色々な工夫をして、ルールづくりを簡単にできると嬉しいです。</p>

<ul>
<li><a href="http://efcl.info/2016/12/14/create-textlint-rule/">textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch</a></li>
<li><a href="https://github.com/textlint/create-textlint-rule">textlint/create-textlint-rule: Create textlint rule project with no configuration.</a></li>
<li><a href="https://github.com/textlint-ja/technological-book-corpus-ja" title="textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス">textlint-ja/technological-book-corpus-ja: 日本語で書かれた技術書のコーパス</a></li>
</ul>

<h2 id="ウェブサイト">ウェブサイト</h2>

<p>textlintのウェブサイト兼オンラインデモとして<a href="https://textlint.github.io/" title="textlint - pluggable linting tool for text and markdown">textlint - pluggable linting tool for text and markdown</a>があります。</p>

<p>こちらも<a href="https://github.com/textlint/textlint.github.io/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"><code>label:&quot;good first issue&quot;</code></a>のラベルがついたIssueがあります。</p>

<h2 id="その他">その他</h2>

<p><a href="https://gist.github.com/azu/2b482e8e2aa636970f5f6110f6488719" title="textlintの直し方">textlintの直し方</a>に簡単にコントビューション方法についてまとめています。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>自然言語にマッチする正規表現を書いて、形態素解析結果でテストして、置換するライブラリを書いた</title>
   <link href="http://efcl.info/2017/10/31/nlp-pattern-match/"/>
   <updated>2017-10-31T11:23:00+09:00</updated>
   <id>http://efcl.info/2017/10/31/nlp-pattern-match</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールを色々書いていて自然言語のマッチの問題がいくつかありました。</p>

<p><a href="https://github.com/textlint-ja/textlint-rule-preset-JTF-style" title="textlint-ja/textlint-rule-preset-JTF-style: JTF日本語標準スタイルガイド for textlint.">textlint-ja/textlint-rule-preset-JTF-style: JTF日本語標準スタイルガイド for textlint.</a>は基本的に正規表現をベースに実装していました。
正規表現で自然言語に対してマッチするのは簡単でいいのですが、意図しない範囲にマッチすることもあるためfalse-positiveになりやすい問題がありました。</p>

<p>一方、ですます or である調の混在をチェックする<a href="https://github.com/textlint-ja/textlint-rule-no-mix-dearu-desumasu" title="textlint-rule-no-mix-dearu-desumasu">textlint-rule-no-mix-dearu-desumasu</a>では、<a href="https://github.com/takuyaa/kuromoji.js#api" title="kuromoji.js">kuromoji.js</a>などで形態素解析した結果を使っています。
形態素解析をすることで(正しい日本語なら)より正確にマッチできます。</p>

<p>しかし、形態素解析のトークンに対してマッチする処理やその情報を元に置換するのは結構面倒です。
kuromojiが出力するトークンにマッチするライブラリなどを書いて使っていますが、それでもそこそこ面倒です。</p>

<ul>
<li><a href="https://github.com/azu/morpheme-match">azu/morpheme-match: match function that match token(形態素解析) with sentence.</a></li>
<li><a href="https://github.com/azu/morpheme-match-all">azu/morpheme-match-all: A wrapper of morpheme-match API. Match all kuromoji&#39;s tokens.</a></li>
</ul>

<p>また、<a href="https://github.com/textlint-ja/textlint-rule-ja-no-abusage" title="textlint-ja/textlint-rule-ja-no-abusage: よくある日本語の誤用をチェックするtextlintルール">textlint-ja/textlint-rule-ja-no-abusage: よくある日本語の誤用をチェックするtextlintルール</a>などはマッチする範囲もトークンで指定するため、コードとしてもあまり読みやすくありません(単語が分解された大きなJSONを持つ形)</p>

<p>この簡単にマッチできるが誤判定し易い正規表現と正確にマッチできるが面倒臭いトークンベースの中間なライブラリをつくりました。</p>

<h2 id="nlp-pattern-match"><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">nlp-pattern-match</a></h2>

<p><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.</a>というリポジトリはmonorepoなのでいろんなライブラリが入っていますが、大きく分けて二種類のライブラリがあります。</p>

<h3 id="パーサ">パーサ</h3>

<p>一つは正確にマッチするのに必要な自然言語を分解するパーサ(形態素解析レベル)です。</p>

<ul>
<li><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-english" title="nlcst-parse-english">nlcst-parse-english</a>

<ul>
<li>英語のテキストを単語に分解してPart-of-speech(POS)情報を付加したNLCST</li>
</ul></li>
<li><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-parse-japanese" title="nlcst-parse-japanese">nlcst-parse-japanese</a>

<ul>
<li>日本語のテキストを形態素解析したNLCST</li>
</ul></li>
</ul>

<p><a href="https://github.com/syntax-tree/nlcst">NLCST</a>はNatural Language Concrete Syntax Treeのことで、自然言語のCST(スペースなどの位置情報も扱うASTみたいなもの)フォーマットです。
NLCSTは<a href="https://github.com/wooorm/retext">retext</a>などが使っている形式で、ParagraphやSentence、WordなどのNodeから構成されます。</p>

<p>たとえば、<code>&quot;ようこそ、日本へ。&quot;</code>のようなテキストをNLCSTにすると次のような巨大なNodeになります。(長いの省略)</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span><span class="nx">JapaneseParser</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-japanese&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">japaneseParse</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JapaneseParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;ようこそ、日本へ。&quot;</span><span class="p">;</span>
<span class="nx">japaneseParse</span><span class="p">.</span><span class="nx">ready</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">CST</span> <span class="o">=</span> <span class="nx">japaneseParse</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">CST</span><span class="p">)</span>
<span class="p">});</span>
<span class="cm">/*</span>
<span class="cm">{</span>
<span class="cm">  &quot;type&quot;: &quot;RootNode&quot;,</span>
<span class="cm">  &quot;children&quot;: [</span>
<span class="cm">    {</span>
<span class="cm">      &quot;type&quot;: &quot;ParagraphNode&quot;,</span>
<span class="cm">      &quot;children&quot;: [</span>
<span class="cm">        {</span>
<span class="cm">          &quot;type&quot;: &quot;SentenceNode&quot;,</span>
<span class="cm">          &quot;children&quot;: [</span>
<span class="cm">            {</span>
<span class="cm">              &quot;type&quot;: &quot;WordNode&quot;,</span>
<span class="cm">              &quot;children&quot;: [</span>
<span class="cm">                {</span>
<span class="cm">                  &quot;type&quot;: &quot;TextNode&quot;,</span>
<span class="cm">                  &quot;value&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                  &quot;position&quot;: {</span>
<span class="cm">                    &quot;start&quot;: {</span>
<span class="cm">                      &quot;line&quot;: 1,</span>
<span class="cm">                      &quot;column&quot;: 1,</span>
<span class="cm">                      &quot;offset&quot;: 0</span>
<span class="cm">                    },</span>
<span class="cm">                    &quot;end&quot;: {</span>
<span class="cm">                      &quot;line&quot;: 1,</span>
<span class="cm">                      &quot;column&quot;: 5,</span>
<span class="cm">                      &quot;offset&quot;: 4</span>
<span class="cm">                    }</span>
<span class="cm">                  },</span>
<span class="cm">                  &quot;data&quot;: {</span>
<span class="cm">                    &quot;word_id&quot;: 34120,</span>
<span class="cm">                    &quot;word_type&quot;: &quot;KNOWN&quot;,</span>
<span class="cm">                    &quot;word_position&quot;: 1,</span>
<span class="cm">                    &quot;surface_form&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                    &quot;pos&quot;: &quot;感動詞&quot;,</span>
<span class="cm">                    &quot;pos_detail_1&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;pos_detail_2&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;pos_detail_3&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;conjugated_type&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;conjugated_form&quot;: &quot;*&quot;,</span>
<span class="cm">                    &quot;basic_form&quot;: &quot;ようこそ&quot;,</span>
<span class="cm">                    &quot;reading&quot;: &quot;ヨウコソ&quot;,</span>
<span class="cm">                    &quot;pronunciation&quot;: &quot;ヨーコソ&quot;</span>
<span class="cm">                  }</span>
<span class="cm">                }</span>
<span class="cm">              ],</span>
<span class="cm">     ...</span>
<span class="cm">}</span>
<span class="cm">*/</span>
</code></pre></div>
<p>これらのパーサは、あるセンテンスの長さが100文字以下といった単語だけではわからない情報などを扱うのに利用できます。また単語の品詞などの情報もあります。</p>

<h3 id="matcher">Matcher</h3>

<p><a href="https://github.com/azu/nlp-pattern-match" title="azu/nlp-pattern-match: Natural Language pattern matching library for JavaScript.">nlp-pattern-match</a>に含んでいるもう一方はマッチングライブラリです。</p>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>というmatcherは先ほどのパース結果のNodeを使った厳密なマッチをするライブラリです。</p>

<p>タグ関数を使って、厳密にマッチしたい部分だけをNodeとして表現できます。 
次の例では英語の<code>Bob &lt;動詞&gt; it.</code>にマッチする結果を取得できます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">PatternMatcher</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-pattern-match&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">EnglishParser</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-english&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">englishParser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EnglishParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">patternMatcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PatternMatcher</span><span class="p">({</span>
    <span class="nx">parser</span><span class="o">:</span> <span class="nx">englishParser</span>
<span class="p">});</span>
<span class="kr">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="nx">patternMatcher</span><span class="p">.</span><span class="nx">tag</span><span class="err">`</span><span class="nx">Bob</span> <span class="nx">$</span><span class="p">{</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
    <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">pos</span><span class="o">:</span> <span class="sr">/^VB/</span> <span class="c1">// verb</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">}</span> <span class="nx">it</span><span class="p">.</span><span class="err">`</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;Bob does it.&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">patternMatcher</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">);</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">result</span><span class="p">]</span> <span class="o">=</span> <span class="nx">results</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">deepEqual</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">index</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">end</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">column</span><span class="o">:</span> <span class="mi">13</span><span class="p">,</span>
        <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">offset</span><span class="o">:</span> <span class="mi">12</span>
    <span class="p">},</span>
    <span class="nx">start</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">column</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">offset</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>はより厳密なマッチをDSL的に書けるようにする趣旨のライブラリでしたが、もっと必要に応じて簡単に書けるライブラリとして<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>があります。</p>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は名前の通り、とりまえず<code>match</code>して、実際にそれが対象なのかを<code>test</code>し、最後に<code>replace</code>するという三段階のライブラリです。
正規表現で処理を書く場合に何でも一発の正規表現でやると難しくなるので、段階に分けてしまえばもっと簡単に書けるのではというコンセプトのライブラリです。</p>

<p>最小のコードは、ほぼ<code>String#replace</code>と同じです。</p>

<blockquote>
<p>Match -&gt; Replace</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/hello/i</span><span class="p">,</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&quot;Hello&quot;</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">,</span> <span class="s2">&quot;should be ok: true&quot;</span><span class="p">);</span>
<span class="c1">// 返り値はコマンドオブジェクト</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;1 replace&quot;</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm">[ { index: 0, match: &#39;Hello&#39;, replace: &#39;Hello&#39;, message: undefined } ]</span>
<span class="cm">*/</span>
</code></pre></div>
<p>少し複雑にして<code>/webkit/i</code>という文字列を<code>WebKit</code>に統一したいという例です。
単純に<code>/webkit/i</code>でマッチすると<code>node-webkit</code>も含まれてしまうため、<code>node-</code>から始まる<code>webkit</code>は除外するというルールを<code>test</code>に追加しています。</p>

<blockquote>
<p>Match -&gt; Test -&gt; Replace</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;webkit is matched,but node-webkit is not match&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/(\S*?)webkit/g</span><span class="p">,</span>
    <span class="nx">test</span><span class="o">:</span> <span class="p">({</span> <span class="nx">captures</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">captures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="s2">&quot;node-&quot;</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&quot;WebKit&quot;</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span> <span class="o">===</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&quot;should be ok: false&quot;</span><span class="p">);</span>
<span class="c1">// 返り値はコマンドオブジェクト</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;no replace&quot;</span><span class="p">);</span>
<span class="c1">// 実際に置換を適応する</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">replaceAll</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">).</span><span class="nx">output</span><span class="p">,</span> <span class="s2">&quot;WebKit is matched,but node-webkit is not match&quot;</span><span class="p">);</span>
</code></pre></div>
<p>先ほどの<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>を組み合わせると、適当にマッチした文字列の品詞をチェックしてから、それが意図した品詞なら置換するという処理が書けます。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">assert</span> <span class="nx">from</span> <span class="s2">&quot;assert&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">replaceAll</span><span class="p">,</span> <span class="nx">matchTestReplace</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;match-test-replace&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">PatternMatcher</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-pattern-match&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">EnglishParser</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;nlcst-parse-english&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">englishParser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EnglishParser</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">matcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PatternMatcher</span><span class="p">({</span> <span class="nx">parser</span><span class="o">:</span> <span class="nx">englishParser</span> <span class="p">});</span>
<span class="c1">// https://developers.google.com/style/clause-order</span>
<span class="c1">// NG: Click Delete if you want to delete the entire document.</span>
<span class="c1">// OK: To delete the entire document, click Delete.</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;Click Delete if you want to delete the entire document.&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">matchTestReplace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">pattern</span><span class="o">:</span> <span class="sr">/Click (\w+) if you want to (.+)./</span><span class="p">,</span>
    <span class="nx">replace</span><span class="o">:</span> <span class="p">({</span> <span class="nx">captures</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">captures</span><span class="p">);</span>
        <span class="k">return</span> <span class="err">`</span><span class="nx">To</span> <span class="nx">$</span><span class="p">{</span><span class="nx">captures</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span> <span class="nx">click</span> <span class="nx">$</span><span class="p">{</span><span class="nx">captures</span><span class="p">[</span><span class="mi">0</span><span class="p">]}.</span><span class="err">`</span>
    <span class="p">},</span>
    <span class="nx">test</span><span class="o">:</span> <span class="p">({</span> <span class="nx">all</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">tag</span><span class="err">`</span><span class="nx">Click</span> <span class="nx">$</span><span class="p">{</span> <span class="p">{</span>
            <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;WordNode&quot;</span><span class="p">,</span>
            <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
                <span class="c1">// Verb</span>
                <span class="nx">pos</span><span class="o">:</span> <span class="sr">/^VB/</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="p">}</span><span class="err">`</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">all</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span> <span class="o">===</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&quot;should be ok: true&quot;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">replaceAll</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">results</span><span class="p">).</span><span class="nx">output</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="s2">&quot;To delete the entire document, click Delete.&quot;</span><span class="p">);</span>
</code></pre></div>
<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は大雑把に正規表現でマッチして、testで本当に意図したものかをチェックしてから置換するという工程を書くためのものです。</p>

<p>このアプローチだと結構正規表現の気軽さを持ちつつ必要な部分で詳細な指定ができるため便利です。
一方、今わかってる問題として大雑把に一度マッチするため、後からマッチする範囲を狭めることができない(無駄な範囲をReplaceしてしまう)という問題があります。</p>

<p>いい案がある方はIssueとかPRを待ってます。</p>

<h2 id="ユースケース">ユースケース</h2>

<p>今このライブラリなどを使ってGoogleの<a href="https://developers.google.com/style/" title="About this guide  |  Google Developer Documentation Style Guide  |  Google Developers">Google Developer Documentation Style Guide</a>という開発者向けのドキュメントスタイルガイドを<a href="https://github.com/textlint/textlint" title="textlint">textlint</a>のルールとして実装しています。</p>

<ul>
<li><a href="https://github.com/textlint-rule/textlint-rule-preset-google%22textlint-rule/textlint-rule-preset-google:%20%5BWIP%5D%20Google%20Developer%20Documentation%20Style%20Guide%20for%20textlint.%22">textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.</a></li>
</ul>

<p><a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>や<a href="https://github.com/finnlp/en-pos" title="en-pos">en-pos</a>を中心に使って実装しています。
感触としては30分~1時間ぐらいで1つのルール(1つのページ)を実装できているので、まあまあ効率的に実装できているかなーと思います。</p>

<p>自分が英文法がよく分かってなかったり、係り受け解析ができない問題、そもそも主観的なルールなどもあるのですべてが実装できるわけではないですが、大雑把にマッチして意図して結果へ置換する処理を書けている感じがします。</p>

<p>興味がある人は<a href="https://github.com/textlint-rule/textlint-rule-preset-google#rules" title="textlint-rule/textlint-rule-preset-google: [WIP] Google Developer Documentation Style Guide for textlint.">textlint-rule/textlint-rule-preset-google</a>にPull Request待っています。</p>

<h2 id="おわりに">おわりに</h2>

<p>textlintのルールなどを書くときに使える<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/nlcst-pattern-match" title="nlcst-pattern-match">nlcst-pattern-match</a>というライブラリ群について紹介しました。</p>

<p>文字列処理は色々文脈に依存したり、そもそも自然言語は壊れた文字列がエラーにならないなどの問題があるため難しいです。完璧な方法はないため目的にあった方法を使う必要があります。
たとえば、今回作った<a href="https://github.com/azu/nlp-pattern-match/tree/master/packages/match-test-replace" title="match-test-replace">match-test-replace</a>は平面的に文字列マッチするだけなので、文字列を構造として捉えるならば色々不足している感じがします。</p>

<p>これ以外にもセンテンス分解やピリオドの位置チェック、ですます・である調の分析などいろんなライブラリを書いています。</p>

<ul>
<li><a href="https://github.com/textlint/textlint/wiki/Collection-of-textlint-rule#global" title="Collection of textlint rule · textlint/textlint Wiki">Collection of textlint rule · textlint/textlint Wiki</a></li>
</ul>

<p>textlintをコマンド一発で作り始めることができる<code>create-textlint-rule</code>というコマンドもあるので、色々作って見ると面白いかもしれません。</p>

<ul>
<li><a href="http://efcl.info/2016/12/14/create-textlint-rule/" title="textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch">textlintのルールを簡単に作り始めることができるツールを作りました | Web Scratch</a></li>
</ul>
 ]]></content>
 </entry>
 
 <entry>
   <title>Alfred上で自分のはてなブックマークを検索できるWorkflow</title>
   <link href="http://efcl.info/2017/10/20/alfred-hatenabookmark/"/>
   <updated>2017-10-20T19:48:00+09:00</updated>
   <id>http://efcl.info/2017/10/20/alfred-hatenabookmark</id>
   <content type="html"><![CDATA[ <p>Alfredで自分のはてブデータを取得して絞り込んで検索できるWorkflowを書きました。</p>

<ul>
<li><a href="https://github.com/azu/alfred-hantebookmark-mydata" title="azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred">azu/alfred-hantebookmark-mydata: Search My HatenaBookmark in Alfred</a></li>
</ul>

<p><img src="https://media.giphy.com/media/3ov9k8YySjxOsxvNHW/giphy.gif" alt="screenshot"></p>

<p>このWorkflowはNode.jsでAlfred Workflowを書ける<a href="https://github.com/sindresorhus/alfy" title="alfy">alfy</a>というフレームワークを使っています。
そのため、npmでWorkflowをインストール、更新できます。
(必然的にNode.js環境が必要です)</p>

<h2 id="インストール">インストール</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">npm install --global alfred-hantebookmark-mydata
</code></pre></div>
<h2 id="設定">設定</h2>

<p>どのはてなアカウントのブックマークを検索するかの設定が必要なので、Workflowの設定から<code>HATENA_ACCOUNT_NAME</code>という変数に自分のアカウント名を入れる必要があります。</p>

<ol>
<li>Open workflow settings</li>
<li>Set Your hatena account name to <code>HATENA_ACCOUNT_NAME</code></li>
</ol>

<p><img src="https://monosnap.com/file/cTzt4ieHD2wGDYb2ANoUh5IXeS6SQA.png" alt="setting"></p>

<h2 id="制限">制限</h2>

<p><a href="https://github.com/sindresorhus/alfy" title="alfy">alfy</a>は基本的に一度きりの実行を想定した作りになっているようです。
なので、入力 -&gt; Nodeでスクリプトを実行 -&gt; 結果を表示の一回だけで終わってる感じです。</p>

<p>ほしかったのは、スクリプトを実行 -&gt; 結果をAlfredで絞り込み という感じのものでした。</p>

<p><code>Script Filter</code>の<a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/#alfred-filters-results" title="Match Mode">Match Mode</a>を使うとそれが実現できる(このWorkflowもこれ)のですが、このMatch Modeのフィルタリングは日本語に対応してない感じがします。</p>

<p>境界となる文字列が記号やスペースのみとなっていて、その結果に対して先頭からのマッチのみなので、必然的に日本語だと上手くマッチしない問題があります。形態素解析とかして分解すればいいのですが、処理時間的に現実的じゃない感じがしました。(差分更新、キャッシュを上手く使えばできそうな気がするけど、PR歓迎)</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">自分のはてなブックマークをAlfredから検索してして絞り込むやつ書いた。<br>もっと早く動くようにできないかな?(後マッチングが日本語不安定な気はする)<a href="https://t.co/8z3GzWGzwW">https://t.co/8z3GzWGzwW</a> <a href="https://t.co/DmhYJ8Dh6v">pic.twitter.com/DmhYJ8Dh6v</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/921017924898275328?ref_src=twsrc%5Etfw">October 19, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
 ]]></content>
 </entry>
 
 <entry>
   <title>kuromoji.jsで形態素解析した結果とテキストの関係をビジュアライズする</title>
   <link href="http://efcl.info/2017/10/19/text-map-kuromoji/"/>
   <updated>2017-10-19T09:45:00+09:00</updated>
   <id>http://efcl.info/2017/10/19/text-map-kuromoji</id>
   <content type="html"><![CDATA[ <p><a href="https://github.com/azu/text-map-kuromoji">azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ</a>というツールを作った話。</p>

<p><a href="https://ipsj.ixsq.nii.ac.jp/ej/?action=pages_view_main&amp;active_action=repository_view_main_item_detail&amp;item_id=70540&amp;item_no=1&amp;page_id=13&amp;block_id=8" title="くだけた表現を高精度に解析するための正規化ルール自動生成手法">くだけた表現を高精度に解析するための正規化ルール自動生成手法</a>という論文誌では、「ヵゎぃぃ」，「ゎた Uゎ」みたいな普通の形態素解析では未知語として検出されるものをどうやって正規化していくかという話が書かれていました。</p>

<p>これを読んでいて面白かったのは形態素解析をした結果の未知語となった部分と穴埋め的にパターンを作って、そのパターンにマッチする同じようなテキストを探すというアプローチでした。</p>

<p>プログラミング言語と違って、大抵の自然言語パーサはパース失敗ではなく、単なる未知な言葉として検出されます。
また、その未知な言葉は常に増えていて、さきほどの<a href="https://ipsj.ixsq.nii.ac.jp/ej/?action=pages_view_main&amp;active_action=repository_view_main_item_detail&amp;item_id=70540&amp;item_no=1&amp;page_id=13&amp;block_id=8" title="くだけた表現を高精度に解析するための正規化ルール自動生成手法">くだけた表現を高精度に解析するための正規化ルール自動生成手法</a>によると手動では登録できない増加量らしいです。</p>

<blockquote>
<p>著者らの経験では，1 人月あたり約 3 万種類の未知語登録が可 能であるのに対し，ブログ 600 万文を著名な形態素解析器 MeCab 3) を用いて解析したと ころ，約 65 万種類の未知語が検出されたことから，ブログ文書のくだけた表現を正しく解 析することは困難といえる.</p>
</blockquote>

<p>この辺のスラング的な単語もクローリングしたデータから辞書を作ることで扱える量が多い辞書として<a href="https://github.com/neologd/mecab-ipadic-neologd" title="mecab-ipadic-NEologd">mecab-ipadic-NEologd</a>が有名です。</p>

<p>で、話を戻して形態素解析をした結果の未知語となるパターンってどれぐらいあるのかなーと思いました。
普通に形態素解析した結果を見ればいいのですが、それは品詞付きの情報が並ぶだけだったり、JSONだったりして、テキストのこの部分が未知語というのがあまり見やすくはありませんでした。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">今日もしないとね。
今日    名詞,副詞可能,*,*,*,*,今日,キョウ,キョー
も      助詞,係助詞,*,*,*,*,も,モ,モ
し      動詞,自立,*,*,サ変・スル,未然形,する,シ,シ
ない    助動詞,*,*,*,特殊・ナイ,基本形,ない,ナイ,ナイ
と      助詞,接続助詞,*,*,*,*,と,ト,ト
ね      助詞,終助詞,*,*,*,*,ね,ネ,ネ
。      記号,句点,*,*,*,*,。,。,。
</code></pre></div>
<p>入力されたテキストと特定の位置に関する情報をビジュアライズするパターンについてはSourceMapを調べていたときに<a href="http://sokra.github.io/source-map-visualization/" title="source-map-visualization">source-map-visualization</a>というサイトがあるのを思い出しました。</p>

<p><a href="http://sokra.github.io/source-map-visualization/"><img src="http://efcl.info/wp-content/uploads/2017/10/19-1508374636.png" alt="sourcemap"></a></p>

<ul>
<li><a href="http://efcl.info/2014/0622/res3933/" title="Source Mapを扱う関連ライブラリのまとめ | Web Scratch">Source Mapを扱う関連ライブラリのまとめ | Web Scratch</a></li>
</ul>

<p>これの形態素解析版があると良さそうと思いました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これの形態素解析版ほしいな  &quot;source-map-visualization&quot;  <a href="https://t.co/PZuGwXdYIQ">https://t.co/PZuGwXdYIQ</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920646507254050822?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>ここで、既にJavaScriptとそのパース結果からECMAScriptのバージョンをToken毎に割り出すツールを作ってたのを思い出しました。</p>

<p><a href="https://azu.github.io/ecmascript-version-detector/"><img src="http://efcl.info/wp-content/uploads/2016/08/04-1470309082.png" alt="image"></a></p>

<ul>
<li><a href="http://efcl.info/2016/08/04/ecmascript-version-detector/" title="そのコードが標準化されてるJavaScriptなのかを判定する方法 | Web Scratch">そのコードが標準化されてるJavaScriptなのかを判定する方法 | Web Scratch</a></li>
</ul>

<p>これをforkして<a href="https://github.com/takuyaa/kuromoji.js#api" title="kuromoji.js">kuromoji.js</a>で形態素解析してその結果をビジュアライズするものを作りました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://t.co/zypZDjn20j">https://t.co/zypZDjn20j</a><a href="https://t.co/UOhjzSxMhI">https://t.co/UOhjzSxMhI</a><br><br>kuromojiで形態素解析した結果をビジュアライズするやつできた。<br>テキストをクリックすると対応した位置のトークン情報が表示される。 <a href="https://t.co/AqrbhMJFBm">pic.twitter.com/AqrbhMJFBm</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920676180797173762?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<ul>
<li>サイト: <a href="https://azu.github.io/text-map-kuromoji/">text-map-kuromoji</a></li>
<li>ソースコード:<a href="https://github.com/azu/text-map-kuromoji">azu/text-map-kuromoji: テキストを形態素解析した結果とテキストの関係をビジュアライズするエディタ</a></li>
</ul>

<p>それで目的だった壊れた日本語は未知語として検出されるのかを確かめてみましたが、てにをはを間違えただけとかその程度だとやっぱり未知語として検出されないということがわかりました。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">日本語の文章ってやっぱり普通に書くと未知語が結構出にくいっぽい気がする。<br><br>変換ミスだとアルファベットが混ざってくるので未知語 = 壊れた文章の検出ができる可能性はありそう。<br>壊れた日本語は検出するの難しいかもなー。パースが失敗しない問題 <a href="https://t.co/EhpmHv34LD">pic.twitter.com/EhpmHv34LD</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/920678011141201920?ref_src=twsrc%5Etfw">October 18, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>一方、ローマ字入力のIME特有のtypoはアルファベットが不自然に混ざるからか未知な言葉として検出されやすくかったです(論文誌の形状が似てる言葉もこういうタイプ)</p>

<ul>
<li><a href="https://github.com/textlint-ja/textlint-rule-ja-unnatural-alphabet" title="textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール">textlint-ja/textlint-rule-ja-unnatural-alphabet: 不自然なアルファベットを検知するtextlintルール</a></li>
</ul>

<p>やっぱり形態素解析に失敗するパーサの必要性を感じました。</p>
 ]]></content>
 </entry>
 
 <entry>
   <title>Clean ArchitectureとBuilding Evolutionary Architecturesを読んだ</title>
   <link href="http://efcl.info/2017/10/09/clean-architecture-and-building-evolutionary-architectures/"/>
   <updated>2017-10-09T23:27:00+09:00</updated>
   <id>http://efcl.info/2017/10/09/clean-architecture-and-building-evolutionary-architectures</id>
   <content type="html"><![CDATA[ <p><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture</a>という本と<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>という本を最近読んだのでざっくりとしたメモ。（両方共2-3時間ぐらいでざっくりとしか読んでないので、解釈間違いは普通にありそうです）</p>

<p>両方共アーキテクチャに対するメタ的な視点な部分があるので、合わせて読むと面白いかも。</p>

<h2 id="clean-architecture">Clean Architecture</h2>

<p>Clean Architecture(Clean Codeの人のシリーズ)という本を読んだ。</p>

<ul>
<li><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture: A Craftsman&#39;s Guide to Software Structure and Design | InformIT</a>

<ul>
<li>PDFとかEpubとかMobiが買える</li>
</ul></li>
</ul>

<p><a href="https://www.amazon.com/Robert-C.-Martin/e/B000APG87E/ref=dp_byline_cont_book_1" title="Robert C. Martin">Robert C. Martin</a>の<code>Clean *</code>シリーズでいわゆる<a href="http://blog.tai2.net/the_clean_architecture.html" title="クリーンアーキテクチャ">クリーンアーキテクチャ</a>そのものだけを扱ったという内容ではない。</p>

<p>でもクリーンアーキテクチャについて紹介してる章もある。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a> Clean ArchitectureがClean Architectureについて書いてる章があった… <a href="https://t.co/75EB3FW4U3">pic.twitter.com/75EB3FW4U3</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912128410343768064?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アーキテクチャのルール自体はシステム/アプリケーションのサイズにかかわらずいつも同じという話。
これはアーキテクチャのメタ的な感じっぽい。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a> シングルスレッドのアプリ、マルチスレッドのアプリ、重量プロセスのアプリ、軽量プロセスのアプリ色々作ってきたけどアーキテクチャのルールはいつも同じ<br><br>&gt; The architecture rules are the same!</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912117809714307072?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>そもそもの話としてアーキテクチャを決めるのはプログラマ（アーキテクト）で、その人のスキルとかチームによって異なる選択をしてる。なので、暗黙的に、異なるチームでは異なるアーキテクチャの決定をする。</p>

<p>アーキテクチャの目的は開発、デプロイ、運用、メンテをやりやすくするため。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/CleanArchitecture?src=hash&amp;ref_src=twsrc%5Etfw">#CleanArchitecture</a>  良いアーキテクチャがサポートすべきもの <a href="https://t.co/xp1upNzbO5">pic.twitter.com/xp1upNzbO5</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/912124439344562176?ref_src=twsrc%5Etfw">September 25, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>アーキテクトは境界を見つけることが仕事で、そのboundariesの線を引くこと。
境界はDBとかテストとかアプリケーションとかcontextとか色々なところにある。
それを気をつけて認識しないといけない。また同時に認識した境界を無視しなければならない。
なぜなら、すべてを実装するのはコストが高いため。</p>

<p>後は境界を引いた上でそれぞれのコンポーネントを結合するプラグインの仕組みなどについて。
フレームワークをコードに入れるのではなく、コードに対してフレームワークというコンポーネントをプラグインとして入れるようにするとか。</p>

<blockquote>
<p>Don’t marry the framework!</p>
</blockquote>

<p>境界をちゃんとして、依存関係をちゃんとしよう的な話が多かった。</p>

<h2 id="building-evolutionary-architectures">Building Evolutionary Architectures</h2>

<p>Building Evolutionary ArchitecturesというEvolutionary Architectures(進化的アーキテクチャ)についての本を読んだ。</p>

<ul>
<li><a href="https://www.thoughtworks.com/books/building-evolutionary-architectures" title="Building Evolutionary Architectures | ThoughtWorks">Building Evolutionary Architectures | ThoughtWorks</a></li>
<li><a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books</a></li>
</ul>

<p>ThoughtWorksの人達が書いた本なので、アーキテクチャに対するメタ的な目線が多かった。</p>

<p>そもそも、Evolutionary Architectures(進化的アーキテクチャ)とは何かという話や進化的アーキテクチャというのは何を目的にしているか。(adaptable Architectureと言わなかったのはなぜかなど?)</p>

<blockquote class="twitter-tweet" data-partner="tweetdeck"><p lang="en" dir="ltr">Why Evolutionary? <a href="https://t.co/dhWQIhUg4k">pic.twitter.com/dhWQIhUg4k</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917406155374157824?ref_src=twsrc%5Etfw">October 9, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>進化的アーキテクチャは次の3つのポイントが主になってる的な話。</p>

<ul>
<li>Incremental change</li>
<li>Guided change with fitness functions</li>
<li>Appropriate coupling</li>
</ul>

<p>継続的に変更すること(Incremental change)ができ、その変更/進化が目的の方向なのかをチェックできる指標をちゃんと持つこと(Guided change with fitness functions)。
つまりアーキテクチャを選ぶことが目的でなく、Fitness functionとなる指標がありそれに対するアーキテクチャを選べているかを確認できるようにすることが目的。</p>

<p>ある変化に対してその変化が目的に沿ったものだったかを計測できる指標のことをfitness functionと言っているという理解。</p>

<blockquote>
<p>A fitness function is a particular type of objective function that is used to summarise, as a single figure of merit, how close a given design solution is to achieving the set aims.</p>
</blockquote>

<p>元ネタは<a href="https://en.wikipedia.org/wiki/Fitness_function" title="Fitness function - Wikipedia">Fitness function - Wikipedia</a>とのこと。</p>

<p>でてくる用語が抽象的なので次の動画も見たほうが分かりやすいかも。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/SzSZpZI02Jg" frameborder="0" allowfullscreen></iframe>

<p>そのため、何がFitness functionなのかは、作るシステム/アプリケーションによって異なる。
あるシステムではパフォーマンスやセキュリティが大事だったり、作るものによって異なる = 進化の方向はアプリケーションで異なる。</p>

<p>テストとかパフォーマンスとかそれぞれコンポーネント毎にfitness functionがあり、システム全体でのバランスを検証する。
スケーラビリティとか、パフォーマンス、セキュリティとかデータスキーマとかプロジェクトにおける指標となるものをちゃんと決めてないと、都度の変化はただの反応的な変化(reactionary architecture)となるので、最初にシステム全体として進化の指標を決めることは大事という話。
つまり、正しい方向を向いてるかどうかという指標はちゃんと決めないと、正しさが分からずに問題となるよという話だと思う。</p>

<p>その指標が決まっているだけでは継続的な進化はできないので、Incremental changeをするためには継続的インテグレーション(CI)と継続的デリバリー(CD)といったリリースサイクルに関わるもの大事という話が結構でてきた。(また、このデプロイの頻度とかは物理的なものとデジタル的なもので異なるという話とか。)</p>

<p>リリースサイクルの例としてGitHubとかの例がでてきた。</p>

<ul>
<li><a href="https://githubengineering.com/move-fast/" title="Move Fast and Fix Things | GitHub Engineering">Move Fast and Fix Things | GitHub Engineering</a></li>
</ul>

<p>なんでリリースサイクルが大事かというとリリース速度と進化的アーキテクチャに相関が存在する。
つまりプロジェクトのサイクルタイムによってアーキテクチャの進化速度が決まり、より早いサイクルはより早い進化を促すことができるため。</p>

<p>継続的にデプロイするには、そのシステムがモジュール化されていることが大事。
そのモジュール化を行う方法?としていろんなアーキテクチャがあるよという、既存のいろんなアーキテクチャ紹介(モノリシック、レイヤードアーキテクチャ、<a href="https://en.wikipedia.org/wiki/Event-driven_architecture" title="Event-driven architecture">Event-driven architecture</a>、serverlessとか)</p>

<p>けど</p>

<blockquote>
<p>Don’t build an architecture just because it will be fun meta-work.</p>
</blockquote>

<p>だよという話。</p>

<hr>

<p>アーキテクチャの対義語(アンチパターン)として泥団子(<a href="https://ja.wikipedia.org/wiki/%E5%A4%A7%E3%81%8D%E3%81%AA%E6%B3%A5%E3%81%A0%E3%82%93%E3%81%94" title="Big ball of mud">Big ball of mud</a>)の話。
基本的に泥団子は進化することができないので、新しい変化を取り込むことができない。
いくかの柔軟性を取り込んでいくことでアーキテクチャ全体を変更せずに、取り入れることができる。</p>

<p>柔軟性についてでどういうものがあるかという話。</p>

<ul>
<li>必要ない変数を取り除く

<ul>
<li>Immutabilityを取り入れる</li>
<li>Immutable infrastructureは必要ない変数を取り除く</li>
</ul></li>
<li>決定を可逆にする

<ul>
<li>Make Decisions Reversible</li>
<li>Revertable、 blue/green deployment</li>
</ul></li>
<li>Prefer Evolvable over Predictable</li>
<li>Build Anticorruption Layers

<ul>
<li>腐敗防止を設ける</li>
</ul></li>
<li>Mitigate External Change

<ul>
<li>外部ライブラリの変更の影響を小さく保つ</li>
<li>left-padの教訓</li>
</ul></li>
<li>Updating Libraries Versus Frameworks

<ul>
<li>アーキテクトはライブラリとフレームワークを区別する</li>
<li>開発者のコードがライブラリを呼び出す</li>
<li>フレームワークは開発者のコードを呼び出す</li>
<li>多くの場合はライブラリを選ぶことで影響が軽減される</li>
<li>フレームワークは積極的に依存を更新する(セキュリティアップデート)</li>
<li>ライブラリは必要になったら更新する(update when neededモデル)</li>
</ul></li>
<li>Prefer Continuous Delivery to Snapshots

<ul>
<li>The conflict between Continuous Delivery and traditional Agile - kief.com</li>
<li>-LATESTみたいなスナップショットじゃなくてタグ切って管理</li>
</ul></li>
<li>これはMake Decisions Reversibleとも繋がる(revert可能にする)

<ul>
<li>Prefer Continuous Delivery over snapshots for (external) dependencies.</li>
<li>継続的デプロイができる環境では外部依存についての考えかたも変える</li>
<li>2つの指標を導入する</li>
<li>fluid

<ul>
<li>自動的に依存を更新する</li>
</ul></li>
<li>guarded

<ul>
<li>固定 -&gt; fluidに戻すように修正する</li>
</ul></li>
</ul></li>
<li>Version Services Internally

<ul>
<li>一度に管理するサービスのエンドポイントのバージョンは2つまで</li>
</ul></li>
</ul>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">left-padだ <a href="https://t.co/JctKbVAVfH">pic.twitter.com/JctKbVAVfH</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917040368339755008?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>外部モジュールのバージョン管理の話が結構面白かった。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ライブラリとフレームワークの区別について<br>開発者のコードがライブラリを呼び出す。一方、フレームワークは開発者のコードを呼び出す。<br>多くの場合はライブラリを選ぶことで影響が軽減される。<br><br>フレームワークのアップデートは積極的に行い、ライブラリのアップデートは必要になったら行う。</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917041667881893889?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>つまり、フレームワークは自分が制御するわけではないので、アップデートは積極的に行わないと進化できなくなる可能性がある。一方ライブラリは必要になったタイミングで更新すればいいという話。</p>

<p>またフレームワークに関するアンチパターンとしてLast 10%という話があった。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">Antipattern: Last 10% Trap<br>- あるフレームワークで要求の80%が実現できることが確認できていた<br>- ハックをつかって10%+できた<br>- しかし最後の10%が無理で要求を満たせなかったので、フレームワークを使うのをやめる</p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917045990917468161?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<hr>

<p>泥団子から進化することはできないのでどうやって分解するかという話。</p>

<p>泥団子を進化させることはできない。(本で ball of mud は結構出てくる)
泥団子を再加工するコストが莫大なものとなる。これを変質させる方法の第一歩はモジュール化。
最初に行うべき作業は現在のシステムからモジュールの発見すること。</p>

<p>ここでも境界を見つける話や泥団子からのマイグレーション方法についてなど。
モジュールへ分解していくのだけど、安易に分解するとパフォーマンスが問題になることがあるよとか、分解した結果複数のモジュールが共有してる共有モジュールはどうするの?とか。</p>

<p>どうにかして境界を見つけて分解することができたら、取捨選択のステップへ。ここでも指標となるFitness functionがでてくる。</p>

<blockquote>
<p>Next, developers choose and detach the chosen service from the monolith, fixingany calling points. Fitness functions play a critical role here — developersshould build fitness functions to make sure the newly introduced integrationpoints don’t change, and add consumer-driven contracts.</p>
</blockquote>

<hr>

<p>またIncremental changeの話に戻って</p>

<p>サイクルタイムはビジネスメトリクスであるという話。ならなぜ、短い時間で繰り返せるということはコストが小さくなるということ。最小のコストで試すことができる。
このサイクルタイムを短くするにはいろいろ自動化が必要になるという話。</p>

<p>変化のリスクを小さくするのが進化的アーキテクチャの考え方。
その変化において大きなBreaking Changeを減らす/なくしIncremental changeできるようにする。
それによって、新しいものを取り入れる余地を作る。</p>

<p>雑に進化的アーキテクチャとは何かというと</p>

<ul>
<li>予測可能性より進化性</li>
<li>進化のリスクを小さくする(痛みを伴うBreaking Changeなしに進化)</li>
<li>依存するライブラリとフレームワークの管理とリスクを考えて意思決定をする</li>
<li>可逆性を持つ決定を取り入れる</li>
<li>腐敗防止層を設ける</li>
<li>進化の速度とリリースサイクルには相関がある

<ul>
<li>短い時間で繰り返せるということは、試すコストが小さい</li>
<li>プロジェクトのサイクルタイムによってアーキテクチャの進化速度が決まる</li>
</ul></li>
<li>泥団子は進化することができないので、柔軟性のポイントを取り入れる</li>
<li>目的に対する成長なのかを計測する(そのため実装の詳細を無視してはいけない)</li>
</ul>

<p>アーキテクチャは方程式ではなく、進行中のプロセスのスナップショットにすぎないという話。</p>

<hr>

<p>読み終わってそういえば<a href="http://bliki-ja.github.io/SacrificialArchitecture/" title="犠牲的アーキテクチャ">犠牲的アーキテクチャ</a>というものが同じくThoughtWorksのMartin Fowlerさんが言っていたのを思い出した。
進化的アーキテクチャはより緩やか/より前進的な犠牲的アーキテクチャと言えるのかもしれないなーとか思った。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">最近聞かなくなった気もするけど犠牲的アーキテクチャの話も少しでてきてた気がする。<br>進化的アーキテクチャは緩やかな犠牲的アーキテクチャと言えるのかもしれない<a href="https://t.co/FckZSanZai">https://t.co/FckZSanZai</a></p>&mdash; azu (@azu_re) <a href="https://twitter.com/azu_re/status/917070245768028161?ref_src=twsrc%5Etfw">October 8, 2017</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="おわり">おわり</h2>

<p><a href="http://www.informit.com/store/clean-architecture-a-craftsmans-guide-to-software-structure-9780134494319" title="Clean Architecture: A Craftsman&amp;#39;s Guide to Software Structure and Design | InformIT">Clean Architecture</a>と<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>を読んでの雑なメモ書き。</p>

<p>両方共、アーキテクチャとは境界を見つけることという話や異なるチーム異なるシステムでは異なるアーキテクチャがあるよという話をしてたのが良かった。</p>

<p>あとはアーキテクチャ選び遊びは楽しいけど、目的にあってないアーキテクチャを選ぶアーキテクチャシンドロームにかかってはいけないという話も共通してた気がする。</p>

<blockquote>
<p>Don’t build an architecture just because it will be fun meta-work.</p>
</blockquote>

<p>どちらの本も読んで何か実践的な何かを学べるタイプのものではないので、その辺を見たい場合は別の本を見たほうが良さそう。</p>

<ul>
<li><a href="https://www.gitbook.com/book/delftswa/desosa-2017/details" title="Delft Students on Software Architecture: DESOSA 2017 · GitBook">Delft Students on Software Architecture: DESOSA 2017 · GitBook</a></li>
<li><a href="http://ec.nikkeibp.co.jp/item/books/P98480.html" title=".NETのエンタープライズアプリケーションアーキテクチャ">.NETのエンタープライズアプリケーションアーキテクチャ</a></li>
<li><a href="https://www.amazon.com/dp/1118714709/" title="Patterns, Principles, and Practices of Domain-Driven Design: Scott Millett, Nick Tune: 0787721845461: Amazon.com: Books">Patterns, Principles, and Practices of Domain-Driven Design: Scott Millett, Nick Tune: 0787721845461: Amazon.com: Books</a>

<ul>
<li><a href="http://efcl.info/2016/09/30/architecture-refs/" title="アーキテクチャをめぐるたび | Web Scratch">アーキテクチャをめぐるたび | Web Scratch</a></li>
</ul></li>
</ul>

<p>どちらかというと次のものに近い方向だけど、もう少し技術よりなので短い時間で読みやすい。</p>

<ul>
<li><a href="https://www.amazon.co.jp/dp/B00ZF44J0I/" title="ソフトウェアシステムアーキテクチャ構築の原理">ソフトウェアシステムアーキテクチャ構築の原理</a></li>
<li><a href="https://leanpub.com/livingdocumentation" title="Living Documentation by design, with Domain-Driven Design">Living Documentation by design, with Domain-Driven Design</a>

<ul>
<li><a href="http://efcl.info/2017/05/12/Living-Documentation-DDD/" title="Living Documentation by design, with Domain-Driven Designを読んだ | Web Scratch">Living Documentation by design, with Domain-Driven Designを読んだ | Web Scratch</a></li>
</ul></li>
</ul>

<p>感想の量からもわかるように<a href="https://www.amazon.com/dp/1491986360/" title="Building Evolutionary Architectures: Support Constant Change: Neal Ford, Rebecca Parsons, Patrick Kua: 9781491986363: Amazon.com: Books">Building Evolutionary Architectures</a>は結構面白かった。</p>
 ]]></content>
 </entry>
 

</feed>
